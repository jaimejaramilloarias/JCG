<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jazz Comping Generator - Jaime Jaramillo Arias</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' x2='1' y1='1' y2='0'%3E%3Cstop stop-color='%2338bdf8'/%3E%3Cstop offset='.6' stop-color='%23a78bfa'/%3E%3Cstop offset='1' stop-color='%23fbbf24'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='64' height='64' rx='14' fill='%23121826'/%3E%3Cpath d='M18 46c5-4 9-9 14-18 4 8 9 13 14 17' fill='none' stroke='url(%23g)' stroke-width='6' stroke-linecap='round'/%3E%3Ccircle cx='18' cy='46' r='4' fill='%2338bdf8'/%3E%3Ccircle cx='32' cy='28' r='4' fill='%23a78bfa'/%3E%3Ccircle cx='46' cy='45' r='4' fill='%23fbbf24'/%3E%3C/svg%3E" />
  <style>
    :root{
      --bg:#0a0f1c;
      --panel:#0f1628;
      --panel2:#12213c;
      --txt:#e8edf7;
      --muted:#9bb1c9;
      --line:#1f2e46;
      --accent:#1dd4f2;
      --accent2:#f59e0b;
      --bad:#f87171;
      --ok:#22c55e;
      --shadow: 0 18px 36px rgba(4,6,12,.32);
      --glow: 0 0 0 1px rgba(29,212,242,.26), 0 18px 32px rgba(0,0,0,.48);
      --frost: blur(18px);
      --r:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:'Inter', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1100px 620px at 12% 12%, rgba(29,212,242,.14), transparent 55%),
                  radial-gradient(1200px 760px at 88% 8%, rgba(245,158,11,.12), transparent 58%),
                  linear-gradient(145deg, #070c16 0%, #0d1323 48%, #070c16 100%);
      color:var(--txt);
      position:relative;
      min-height:100%;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      background: radial-gradient(720px 460px at 28% 78%, rgba(29,212,242,.10), transparent 60%), radial-gradient(660px 400px at 76% 80%, rgba(245,158,11,.12), transparent 60%);
      pointer-events:none;
      opacity:.85;
    }
    .wrap{
      max-width:1180px; margin:26px auto 42px; padding:0 18px 40px;
    }
    header{
      display:flex; align-items:center; justify-content:space-between; gap:20px; margin-bottom:18px; flex-wrap:wrap;
    }
    header.hero{padding:18px 18px 16px; border:1px solid rgba(255,255,255,.08); background: linear-gradient(135deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); box-shadow: var(--glow); backdrop-filter: var(--frost); border-radius:18px;}
    .brand{display:flex; flex-direction:column; gap:6px;}
    .eyebrow{margin:0; font-size:11px; letter-spacing:.4px; text-transform:uppercase; color:rgba(255,255,255,.68); font-weight:800;}
    h1{margin:0; font-size:32px; letter-spacing:.1px; font-weight:800; color:#f8fafc; text-shadow:0 14px 40px rgba(0,0,0,.35); font-family:'Space Grotesk', 'Inter', system-ui, -apple-system, sans-serif;}
    .sub{color:var(--muted); font-size:13px; margin-top:2px; line-height:1.55;}
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
      backdrop-filter: var(--frost);
    }
    .megaCard{padding:10px 10px 18px; border:1px solid rgba(255,255,255,.06); box-shadow: var(--glow);}
    .megaHd{border-bottom:1px solid rgba(35,50,74,.7); background: rgba(24,34,56,.65); padding:10px 12px; display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .megaHd .title{font-size:13px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted);}
    .megaHd .mini{color:rgba(255,255,255,.82); font-size:12px;}
    .megaBd{display:flex; flex-direction:column; gap:16px; padding:14px;}
    .heroMeta{display:flex; align-items:center; gap:14px; flex-wrap:wrap; justify-content:flex-end;}
    .controlBar{display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:12px; align-items:stretch;}
    .controlCluster{border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:12px 14px; background: linear-gradient(180deg, rgba(18,26,44,.88), rgba(12,18,32,.92)); display:flex; flex-direction:column; gap:10px; box-shadow: 0 14px 32px rgba(0,0,0,.30); position:relative; overflow:hidden;}
    .controlCluster::before{content:""; position:absolute; inset:0; background: linear-gradient(135deg, rgba(29,212,242,.10), transparent 45%); opacity:.9; pointer-events:none;}
    .controlCluster > *{position:relative;}
    .clusterTitle{font-size:12px; color:var(--muted); letter-spacing:.3px; text-transform:uppercase; font-weight:800;}
    .clusterActions{display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
    .miniStat{font-size:12px; color:var(--muted); margin-left:auto;}
    .card .hd{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(35,50,74,.8);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background: linear-gradient(135deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    }
    .card .hd .title{font-size:13px; color:var(--muted); letter-spacing:.4px; text-transform:uppercase; letter-spacing:.32px}
    .card .bd{padding:14px}
    textarea{
      width:100%; min-height:150px; padding:14px 14px;
      border-radius:16px; border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      color:var(--txt); font-size:14px; line-height:1.45;
      outline:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    textarea:focus{border-color: rgba(125,211,252,.6); box-shadow:0 0 0 4px rgba(125,211,252,.12)}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .btn{
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(135deg, rgba(255,255,255,.08), rgba(29,212,242,.08));
      color:var(--txt);
      padding:10px 14px;
      border-radius:14px;
      cursor:pointer;
      font-weight:700;
      letter-spacing:.15px;
      font-size:13px;
      transition: transform .06s ease, border-color .15s ease, background .15s ease, box-shadow .15s ease;
      user-select:none;
      box-shadow: 0 12px 20px rgba(0,0,0,.26);
    }
    .btn:hover{border-color: rgba(29,212,242,.45); background: linear-gradient(135deg, rgba(255,255,255,.12), rgba(29,212,242,.12)); box-shadow: 0 16px 24px rgba(0,0,0,.32)}
    .btn:active{transform: translateY(1px)}
    .btn.primary{border-color: rgba(29,212,242,.70); background: linear-gradient(135deg, rgba(29,212,242,.24), rgba(29,212,242,.10))}
    .btn.purple{border-color: rgba(245,158,11,.65); background: linear-gradient(135deg, rgba(245,158,11,.20), rgba(245,158,11,.08))}
    .btn.bad{border-color: rgba(251,113,133,.65); background: linear-gradient(135deg, rgba(251,113,133,.18), rgba(251,113,133,.08))}
    .btn:disabled{opacity:.45; cursor:not-allowed}
    select,
    input[type="number"]{
      width:100%;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      color:var(--txt);
      outline:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    select:focus,
    input[type="number"]:focus{border-color: rgba(125,211,252,.6); box-shadow:0 0 0 4px rgba(125,211,252,.12)}
    .label{font-size:12px; color:var(--muted); margin-bottom:6px; display:flex; align-items:center; gap:8px}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:7px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(135deg, rgba(255,255,255,.09), rgba(29,212,242,.05));
      color:var(--txt);
      font-size:12px;
      cursor:pointer;
      user-select:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .pill:hover{border-color: rgba(29,212,242,.42)}
    .pill.status{padding:10px 14px; font-weight:700; letter-spacing:.2px; box-shadow:0 12px 22px rgba(0,0,0,.28)}
    .pill small{color:var(--muted); font-weight:600}
    .chips{display:flex; flex-wrap:wrap; gap:8px}
    .split{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    .kpi{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .dot{width:9px; height:9px; border-radius:50%}
    .dot.ok{background:var(--ok)}
    .dot.bad{background:var(--bad)}
    .mono{font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
    .log{
      max-height:260px; overflow:auto; padding:12px 14px;
      border-radius:14px; border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02)); color:var(--muted);
      font-size:12px; line-height:1.35;
      white-space:pre-wrap;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .mini{font-size:12px; color:var(--muted)}
    .inputNumber{width:120px}
    .sectionGrid{display:grid; grid-template-columns: repeat(auto-fit, minmax(260px,1fr)); gap:14px;}
    .sectionCard{border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:12px 14px; background: linear-gradient(180deg, rgba(20,32,56,.88), rgba(16,26,44,.86)); display:flex; flex-direction:column; gap:10px; box-shadow: 0 12px 28px rgba(0,0,0,.26);}
    .sectionTitle{font-size:12px; color:var(--muted); letter-spacing:.3px; text-transform:uppercase; font-weight:800;}
    .inlineStats{display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-size:12px; color:var(--muted);}
    .pillRow{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .warn{color: #fbbf24}
    .ok{color: var(--ok)}
    .bad{color: var(--bad)}
    .hint{color:var(--muted); font-size:12px; margin-top:10px; line-height:1.35}
    .hint code{color:#c7d2fe}

    .topActions{display:flex; gap:10px; align-items:center}
    .btn.ghost{background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.12)}
    .btn.ghost:hover{background: rgba(255,255,255,.10)}
    .helpBtn{display:inline-flex; align-items:center; gap:8px}
    .helpBtn .q{display:inline-flex; width:18px; height:18px; border-radius:999px; align-items:center; justify-content:center;
      border:1px solid rgba(255,255,255,.18); color: var(--txt); font-weight:800; font-size:12px; background: rgba(255,255,255,.06);
    }

    /* Modal */
    .modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; padding:18px; background: rgba(0,0,0,.35); z-index:9999;}
    .modal.open{display:flex}
    .modalCard{
      width:min(860px, 100%);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      box-shadow: 0 18px 44px rgba(0,0,0,.30);
      overflow:hidden;
    }
    .modalHd{padding:14px 14px 10px; border-bottom:1px solid rgba(255,255,255,.12); display:flex; justify-content:space-between; align-items:center; gap:12px}
    .modalHd h2{margin:0; font-size:14px; letter-spacing:.3px}
    .modalBd{padding:14px}
    .modalBd p{margin:0 0 10px; color: var(--muted); font-size:13px; line-height:1.45}
    .modalBd ul{margin:8px 0 14px 18px; color: var(--muted); font-size:13px; line-height:1.45}
    .kbd{font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace; padding:2px 6px; border-radius:8px;
      border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06); color: var(--txt); font-size:12px;
    }

    @media (max-width: 980px){
      .controlBar{grid-template-columns: 1fr;}
    }

    /* Modal: solid (no translucency) */
    .modalCard{background: var(--panel) !important;}

    /* Theme toggle */
    html[data-theme="dark"]{
      --bg:#0a0f1c;
      --panel:#0f1628;
      --panel2:#12213c;
      --txt:#e8edf7;
      --muted:#9bb1c9;
      --line:#1f2e46;
      --accent:#1dd4f2;
      --accent2:#f59e0b;
      --bad:#f87171;
      --ok:#22c55e;
      --shadow: 0 14px 28px rgba(0,0,0,.32);
    }
    html[data-theme="light"]{
      --bg:#f3f6fb;
      --panel:#ffffff;
      --panel2:#f3f7fd;
      --txt:#0d1323;
      --muted:#4a5c76;
      --line:#d5deeb;
      --accent:#0891b2;
      --accent2:#c26d00;
      --bad:#e64967;
      --ok:#17804f;
      --shadow: 0 10px 24px rgba(12,18,40,.12);
      --glow: 0 0 0 1px rgba(12,145,178,.22), 0 16px 28px rgba(12,18,40,.16);
      --frost: blur(14px);
    }
    html[data-theme="light"] body{
      background: radial-gradient(900px 520px at 18% 12%, rgba(12,145,178,.12), transparent 60%),
                  radial-gradient(900px 520px at 82% 18%, rgba(194,109,0,.10), transparent 60%),
                  var(--bg);
      color:var(--txt);
    }
    html[data-theme="light"] textarea,
    html[data-theme="light"] select,
    html[data-theme="light"] input[type="number"]{
      background: rgba(18,24,38,.04);
      color: var(--txt);
      border-color: var(--line);
    }
    html[data-theme="light"] .btn{
      background: rgba(18,24,38,.04);
      color: var(--txt);
      border-color: var(--line);
    }
    html[data-theme="light"] .btn:hover{
      background: rgba(18,24,38,.07);
      border-color: rgba(14,165,233,.35);
    }
    html[data-theme="light"] .pill{
      background: rgba(18,24,38,.04);
      border-color: var(--line);
      color: var(--txt);
    }

  </style>
</head>
<body>
<div class="wrap">
  <header class="hero card">
    <div class="brand">
      <p class="eyebrow">Suite creativa</p>
      <h1>Jazz Comping Generator - Jaime Jaramillo Arias</h1>
      <div class="sub">Escribe una progresión, controla tus referencias de audio y genera playback desde archivos WAV.</div>
    </div>
    <div class="heroMeta">
      <div class="kpi">
        <div class="pill status" title="Estado de carga de referencias de audio">
          <span class="dot bad" id="dotReady"></span>
          <span id="readyText">No listo</span>
        </div>
      </div>
      <div class="topActions">
        <button class="btn ghost helpBtn" id="btnHelp" title="Abrir ayuda">
          <span class="q">?</span><span>Ayuda</span>
        </button>
        <button class="btn ghost" id="btnTheme" title="Cambiar modo claro/oscuro">Modo</button>
      </div>
    </div>
  </header>

  <div class="card megaCard">
    <div class="hd megaHd">
      <div class="title">Panel principal</div>
      <div class="mini">Solo audio de referencia: controla playback, ajustes y exportación.</div>
    </div>
    <div class="megaBd">
      <div class="controlBar">
        <div class="controlCluster">
          <div class="clusterTitle">Reproducción y export</div>
          <div class="clusterActions">
            <button class="btn primary" id="btnPlay" title="Reproducir la progresión usando tus referencias de audio">Reproducir</button>
            <button class="btn bad" id="btnStop" title="Detener reproducción">Stop</button>
            <button class="btn purple" id="btnExportAudio" title="Exportar el audio generado">Exportar audio</button>
          </div>
          <div class="inlineStats">
            <span class="mini">El playback usa los WAVs cargados y los ajustes de referencia.</span>
          </div>
        </div>

        <div class="controlCluster">
          <div class="clusterTitle">Carpeta de audio</div>
          <div class="clusterActions">
            <button class="btn" id="btnPickAudioFolder" title="Cargar carpeta con archivos WAV de referencia">Cargar carpeta</button>
            <input id="audioFolderFallback" type="file" webkitdirectory multiple style="display:none" />
          </div>
          <div class="mini" id="audioFolderStatus" style="margin-top:8px">Sin carpeta cargada.</div>
        </div>

        <div class="controlCluster">
          <div class="clusterTitle">Ajustes de referencia</div>
          <div class="split">
            <div>
              <div class="label">Compases por archivo</div>
              <input id="barsPerFile" type="number" min="1" max="256" value="24" />
            </div>
            <div>
              <div class="label">Compases por acorde</div>
              <input id="barsPerChord" type="number" min="1" max="64" value="2" />
            </div>
            <div>
              <div class="label">Signatura de medida</div>
              <select id="timeSignature">
                <option value="2/4">2/4</option>
                <option value="3/4">3/4</option>
                <option value="4/4" selected>4/4</option>
                <option value="5/4">5/4</option>
                <option value="6/8">6/8</option>
                <option value="7/8">7/8</option>
              </select>
            </div>
            <div>
              <div class="label">BPM fijo referencias</div>
              <input id="refBpm" type="number" min="20" max="300" value="90" />
            </div>
            <div>
              <div class="label">Crossfade (ms)</div>
              <input id="crossfadeMs" type="number" min="0" max="2000" value="20" />
            </div>
            <div>
              <div class="label">Fundamental inicial</div>
              <select id="startRoot">
                <option value="A">A</option>
                <option value="A#">A#</option>
                <option value="B">B</option>
                <option value="C">C</option>
                <option value="C#">C#</option>
                <option value="D">D</option>
                <option value="D#">D#</option>
                <option value="E">E</option>
                <option value="F">F</option>
                <option value="F#">F#</option>
                <option value="G">G</option>
                <option value="G#">G#</option>
              </select>
            </div>
          </div>
        </div>
      </div>

      <div class="sectionGrid">
        <div class="sectionCard">
          <div class="sectionTitle">Progresión y calidades</div>
          <div class="label">Repeticiones</div>
          <div class="row" style="gap:14px; align-items:flex-end">
            <input id="repeatCount" type="number" min="1" max="64" value="1" class="inputNumber" title="Número de veces que se repetirá la progresión" />
            <div class="mini">Cuántas veces se repetirá la progresión al reproducir o exportar el audio.</div>
          </div>

          <div class="label" style="margin-top:10px">Transposición</div>
          <div class="row" style="gap:14px; align-items:flex-end">
            <input id="globalTranspose" type="number" min="-24" max="24" value="0" class="inputNumber" title="Sube o baja las fundamentales del cifrado por semitonos" />
            <div class="mini">Ajusta las fundamentales del cifrado sin alterar las referencias cargadas.</div>
          </div>

          <div class="label" style="margin-top:10px">Progresión</div>
          <textarea id="prog" spellcheck="false" title="Escribe la progresión usando barras: | Cmaj7 | o | Dm7 G7 |" placeholder="Escribe una progresión con barras. Ej: | Cmaj7 | o | Dm7 G7 |" ></textarea>
          <div class="label">Cifrados disponibles (calidades) <span class="mini">(clic para insertar)</span></div>
          <div class="chips" id="qualityChips"></div>
          <div class="pillRow" style="margin-top:8px">
            <div class="pill status" id="qualityMismatch" title="Estado de coincidencia de calidades">
              <span class="dot bad" id="qualityMismatchDot"></span>
              <span id="qualityMismatchText">Carga referencias de audio para validar calidades.</span>
            </div>
          </div>
          <div class="hint">
            <div><b>Calidades:</b> aparecen en la lista después de cargar tus WAVs.</div>
            <div style="margin-top:6px">Usa exactamente las calidades que ves (ej: <code>G7alt</code>, <code>F13(b9)</code>).</div>
          </div>
        </div>

        <div class="sectionCard">
          <div class="sectionTitle">Diagnóstico en vivo</div>
          <div id="logBlock">
            <div class="label">Log</div>
            <div class="log" id="log"></div>
          </div>
          <div class="hint">
            Si “cargar carpeta” no aparece, abre esto desde <code>http://localhost</code>.
            En mac: <code>python3 -m http.server 8000</code> y abre <code>http://localhost:8000</code>.
          </div>
          <div class="hint">El bloque de log se limpia cada vez que cargas una carpeta.</div>
        </div>
      </div>
    </div>
  </div>
</div>


<div class="modal" id="helpModal" aria-hidden="true">
  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modalHd">
      <h2 id="helpTitle">Ayuda</h2>
      <div class="row">
        <button class="btn" id="btnHelpClose" title="Cerrar ayuda">Cerrar</button>
      </div>
    </div>
    <div class="modalBd">
      <p><b>Manual rápido</b></p>
      <ul>
        <li><b>1) Cargar referencias:</b> pulsa <span class="kbd">Cargar carpeta</span> y elige la carpeta con tus WAVs.</li>
        <li><b>2) Ajustes:</b> define compases por archivo, compases por acorde, BPM fijo, crossfades y fundamental inicial.</li>
        <li><b>3) Progresión:</b> escribe con barras. Ej: <span class="kbd">| Dm7 G7 | Cmaj7 |</span>.</li>
        <li><b>4) Calidades:</b> revisa el indicador de coincidencias para ver si falta algún acorde.</li>
        <li><b>5) Escuchar:</b> pulsa <span class="kbd">Reproducir</span>. Usa <span class="kbd">Stop</span> para detener.</li>
        <li><b>6) Exportar:</b> guarda el audio con <span class="kbd">Exportar audio</span>.</li>
      </ul>
      <p class="mini">Atajo: <span class="kbd">Espacio</span> alterna Reproducir / Stop (cuando no estás escribiendo).</p>

    </div>
  </div>
</div>

<script>
(() => {
  const el = (id) => document.getElementById(id);
  const logEl = el("log");
  const readyText = el("readyText");
  const dotReady = el("dotReady");
  const audioFolderStatus = el("audioFolderStatus");
  const qualityChips = el("qualityChips");
  const qualityMismatchText = el("qualityMismatchText");
  const qualityMismatchDot = el("qualityMismatchDot");

  const prog = el("prog");
  const repeatCount = el("repeatCount");
  const globalTranspose = el("globalTranspose");
  const barsPerFileInput = el("barsPerFile");
  const barsPerChordInput = el("barsPerChord");
  const timeSignatureInput = el("timeSignature");
  const refBpmInput = el("refBpm");
  const crossfadeMsInput = el("crossfadeMs");
  const startRootInput = el("startRoot");

  const NOTE_TO_SEMI = new Map([
    ["C",0], ["B#",0],
    ["C#",1], ["DB",1],
    ["D",2],
    ["D#",3], ["EB",3],
    ["E",4], ["FB",4],
    ["F",5], ["E#",5],
    ["F#",6], ["GB",6],
    ["G",7],
    ["G#",8], ["AB",8],
    ["A",9],
    ["A#",10], ["BB",10],
    ["B",11], ["CB",11]
  ]);
  const SEMI_TO_NOTE_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const SEMI_TO_NOTE_FLAT = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];

  let audioCtx = null;
  let audioBuffersByQuality = new Map();
  let audioUrlsByQuality = new Map();
  let audioQualities = [];
  let audioFolderLoaded = false;
  let isAudioPlaying = false;
  let audioNodes = [];
  let audioTimers = [];
  let currentGlobalTranspose = 0;
  const PLAYBACK_SCHEDULE_AHEAD_SEC = 0.08;
  const RELEASE_TAIL_SEC = 0.05;
  const MIN_FADE_SEC = 0.005;

  const log = (msg, level = "INFO") => {
    const prefix = level === "ERROR" ? "❌" : level === "WARN" ? "⚠️" : "✅";
    const stamp = new Date().toLocaleTimeString();
    logEl.textContent += `[${stamp}] ${prefix} ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  };

  const clearLog = () => {
    logEl.textContent = "";
  };

  const setReady = (ready, text) => {
    if (ready) {
      dotReady.classList.remove("bad");
      dotReady.classList.add("ok");
    } else {
      dotReady.classList.remove("ok");
      dotReady.classList.add("bad");
    }
    readyText.textContent = text;
  };

  const normalizeAccidentals = (s) => s.replaceAll("♭","b").replaceAll("♯","#");

  const normalizeQuality = (q) => {
    let s = (q || "").trim();
    s = normalizeAccidentals(s);
    return s || null;
  };

  const parseChordToken = (tokRaw) => {
    const tok = normalizeAccidentals(tokRaw.trim());
    const m = tok.match(/^([A-Ga-g])([#b]?)(.*)$/);
    if (!m) throw new Error(`No entiendo el acorde: "${tokRaw}"`);
    const root = (m[1].toUpperCase() + (m[2]||"")).toUpperCase();
    const qualRaw = (m[3]||"").trim();
    const qualKey = normalizeQuality(qualRaw);
    if (!qualKey) throw new Error(`Calidad faltante en "${tokRaw}". Ej: Dm7, G9, A7alt, Cmaj7.`);
    const rootSemi = NOTE_TO_SEMI.get(root.toUpperCase());
    if (rootSemi === undefined) throw new Error(`Fundamental inválida: "${root}"`);
    return { root, rootSemi, quality: qualKey, token: tokRaw };
  };

  const getTimeSignature = () => {
    const raw = timeSignatureInput.value || "4/4";
    const [numRaw, denRaw] = raw.split("/");
    const num = Math.max(1, parseInt(numRaw, 10) || 4);
    const den = Math.max(1, parseInt(denRaw, 10) || 4);
    return { num, den };
  };

  const getEighthsPerBar = () => {
    const { num, den } = getTimeSignature();
    const eighths = Math.round((num * 8) / den);
    return Math.max(1, eighths);
  };

  const durationsForBar = (chordCount, eighthsPerBar) => {
    if (eighthsPerBar === 8) {
      if (chordCount === 1) return [8];
      if (chordCount === 2) return [4, 4];
      if (chordCount === 3) return [4, 2, 2];
      return [2, 2, 2, 2];
    }
    const base = Math.floor(eighthsPerBar / chordCount);
    let remainder = eighthsPerBar % chordCount;
    return Array.from({ length: chordCount }, () => {
      const extra = remainder > 0 ? 1 : 0;
      remainder = Math.max(0, remainder - 1);
      return base + extra;
    });
  };

  const parseProgression = (text, opts = {}) => {
    const { maxChordsPerBar = 4 } = opts;
    const raw = text.replace(/\r/g, "").trim();
    if (!raw) throw new Error("Escribe una progresión.");
    const parts = raw.split("|").map((s) => s.trim()).filter(Boolean);
    if (!parts.length) throw new Error("Usa barras | |. Ej: | Bbmaj7 Gm9 | ...");

    const segments = [];
    let startEighth = 0;
    let lastBarChords = null;
    const eighthsPerBar = getEighthsPerBar();

    const addBar = (barChords, source = "", barIndex = 0) => {
      if (!barChords || !barChords.length) {
        throw new Error(`Barra inválida: "${source || ""}". Solo 1 a ${maxChordsPerBar} acordes por compás.`);
      }
      if (barChords.length < 1 || barChords.length > maxChordsPerBar) {
        throw new Error(`Barra inválida: "${source || barChords.join(" ")}". Solo 1 a ${maxChordsPerBar} acordes por compás.`);
      }

      const chordCount = barChords.length;
      const durations = durationsForBar(chordCount, eighthsPerBar);
      const stored = [];

      for (const [idx, c] of barChords.entries()) {
        const parsed = parseChordToken(c);
        segments.push({
          ...parsed,
          startEighth,
          durEighth: durations[idx],
          barIndex,
          barChordCount: chordCount,
          barChordIndex: idx,
          windowFromStart: chordCount === 4 || (chordCount === 3 && idx > 0),
        });
        startEighth += durations[idx];
        stored.push(c);
      }

      lastBarChords = stored;
    };

    for (const [barIndex, bar] of parts.entries()) {
      if (bar === "%") {
        if (!lastBarChords) throw new Error("El signo % solo se puede usar después del primer compás.");
        addBar(lastBarChords, bar, barIndex);
        continue;
      }
      const chords = bar.split(/\s+/).map((s) => s.trim()).filter(Boolean);
      addBar(chords, bar, barIndex);
    }

    const totalEighth = parts.length * eighthsPerBar;
    if (segments.length >= 2) {
      for (let i = 1; i < segments.length; i++) {
        const prevStart = segments[i - 1].startEighth;
        const proposed = Math.max(0, segments[i].startEighth - 1);
        const minAllowed = prevStart + 1;
        segments[i].startEighth = Math.max(proposed, minAllowed);
      }
      for (let i = 1; i < segments.length; i++) {
        if (segments[i].startEighth <= segments[i - 1].startEighth) {
          segments[i].startEighth = segments[i - 1].startEighth + 1;
        }
      }
      for (let i = 0; i < segments.length - 1; i++) {
        segments[i].durEighth = segments[i + 1].startEighth - segments[i].startEighth;
      }
      segments[segments.length - 1].durEighth = totalEighth - segments[segments.length - 1].startEighth;
      for (const s of segments) {
        s.durEighth = Math.max(1, s.durEighth);
      }
    }

    return { segments, totalEighth, totalBars: parts.length };
  };

  const repeatSegments = (segments, totalEighth, times) => {
    const t = Math.max(1, parseInt(times, 10) || 1);
    if (t === 1) return { segments, totalEighth };
    const out = [];
    for (let i = 0; i < t; i++) {
      const offset = i * totalEighth;
      for (const s of segments) {
        out.push({ ...s, startEighth: s.startEighth + offset });
      }
    }
    return { segments: out, totalEighth: totalEighth * t };
  };

  const getBarsPerFile = () => Math.max(1, parseInt(barsPerFileInput.value, 10) || 1);
  const getBarsPerChord = () => Math.max(1, parseInt(barsPerChordInput.value, 10) || 1);
  const getRefBpm = () => Math.max(20, parseInt(refBpmInput.value, 10) || 90);
  const getCrossfadeSeconds = () => Math.max(0, parseInt(crossfadeMsInput.value, 10) || 0) / 1000;

  const buildRootBarStartMap = () => {
    const map = new Map();
    const startRoot = (startRootInput.value || "A").toUpperCase();
    const startSemi = NOTE_TO_SEMI.get(startRoot);
    if (startSemi == null) return map;
    const barsPerChord = getBarsPerChord();
    for (let i = 0; i < 12; i++) {
      const rootSemi = (startSemi + i) % 12;
      map.set(rootSemi, i * barsPerChord);
    }
    return map;
  };

  const getBarSeconds = () => {
    const { num, den } = getTimeSignature();
    const bpm = getRefBpm();
    return (60 / bpm) * num * (4 / den);
  };

  const getSecondsPerEighth = () => {
    const bpm = getRefBpm();
    return (60 / bpm) / 2;
  };

  const transposeRootLabel = (root, delta, preferFlat = false) => {
    const baseSemi = NOTE_TO_SEMI.get(root.toUpperCase());
    if (baseSemi == null) return root;
    const target = ((baseSemi + delta) % 12 + 12) % 12;
    const dict = preferFlat ? SEMI_TO_NOTE_FLAT : SEMI_TO_NOTE_SHARP;
    return dict[target] ?? root;
  };

  const transposeChordTokenText = (tok, delta) => {
    if (!delta) return tok;
    const normalized = normalizeAccidentals(tok.trim());
    const m = normalized.match(/^([A-Ga-g])([#b]?)(.*)$/);
    if (!m) return tok;
    const rootKey = (m[1].toUpperCase() + (m[2] || "" )).toUpperCase();
    const preferFlat = m[2] === "b" || m[2] === "♭";
    if (!NOTE_TO_SEMI.has(rootKey)) return tok;
    const rest = m[3] || "";
    const newRoot = transposeRootLabel(rootKey, delta, preferFlat);
    return newRoot + rest;
  };

  const transposeProgressionText = (text, delta) => {
    if (!delta) return text;
    const bars = text.replace(/\r/g, "").split("|");
    const mapped = bars.map((bar) => {
      const trimmed = bar.trim();
      if (!trimmed) return "";
      const tokens = trimmed.split(/\s+/).filter(Boolean).map((tok) => tok === "%" ? tok : transposeChordTokenText(tok, delta));
      return tokens.length ? ` ${tokens.join(" ")} ` : "";
    });
    return mapped.join("|");
  };

  const clampGlobalTranspose = () => {
    let n = parseInt(globalTranspose.value, 10);
    if (!Number.isFinite(n)) n = 0;
    n = Math.max(-24, Math.min(24, n));
    globalTranspose.value = String(n);
    return n;
  };

  const applyGlobalTranspose = () => {
    const desired = clampGlobalTranspose();
    const delta = desired - currentGlobalTranspose;
    if (delta === 0) return;
    prog.value = transposeProgressionText(prog.value, delta);
    currentGlobalTranspose = desired;
    updateQualityMismatch();
  };

  const insertAtCursor = (input, text) => {
    const start = input.selectionStart || 0;
    const end = input.selectionEnd || 0;
    const value = input.value;
    input.value = value.slice(0, start) + text + value.slice(end);
    const pos = start + text.length;
    input.selectionStart = input.selectionEnd = pos;
    input.focus();
  };

  const renderQualityChips = () => {
    qualityChips.innerHTML = "";
    if (!audioQualities.length) {
      const s = document.createElement("span");
      s.className = "mini";
      s.textContent = "Carga una carpeta de audio para ver las calidades disponibles.";
      qualityChips.appendChild(s);
      return;
    }
    for (const q of audioQualities) {
      const chip = document.createElement("button");
      chip.type = "button";
      chip.className = "pill";
      chip.textContent = q;
      chip.title = "Insertar calidad";
      chip.addEventListener("click", () => insertAtCursor(prog, q));
      qualityChips.appendChild(chip);
    }
  };

  const updateQualityMismatch = () => {
    if (!audioFolderLoaded || !audioQualities.length) {
      qualityMismatchText.textContent = "Carga referencias de audio para validar calidades.";
      qualityMismatchDot.classList.remove("ok");
      qualityMismatchDot.classList.add("bad");
      return;
    }

    try {
      const parsed = parseProgression(prog.value, { maxChordsPerBar: 4 });
      const qualities = new Set(parsed.segments.map((s) => s.quality));
      const missing = [...qualities].filter((q) => !audioQualities.includes(q));
      if (missing.length) {
        qualityMismatchText.textContent = `Faltan referencias para: ${missing.join(", ")}`;
        qualityMismatchDot.classList.remove("ok");
        qualityMismatchDot.classList.add("bad");
      } else {
        qualityMismatchText.textContent = "Todas las calidades están cubiertas por las referencias.";
        qualityMismatchDot.classList.remove("bad");
        qualityMismatchDot.classList.add("ok");
      }
    } catch (err) {
      qualityMismatchText.textContent = `Progresión inválida: ${String(err?.message || err)}`;
      qualityMismatchDot.classList.remove("ok");
      qualityMismatchDot.classList.add("bad");
    }
  };

  const ensureAudioContext = () => {
    if (!audioCtx) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) throw new Error("AudioContext no disponible en este navegador.");
      const options = { latencyHint: "playback" };
      try {
        audioCtx = new Ctx(options);
      } catch (_) {
        audioCtx = new Ctx();
      }
    }
    return audioCtx;
  };

  const parseAudioFileName = (fullName) => {
    if (!fullName) return null;
    if (!/\.wav$/i.test(fullName)) return null;
    const base = fullName.replace(/\.[^.]+$/, "");
    const qualityKey = normalizeQuality(base);
    if (!qualityKey) return null;
    return qualityKey;
  };

  const loadFolderViaPicker = async () => {
    if (window.showDirectoryPicker) {
      const dir = await window.showDirectoryPicker();
      const collect = async (handle, acc) => {
        for await (const [, child] of handle.entries()) {
          if (child.kind === "file") {
            acc.push(await child.getFile());
          } else if (child.kind === "directory") {
            await collect(child, acc);
          }
        }
      };
      const files = [];
      await collect(dir, files);
      return { name: dir.name || "carpeta", files };
    }

    return await new Promise((resolve, reject) => {
      const input = el("audioFolderFallback");
      input.onchange = () => {
        const list = [...input.files];
        if (!list.length) reject(new Error("No se encontraron archivos en esa carpeta."));
        else resolve({ name: "carpeta", files: list });
      };
      input.click();
    });
  };

  const updateReadyState = () => {
    setReady(!!audioFolderLoaded, audioFolderLoaded ? "Listo" : "No listo");
  };

  const loadAudioFolder = async () => {
    clearLog();
    audioBuffersByQuality.clear();
    for (const url of audioUrlsByQuality.values()) {
      URL.revokeObjectURL(url);
    }
    audioUrlsByQuality.clear();
    audioQualities = [];
    renderQualityChips();

    audioFolderLoaded = false;
    audioFolderStatus.textContent = "Cargando…";
    updateReadyState();

    try {
      const ctx = ensureAudioContext();
      const { name, files } = await loadFolderViaPicker();
      const folderFiles = files;
      const statusLabel = `Carpeta (audio): ${name} — ${folderFiles.length} archivo(s).`;
      audioFolderStatus.textContent = statusLabel;

      const skipped = [];
      const dups = [];

      for (const f of folderFiles) {
        const fullName = (f.name || "").trim();
        if (!fullName) { skipped.push("(sin nombre)"); continue; }
        const qualityKey = parseAudioFileName(fullName);
        if (!qualityKey) { skipped.push(fullName); continue; }
        if (audioBuffersByQuality.has(qualityKey)) {
          dups.push(qualityKey);
          const oldUrl = audioUrlsByQuality.get(qualityKey);
          if (oldUrl) URL.revokeObjectURL(oldUrl);
        }

        try {
          const buf = await f.arrayBuffer();
          const audioBuf = await ctx.decodeAudioData(buf.slice(0));
          audioBuffersByQuality.set(qualityKey, audioBuf);
          const objectUrl = URL.createObjectURL(f);
          audioUrlsByQuality.set(qualityKey, objectUrl);
        } catch (err) {
          skipped.push(fullName);
        }
      }

      audioQualities = [...new Set(audioBuffersByQuality.keys())].sort((a, b) => a.localeCompare(b, "en"));
      renderQualityChips();
      updateQualityMismatch();

      if (!audioQualities.length) {
        log("No encontré WAVs válidos. Revisa nombres y extensiones.", "ERROR");
        audioFolderStatus.textContent = "Sin carpeta cargada.";
        audioFolderLoaded = false;
        updateReadyState();
        return;
      }

      if (skipped.length) {
        log(`Archivos ignorados (no WAV / nombre inválido): ${skipped.join(", ")}`, "WARN");
      }
      if (dups.length) {
        log(`Duplicados: se usó el último WAV para: ${[...new Set(dups)].join(", ")}`, "WARN");
      }

      const expectedSeconds = getBarsPerFile() * getBarSeconds();
      for (const [quality, buffer] of audioBuffersByQuality.entries()) {
        if (buffer.duration + 0.1 < expectedSeconds) {
          log(`"${quality}": duración corta (${buffer.duration.toFixed(2)}s). Esperaba ~${expectedSeconds.toFixed(2)}s.`, "WARN");
        }
      }

      log(`Cargados ${audioQualities.length} WAV(s) de referencia.`, "OK");
      audioFolderLoaded = true;
      updateReadyState();
    } catch (err) {
      audioFolderLoaded = false;
      audioFolderStatus.textContent = "Error al cargar carpeta.";
      log(String(err?.message || err), "ERROR");
      updateReadyState();
    }
  };

  const stopAudioPlayback = () => {
    isAudioPlaying = false;
    for (const t of audioTimers) {
      clearTimeout(t);
    }
    audioTimers = [];
    for (const node of audioNodes) {
      try {
        node.source?.stop();
      } catch (_) {}
      try {
        node.source?.disconnect();
        node.gain?.disconnect();
      } catch (_) {}
    }
    audioNodes = [];
  };

  const scheduleAudioChord = ({ ctx, buffer, startTime, endTime, bufferOffset, loopStart, loopEnd, trackNodes = true }) => {
    if (!buffer) return;
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    source.loop = true;
    source.loopStart = loopStart;
    source.loopEnd = loopEnd;

    const gain = ctx.createGain();
    gain.gain.value = 0;
    source.connect(gain).connect(ctx.destination);

    const duration = Math.max(0, endTime - startTime);
    const crossfade = Math.min(getCrossfadeSeconds(), duration / 2);
    const attack = Math.min(Math.max(MIN_FADE_SEC, crossfade || 0), duration / 2 || MIN_FADE_SEC);
    const release = Math.min(Math.max(MIN_FADE_SEC, crossfade || 0), duration / 2 || MIN_FADE_SEC);
    gain.gain.setValueAtTime(0, Math.max(0, startTime - attack));
    gain.gain.linearRampToValueAtTime(1, startTime + attack);
    if (duration > attack + release) {
      gain.gain.setValueAtTime(1, Math.max(startTime + attack, endTime - release));
    }
    gain.gain.linearRampToValueAtTime(0, endTime + release);

    const safeOffset = Math.max(0, Math.min(buffer.duration - 0.002, bufferOffset));
    source.start(startTime, safeOffset);
    source.stop(endTime + release + RELEASE_TAIL_SEC);

    if (trackNodes) {
      audioNodes.push({ source, gain });
    }
  };

  const buildAudioSegments = () => {
    const parsed = parseProgression(prog.value, { maxChordsPerBar: 4 });
    const repeated = repeatSegments(parsed.segments, parsed.totalEighth, parseInt(repeatCount.value, 10) || 1);
    return { segments: repeated.segments, totalEighth: repeated.totalEighth };
  };

  const playAudio = () => {
    if (!audioFolderLoaded || !audioBuffersByQuality.size) {
      log("Carga una carpeta de WAVs para reproducir.", "ERROR");
      return;
    }
    let parsed;
    try {
      parsed = buildAudioSegments();
    } catch (err) {
      log(String(err?.message || err), "ERROR");
      updateQualityMismatch();
      return;
    }

    const segments = parsed.segments;
    if (!segments.length) {
      log("No hay acordes para reproducir.", "ERROR");
      return;
    }

    const rootBarMap = buildRootBarStartMap();
    const barsPerChord = getBarsPerChord();
    const eighthsPerBar = getEighthsPerBar();
    const segmentEighths = eighthsPerBar * barsPerChord;

    for (const seg of segments) {
      if (!audioBuffersByQuality.has(seg.quality)) {
        log(`No tengo WAV para la calidad "${seg.quality}".`, "ERROR");
        return;
      }
      if (!rootBarMap.has(seg.rootSemi)) {
        log(`Fundamental inválida para audio: ${seg.root}.`, "ERROR");
        return;
      }
    }

    stopAudioPlayback();
    isAudioPlaying = true;

    const ctx = ensureAudioContext();
    const secPerEighth = getSecondsPerEighth();
    const barSeconds = getBarSeconds();
    const segmentSeconds = barsPerChord * barSeconds;
    const baseTime = ctx.currentTime + PLAYBACK_SCHEDULE_AHEAD_SEC;

    for (const seg of segments) {
      const buffer = audioBuffersByQuality.get(seg.quality);
      const rootBarStart = rootBarMap.get(seg.rootSemi);
      const offsetEighthInSegment = seg.startEighth % segmentEighths;
      const offsetSeconds = offsetEighthInSegment * secPerEighth;
      const loopStart = rootBarStart * barSeconds;
      const loopEnd = loopStart + segmentSeconds;

      const startTime = baseTime + seg.startEighth * secPerEighth;
      const endTime = startTime + seg.durEighth * secPerEighth;
      const startFromBeginning = !!seg.windowFromStart;
      const bufferOffset = startFromBeginning ? loopStart : loopStart + offsetSeconds;

      scheduleAudioChord({
        ctx,
        buffer,
        startTime,
        endTime,
        bufferOffset,
        loopStart,
        loopEnd,
        trackNodes: true,
      });
    }

    const doneTimer = setTimeout(
      () => { isAudioPlaying = false; },
      (parsed.totalEighth * secPerEighth + PLAYBACK_SCHEDULE_AHEAD_SEC + 0.4) * 1000
    );
    audioTimers.push(doneTimer);
    log("Playback iniciado.", "OK");
  };

  const encodeWavFromBuffer = (buffer) => {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const length = buffer.length;
    const bytesPerSample = 4;
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = length * blockAlign;
    const bufferSize = 44 + dataSize;
    const wavBuffer = new ArrayBuffer(bufferSize);
    const view = new DataView(wavBuffer);

    const writeString = (offset, str) => {
      for (let i = 0; i < str.length; i += 1) {
        view.setUint8(offset + i, str.charCodeAt(i));
      }
    };

    writeString(0, "RIFF");
    view.setUint32(4, 36 + dataSize, true);
    writeString(8, "WAVE");
    writeString(12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 3, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bytesPerSample * 8, true);
    writeString(36, "data");
    view.setUint32(40, dataSize, true);

    const channelData = [];
    for (let ch = 0; ch < numChannels; ch += 1) {
      channelData.push(buffer.getChannelData(ch));
    }

    let offset = 44;
    for (let i = 0; i < length; i += 1) {
      for (let ch = 0; ch < numChannels; ch += 1) {
        const sample = Math.max(-1, Math.min(1, channelData[ch][i]));
        view.setFloat32(offset, sample, true);
        offset += bytesPerSample;
      }
    }

    return wavBuffer;
  };

  const exportAudio = async () => {
    if (!audioFolderLoaded || !audioBuffersByQuality.size || !audioUrlsByQuality.size) {
      log("Carga una carpeta de WAVs para exportar audio.", "ERROR");
      return;
    }
    let parsed;
    try {
      parsed = buildAudioSegments();
    } catch (err) {
      log(String(err?.message || err), "ERROR");
      updateQualityMismatch();
      return;
    }

    const segments = parsed.segments;
    if (!segments.length) {
      log("No hay acordes para exportar.", "ERROR");
      return;
    }

    const rootBarMap = buildRootBarStartMap();
    const barsPerChord = getBarsPerChord();
    const eighthsPerBar = getEighthsPerBar();
    const segmentEighths = eighthsPerBar * barsPerChord;

    for (const seg of segments) {
      if (!audioBuffersByQuality.has(seg.quality) || !audioUrlsByQuality.has(seg.quality)) {
        log(`No tengo WAV para la calidad "${seg.quality}".`, "ERROR");
        return;
      }
      if (!rootBarMap.has(seg.rootSemi)) {
        log(`Fundamental inválida para audio: ${seg.root}.`, "ERROR");
        return;
      }
    }

    const buffers = [...audioBuffersByQuality.values()];
    const sampleRate = buffers[0]?.sampleRate || 44100;
    const numChannels = Math.max(1, ...buffers.map((buf) => buf.numberOfChannels || 1));
    const secPerEighth = getSecondsPerEighth();
    const totalDuration = parsed.totalEighth * secPerEighth;
    const renderLength = Math.ceil((totalDuration + 0.4) * sampleRate);
    const offlineCtx = new OfflineAudioContext(numChannels, renderLength, sampleRate);

    log("Renderizando audio en segundo plano…", "OK");

    const barSeconds = getBarSeconds();
    const segmentSeconds = barsPerChord * barSeconds;

    for (const seg of segments) {
      const buffer = audioBuffersByQuality.get(seg.quality);
      const rootBarStart = rootBarMap.get(seg.rootSemi);
      const offsetEighthInSegment = seg.startEighth % segmentEighths;
      const offsetSeconds = offsetEighthInSegment * secPerEighth;
      const loopStart = rootBarStart * barSeconds;
      const loopEnd = loopStart + segmentSeconds;

      const startTime = seg.startEighth * secPerEighth;
      const endTime = startTime + seg.durEighth * secPerEighth;
      const startFromBeginning = !!seg.windowFromStart;
      const bufferOffset = startFromBeginning ? loopStart : loopStart + offsetSeconds;

      scheduleAudioChord({
        ctx: offlineCtx,
        buffer,
        startTime,
        endTime,
        bufferOffset,
        loopStart,
        loopEnd,
        trackNodes: false,
      });
    }

    let rendered;
    try {
      rendered = await offlineCtx.startRendering();
    } catch (err) {
      log(`Error al renderizar WAV: ${String(err?.message || err)}`, "ERROR");
      return;
    }

    const wavBuffer = encodeWavFromBuffer(rendered);
    const blob = new Blob([wavBuffer], { type: "audio/wav" });
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement("a");
    anchor.href = url;
    anchor.download = `referencia_${getRefBpm()}bpm.wav`;
    document.body.appendChild(anchor);
    anchor.click();
    anchor.remove();
    URL.revokeObjectURL(url);
    log(`Exportado audio: ${anchor.download}`, "OK");
  };

  const btnHelp = el("btnHelp");
  const btnHelpClose = el("btnHelpClose");
  const helpModal = el("helpModal");
  const openHelp = () => {
    helpModal.classList.add("open");
    helpModal.setAttribute("aria-hidden", "false");
  };
  const closeHelp = () => {
    helpModal.classList.remove("open");
    helpModal.setAttribute("aria-hidden", "true");
  };
  btnHelp.addEventListener("click", openHelp);
  btnHelpClose.addEventListener("click", closeHelp);
  helpModal.addEventListener("click", (e) => { if (e.target === helpModal) closeHelp(); });
  window.addEventListener("keydown", (e) => { if (e.key === "Escape") closeHelp(); });

  const btnTheme = el("btnTheme");
  const root = document.documentElement;
  const setTheme = (t) => {
    root.setAttribute("data-theme", t);
    try { localStorage.setItem("jcg_theme", t); } catch (_) {}
  };
  const savedTheme = (() => { try { return localStorage.getItem("jcg_theme"); } catch (_) { return null; } })();
  setTheme(savedTheme || "dark");
  btnTheme.addEventListener("click", () => {
    const cur = root.getAttribute("data-theme") || "dark";
    setTheme(cur === "dark" ? "light" : "dark");
  });

  el("btnPickAudioFolder").addEventListener("click", loadAudioFolder);
  el("btnPlay").addEventListener("click", playAudio);
  el("btnStop").addEventListener("click", stopAudioPlayback);
  el("btnExportAudio").addEventListener("click", exportAudio);

  prog.addEventListener("input", updateQualityMismatch);
  repeatCount.addEventListener("input", updateQualityMismatch);
  barsPerFileInput.addEventListener("input", updateQualityMismatch);
  barsPerChordInput.addEventListener("input", updateQualityMismatch);
  timeSignatureInput.addEventListener("change", updateQualityMismatch);
  refBpmInput.addEventListener("input", updateQualityMismatch);
  crossfadeMsInput.addEventListener("input", updateQualityMismatch);
  startRootInput.addEventListener("change", updateQualityMismatch);
  globalTranspose.addEventListener("input", applyGlobalTranspose);

  window.addEventListener("keydown", (e) => {
    if (e.code !== "Space" && e.key !== " ") return;
    const ae = document.activeElement;
    const tag = ae && ae.tagName ? ae.tagName.toLowerCase() : "";
    const typing = tag === "textarea" || tag === "input" || tag === "select" || (ae && ae.isContentEditable);
    if (typing) return;
    e.preventDefault();
    if (isAudioPlaying) stopAudioPlayback();
    else playAudio();
  });

  prog.value = "";
  renderQualityChips();
  updateQualityMismatch();
  updateReadyState();
})();
</script>
</body>
</html>
