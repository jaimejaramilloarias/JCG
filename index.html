<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jazz Comping Generator - Jaime Jaramillo Arias</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' x2='1' y1='1' y2='0'%3E%3Cstop stop-color='%2338bdf8'/%3E%3Cstop offset='.6' stop-color='%23a78bfa'/%3E%3Cstop offset='1' stop-color='%23fbbf24'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='64' height='64' rx='14' fill='%23121826'/%3E%3Cpath d='M18 46c5-4 9-9 14-18 4 8 9 13 14 17' fill='none' stroke='url(%23g)' stroke-width='6' stroke-linecap='round'/%3E%3Ccircle cx='18' cy='46' r='4' fill='%2338bdf8'/%3E%3Ccircle cx='32' cy='28' r='4' fill='%23a78bfa'/%3E%3Ccircle cx='46' cy='45' r='4' fill='%23fbbf24'/%3E%3C/svg%3E" />
  <style>
    :root{
      --bg:#0f141b;
      --panel:#161c26;
      --panel2:#1c2430;
      --txt:#f0f4f8;
      --muted:#a1adbf;
      --line:#2b3646;
      --accent:#2f81f7;
      --bad:#f87171;
      --ok:#4ade80;
      --metal-purple-1:#5b3bce;
      --metal-purple-2:#8b5cf6;
      --metal-purple-3:#3b1a7a;
      --metal-orange-1:#f59e0b;
      --metal-orange-2:#f97316;
      --metal-orange-3:#b45309;
      --metal-green-1:#34d399;
      --metal-green-2:#22c55e;
      --metal-green-3:#15803d;
      --shadow: 0 18px 34px rgba(6,10,16,.55);
      --glow: 0 0 0 1px rgba(74,92,120,.35), 0 18px 36px rgba(0,0,0,.55);
      --frost: blur(16px);
      --r:18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:'Inter', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 720px at 10% 12%, rgba(46,129,247,.12), transparent 60%),
                  radial-gradient(1000px 640px at 84% 8%, rgba(66,83,108,.18), transparent 60%),
                  var(--bg);
      color:var(--txt);
      position:relative;
      min-height:100%;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      background: radial-gradient(680px 460px at 24% 78%, rgba(47,129,247,.08), transparent 62%),
                  radial-gradient(620px 420px at 78% 80%, rgba(64,78,98,.12), transparent 60%);
      pointer-events:none;
      opacity:.6;
    }
    .wrap{
      max-width:760px; margin:10px auto 18px; padding:0 12px 18px;
    }
    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px; flex-wrap:wrap;
    }
    header.hero{padding:12px; border:1px solid rgba(255,255,255,.08); background: linear-gradient(135deg, rgba(30,40,56,.95), rgba(22,30,44,.96)); box-shadow: var(--glow); backdrop-filter: var(--frost); border-radius:18px;}
    .brand{display:flex; flex-direction:column; gap:6px;}
    .eyebrow{margin:0; font-size:11px; letter-spacing:.4px; text-transform:uppercase; color:rgba(255,255,255,.68); font-weight:800;}
    h1{margin:0; font-size:28px; letter-spacing:.1px; font-weight:800; color:#f8fafc; text-shadow:0 14px 40px rgba(0,0,0,.35); font-family:'Space Grotesk', 'Inter', system-ui, -apple-system, sans-serif;}
    .sub{color:var(--muted); font-size:12px; margin-top:2px; line-height:1.5;}
    .card{
      background: linear-gradient(180deg, rgba(22,30,44,.98), rgba(20,28,40,.94));
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
      backdrop-filter: var(--frost);
    }
    .megaCard{padding:4px 4px 10px; border:1px solid rgba(255,255,255,.08); box-shadow: var(--glow);}
    .megaHd{border-bottom:1px solid rgba(44,56,76,.8); background: linear-gradient(135deg, rgba(22,30,44,.98), rgba(18,26,38,.98)); padding:6px 10px; display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .megaHd .title{font-size:13px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted);}
    .megaHd .mini{color:rgba(255,255,255,.82); font-size:12px;}
    .megaBd{display:flex; flex-direction:column; gap:8px; padding:8px;}
    .heroMeta{display:flex; align-items:center; gap:14px; flex-wrap:wrap; justify-content:flex-end;}
    .controlBar{display:grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap:8px; align-items:stretch;}
    .controlCluster{border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:8px 10px; background: linear-gradient(180deg, rgba(19,26,38,.98), rgba(15,22,34,.98)); display:flex; flex-direction:column; gap:6px; box-shadow: 0 12px 24px rgba(0,0,0,.4); position:relative; overflow:hidden;}
    .controlCluster::before{content:""; position:absolute; inset:0; background: linear-gradient(135deg, rgba(47,129,247,.12), rgba(45,57,78,.18) 55%, transparent 90%); opacity:.8; pointer-events:none;}
    .controlCluster > *{position:relative;}
    .clusterTitle{font-size:11px; color:var(--muted); letter-spacing:.4px; text-transform:uppercase; font-weight:800;}
    .clusterActions{display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
    .miniStat{font-size:12px; color:var(--muted); margin-left:auto;}
    .progressWrap{display:none; flex-direction:column; gap:4px; margin-top:6px;}
    .progressWrap.active{display:flex;}
    .progressRow{display:flex; align-items:center; justify-content:space-between; font-size:11px; color:var(--muted);}
    progress{width:100%; height:10px; border-radius:999px; overflow:hidden; appearance:none; background: rgba(255,255,255,.08);}
    progress::-webkit-progress-bar{background: rgba(255,255,255,.08); border-radius:999px;}
    progress::-webkit-progress-value{background: linear-gradient(90deg, rgba(47,129,247,.85), rgba(139,92,246,.9)); border-radius:999px;}
    progress::-moz-progress-bar{background: linear-gradient(90deg, rgba(47,129,247,.85), rgba(139,92,246,.9)); border-radius:999px;}
    .card .hd{
      padding:8px 10px 6px;
      border-bottom:1px solid rgba(35,50,74,.75);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background: linear-gradient(135deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    }
    .card .hd .title{font-size:13px; color:var(--muted); letter-spacing:.4px; text-transform:uppercase; letter-spacing:.32px}
    .card .bd{padding:8px}
    textarea{
      width:100%; min-height:96px; padding:8px 10px;
      border-radius:14px; border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      color:var(--txt); font-size:14px; line-height:1.45;
      outline:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    textarea:focus{border-color: rgba(47,129,247,.6); box-shadow:0 0 0 4px rgba(47,129,247,.15)}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .btn{
      border:1px solid rgba(136,92,255,.65);
      background: linear-gradient(160deg, var(--metal-purple-2), var(--metal-purple-1) 48%, var(--metal-purple-3) 100%);
      color:var(--txt);
      padding:7px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      letter-spacing:.15px;
      font-size:12px;
      transition: transform .06s ease, border-color .15s ease, background .15s ease, box-shadow .15s ease;
      user-select:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.45), inset 0 -1px 0 rgba(0,0,0,.45), 0 12px 22px rgba(8,6,24,.45), 0 0 0 1px rgba(63,46,120,.55);
      text-shadow: 0 1px 0 rgba(22,12,46,.6);
    }
    .btn:hover{border-color: rgba(172,129,255,.9); background: linear-gradient(160deg, #a78bfa, #6d4bd6 52%, #2c105e 100%); box-shadow: inset 0 1px 0 rgba(255,255,255,.5), 0 16px 26px rgba(12,6,28,.45), 0 0 0 1px rgba(118,84,192,.45)}
    .btn:active{transform: translateY(1px)}
    .btn.primary{border-color: rgba(34,197,94,.8); background: linear-gradient(160deg, var(--metal-green-1), var(--metal-green-2) 50%, var(--metal-green-3)); color:#052311}
    .btn.purple{border-color: rgba(139,92,246,.8); background: linear-gradient(160deg, rgba(167,139,250,.85), rgba(139,92,246,.75) 52%, rgba(76,29,149,.85)); color:#f8fafc}
    .btn.bad{border-color: rgba(249,115,22,.85); background: linear-gradient(160deg, var(--metal-orange-1), var(--metal-orange-2) 50%, var(--metal-orange-3)); color:#2a1204}
    .btn:disabled{opacity:.45; cursor:not-allowed}
    select,
    input[type="number"]{
      width:100%;
      padding:7px 9px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color:var(--txt);
      outline:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    select:focus,
    input[type="number"]:focus{border-color: rgba(47,129,247,.6); box-shadow:0 0 0 4px rgba(47,129,247,.15)}
    .label{font-size:11px; color:var(--muted); margin-bottom:6px; display:flex; align-items:center; gap:8px}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      color:#f8fafc;
      font-size:12px;
      cursor:pointer;
      user-select:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .pill:hover{border-color: rgba(47,129,247,.45)}
    .pill.status{padding:8px 12px; font-weight:700; letter-spacing:.2px; box-shadow:0 10px 18px rgba(0,0,0,.28)}
    .pill small{color:var(--muted); font-weight:600}
    .chips{display:flex; flex-wrap:wrap; gap:8px}
    .split{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    .kpi{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .dot{width:9px; height:9px; border-radius:50%}
    .dot.ok{background:var(--ok)}
    .dot.bad{background:var(--bad)}
    .mono{font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
    .log{
      max-height:260px; overflow:auto; padding:12px 14px;
      border-radius:14px; border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03); color:var(--muted);
      font-size:12px; line-height:1.35;
      white-space:pre-wrap;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .mini{font-size:12px; color:var(--muted)}
    .inputNumber{width:120px}
    .sectionGrid{display:grid; grid-template-columns: repeat(auto-fit, minmax(260px,1fr)); gap:8px;}
    .sectionCard{border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:8px 10px; background: linear-gradient(180deg, rgba(20,28,40,.98), rgba(17,24,36,.98)); display:flex; flex-direction:column; gap:6px; box-shadow: 0 12px 28px rgba(0,0,0,.35);}
    .sectionTitle{font-size:11px; color:var(--accent); letter-spacing:.6px; text-transform:uppercase; font-weight:800;}
    .inlineStats{display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-size:12px; color:var(--muted);}
    .pillRow{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .mixerGrid{display:grid; grid-template-columns: repeat(auto-fit, minmax(160px,1fr)); gap:10px;}
    .mixerTrack{border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:10px; background: linear-gradient(180deg, rgba(20,28,40,.98), rgba(17,24,36,.98)); display:flex; flex-direction:column; gap:8px; box-shadow: 0 12px 26px rgba(0,0,0,.35);}
    .mixerTrack .trackName{font-size:12px; font-weight:800; text-transform:uppercase; letter-spacing:.4px;}
    .mixerTrack .trackValue{font-size:11px; color:var(--muted);}
    .mixerTrack .trackButtons{display:flex; gap:6px; flex-wrap:wrap;}
    .mixerTrack .btn.sm{padding:5px 8px; font-size:11px;}
    .mixerEmpty{font-size:12px; color:var(--muted);}
    .warn{color: #fbbf24}
    .ok{color: var(--ok)}
    .bad{color: var(--bad)}
    .hint{color:var(--muted); font-size:12px; margin-top:10px; line-height:1.35}
    .hint code{color:#c7d2fe}

    .topActions{display:flex; gap:8px; align-items:center}
    .btn.ghost{background: rgba(91,59,206,.12); border-color: rgba(167,139,250,.55); color:var(--txt)}
    .btn.ghost:hover{background: rgba(167,139,250,.2)}
    .helpBtn{display:inline-flex; align-items:center; gap:8px}
    .helpBtn .q{display:inline-flex; width:18px; height:18px; border-radius:999px; align-items:center; justify-content:center;
      border:1px solid rgba(255,255,255,.18); color: var(--txt); font-weight:800; font-size:12px; background: rgba(255,255,255,.06);
    }
    .chordPreview{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(47,129,247,.08);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      min-height:56px;
    }
    .savedRow{display:grid; gap:6px; grid-template-columns: minmax(140px, 1.1fr) minmax(140px, 0.8fr); align-items:end;}
    .savedRow .btn{width:100%}
    .savedRow select,
    .savedRow input[type="text"]{width:100%}
    .savedMeta{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
    input[type="text"]{
      width:100%;
      padding:7px 9px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color:var(--txt);
      outline:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    input[type="text"]:focus{border-color: rgba(47,129,247,.6); box-shadow:0 0 0 4px rgba(47,129,247,.15)}
    .badge{
      font-size:11px;
      font-weight:700;
      color:#f8fafc;
      background: linear-gradient(180deg, rgba(47,129,247,.9), rgba(31,111,235,.9));
      padding:4px 8px;
      border-radius:999px;
    }
    .barRow{display:flex; flex-wrap:wrap; align-items:center; gap:6px}
    .barSep{color:var(--muted); font-weight:700; letter-spacing:.4px}
    .chordToken{
      padding:6px 10px;
      border-radius:10px;
      background: linear-gradient(140deg, rgba(139,92,246,.85), rgba(34,197,94,.6) 55%, rgba(249,115,22,.85));
      border:1px solid rgba(139,92,246,.55);
      font-size:12px;
      font-weight:700;
      letter-spacing:.2px;
      color:#f1f5f9;
      text-shadow: 0 1px 0 rgba(20,12,36,.6);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.5), inset 0 -1px 0 rgba(0,0,0,.35), 0 8px 16px rgba(12,6,26,.4);
    }
    .chordToken.bad{
      background: linear-gradient(150deg, rgba(253,186,116,.95), rgba(249,115,22,.95) 50%, rgba(180,83,9,.9));
      border-color: rgba(249,115,22,.85);
      color:#0b0f1c;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.55), inset 0 -1px 0 rgba(0,0,0,.35), 0 0 0 1px rgba(249,115,22,.4), 0 8px 18px rgba(180,83,9,.35);
    }
    .previewEmpty,
    .previewError{
      color:var(--muted);
      font-size:12px;
    }

    /* Modal */
    .modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; padding:18px; background: rgba(9,13,20,.55); z-index:9999;}
    .modal.open{display:flex}
    .modalCard{
      width:min(860px, 100%);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      box-shadow: 0 18px 44px rgba(0,0,0,.30);
      overflow:hidden;
    }
    .modalHd{padding:14px 14px 10px; border-bottom:1px solid rgba(255,255,255,.12); display:flex; justify-content:space-between; align-items:center; gap:12px}
    .modalHd h2{margin:0; font-size:14px; letter-spacing:.3px}
    .modalBd{padding:14px}
    .modalBd p{margin:0 0 10px; color: var(--muted); font-size:13px; line-height:1.45}
    .modalBd ul{margin:8px 0 14px 18px; color: var(--muted); font-size:13px; line-height:1.45}
    .kbd{font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace; padding:2px 6px; border-radius:8px;
      border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06); color: var(--txt); font-size:12px;
    }

    @media (max-width: 980px){
      .controlBar{grid-template-columns: 1fr;}
    }

    /* Modal: solid (no translucency) */
    .modalCard{background: var(--panel) !important;}

    /* Theme toggle */
    html[data-theme="dark"]{
      --bg:#0f141b;
      --panel:#161c26;
      --panel2:#1c2430;
      --txt:#f0f4f8;
      --muted:#a1adbf;
      --line:#2b3646;
      --accent:#2f81f7;
      --bad:#f87171;
      --ok:#4ade80;
      --shadow: 0 18px 34px rgba(6,10,16,.55);
    }
    html[data-theme="light"]{
      --bg:#f2f4f8;
      --panel:#ffffff;
      --panel2:#f4f6fb;
      --txt:#0f1a2b;
      --muted:#52647c;
      --line:#d6dde9;
      --accent:#1f6feb;
      --bad:#e64967;
      --ok:#17804f;
      --shadow: 0 10px 24px rgba(12,18,40,.12);
      --glow: 0 0 0 1px rgba(31,111,235,.22), 0 16px 28px rgba(12,18,40,.16);
      --frost: blur(12px);
    }
    html[data-theme="light"] body{
      background: radial-gradient(900px 520px at 18% 12%, rgba(31,111,235,.08), transparent 60%),
                  radial-gradient(900px 520px at 82% 18%, rgba(82,100,124,.08), transparent 60%),
                  var(--bg);
      color:var(--txt);
    }
    html[data-theme="light"] textarea,
    html[data-theme="light"] select,
    html[data-theme="light"] input[type="number"],
    html[data-theme="light"] input[type="text"]{
      background: rgba(18,24,38,.04);
      color: var(--txt);
      border-color: var(--line);
    }
    html[data-theme="light"] .btn{
      background: linear-gradient(160deg, #c4b5fd, #8b5cf6 55%, #4c1d95);
      color: #1f1140;
      border-color: rgba(139,92,246,.7);
      text-shadow: 0 1px 0 rgba(255,255,255,.55);
    }
    html[data-theme="light"] .btn:hover{
      background: linear-gradient(160deg, #ddd6fe, #7c3aed 55%, #4c1d95);
      border-color: rgba(109,40,217,.55);
    }
    html[data-theme="light"] .btn.ghost{
      background: transparent;
      color: var(--txt);
      border-color: rgba(124,58,237,.45);
      text-shadow: none;
    }
    html[data-theme="light"] .btn.ghost:hover{
      background: rgba(124,58,237,.12);
    }
    html[data-theme="light"] .pill{
      background: rgba(18,24,38,.04);
      border-color: var(--line);
      color: var(--txt);
    }

  </style>
</head>
<body>
<div class="wrap">
  <header class="hero card">
    <div class="brand">
      <h1>Jazz Comping Generator - Jaime Jaramillo Arias</h1>
      <div class="sub">Escribe una progresión, controla tus referencias de audio y genera playback desde archivos WAV.</div>
    </div>
    <div class="heroMeta">
      <div class="kpi">
        <div class="pill status" title="Estado de carga de referencias de audio">
          <span class="dot bad" id="dotReady"></span>
          <span id="readyText">No listo</span>
        </div>
      </div>
      <div class="topActions">
        <button class="btn ghost helpBtn" id="btnHelp" title="Abrir ayuda">
          <span class="q">?</span><span>Ayuda</span>
        </button>
      </div>
    </div>
  </header>

  <div class="card megaCard">
    <div class="hd megaHd">
      <div class="title">Panel principal</div>
    </div>
    <div class="megaBd">
      <div class="sectionGrid">
        <div class="sectionCard">
          <div class="sectionTitle">Progresión y calidades</div>
          <div class="label">Cifrados disponibles (calidades) <span class="mini">(clic para insertar)</span></div>
          <div class="chips" id="qualityChips"></div>
          <div class="label" style="margin-top:8px">Progresión</div>
          <textarea id="prog" spellcheck="false" title="Escribe la progresión usando barras: | Cmaj7 | o | Dm7 G7 |" placeholder="Escribe una progresión con barras. Ej: | Cmaj7 | o | Dm7 G7 |" ></textarea>
          <div class="label" style="margin-top:8px">Guardar progresiones</div>
          <div class="savedRow">
            <div>
              <div class="label">Nombre de progresión</div>
              <input id="progName" type="text" placeholder="Ej: Blues en F, Turnaround" />
            </div>
            <div>
              <button class="btn primary" id="btnSaveProg" title="Guardar la progresión actual">Guardar</button>
            </div>
          </div>
          <div class="savedRow">
            <div>
              <div class="label">Progresiones guardadas</div>
              <select id="savedProgSelect"></select>
            </div>
            <div class="row" style="gap:8px">
              <button class="btn" id="btnLoadProg" title="Cargar la progresión seleccionada">Cargar</button>
              <button class="btn bad" id="btnDeleteProg" title="Eliminar la progresión seleccionada">Eliminar</button>
              <button class="btn ghost" id="btnExportProgs" title="Exportar todas las progresiones guardadas">Exportar</button>
              <button class="btn ghost" id="btnImportProgs" title="Cargar el archivo con progresiones exportadas">Cargar archivo</button>
            </div>
          </div>
          <div class="savedMeta">
            <span class="badge" id="savedCount">0 guardadas</span>
            <input id="importProgFile" type="file" accept=".json,application/json" style="display:none" />
          </div>
          <div class="pillRow" style="margin-top:8px">
            <div class="pill status" id="qualityMismatch" title="Estado de coincidencia de calidades">
              <span class="dot bad" id="qualityMismatchDot"></span>
              <span id="qualityMismatchText">Carga referencias de audio para validar calidades.</span>
            </div>
          </div>
        </div>
      </div>

      <div class="controlBar">
        <div class="controlCluster">
          <div class="clusterTitle">Reproducción y export</div>
          <div class="clusterActions">
            <button class="btn primary" id="btnPlay" title="Reproducir la progresión usando tus referencias de audio">Reproducir</button>
            <button class="btn bad" id="btnStop" title="Detener reproducción">Stop</button>
            <button class="btn purple" id="btnExportAudio" title="Exportar el audio generado">Exportar audio</button>
          </div>
          <div class="label" style="margin-top:8px">Loop de reproducción</div>
          <div class="clusterActions">
            <button class="btn ghost" id="btnLoopProgression" title="Repetir la progresión solo en playback">Loop progresión: OFF</button>
          </div>
        </div>

        <div class="controlCluster">
          <div class="clusterTitle">Carpetas de audio</div>
          <div class="clusterActions">
            <button class="btn" id="btnPickAudioFolder" title="Cargar carpetas con archivos WAV de referencia">Cargar carpetas</button>
            <input id="audioFolderFallback" type="file" webkitdirectory multiple style="display:none" />
          </div>
          <div class="mini" id="audioFolderStatus" style="margin-top:8px">Sin carpetas cargadas.</div>
        </div>

        <div class="controlCluster">
          <div class="clusterTitle">Loop base</div>
          <div class="clusterActions">
            <button class="btn ghost" id="btnLoopToggle" title="Activar o silenciar el loop base">Loop base: ON</button>
          </div>
          <div class="label">Volumen loop</div>
          <div class="row" style="gap:8px; align-items:center;">
            <input id="loopVolume" type="range" min="0" max="1" step="0.01" value="0.6" />
            <span class="mini" id="loopVolumeValue">60%</span>
          </div>
          <div class="mini" id="loopStatus" style="margin-top:6px">Sin loop cargado.</div>
        </div>

        <div class="controlCluster">
          <div class="clusterTitle">Ajustes</div>
          <div class="split">
            <div>
              <div class="label">Compases por archivo</div>
              <input id="barsPerFile" type="number" min="1" max="256" value="24" />
            </div>
            <div>
              <div class="label">Compases por acorde</div>
              <input id="barsPerChord" type="number" min="1" max="64" value="2" />
            </div>
            <div>
              <div class="label">Signatura de medida</div>
              <select id="timeSignature">
                <option value="2/4">2/4</option>
                <option value="3/4">3/4</option>
                <option value="4/4" selected>4/4</option>
                <option value="5/4">5/4</option>
                <option value="6/8">6/8</option>
                <option value="7/8">7/8</option>
              </select>
            </div>
            <div>
              <div class="label">BPM fijo referencias</div>
              <input id="refBpm" type="number" min="20" max="300" value="90" />
            </div>
            <div>
              <div class="label">Crossfade (ms)</div>
              <input id="crossfadeMs" type="number" min="0" max="2000" value="20" />
            </div>
            <div>
              <div class="label">Compases loop base</div>
              <input id="loopBars" type="number" min="1" max="256" value="4" />
            </div>
            <div>
              <div class="label">Ajuste reinicio loop (ms)</div>
              <input id="loopRestartOffset" type="number" min="-1000" max="2000" value="90" />
            </div>
            <div>
              <div class="label">Fundamental inicial</div>
              <select id="startRoot">
                <option value="A">A</option>
                <option value="A#">A#</option>
                <option value="B">B</option>
                <option value="C">C</option>
                <option value="C#">C#</option>
                <option value="D">D</option>
                <option value="D#">D#</option>
                <option value="E">E</option>
                <option value="F">F</option>
                <option value="F#">F#</option>
                <option value="G" selected>G</option>
                <option value="G#">G#</option>
              </select>
            </div>
            <div>
              <div class="label">Repeticiones</div>
              <input id="repeatCount" type="number" min="1" max="64" value="1" class="inputNumber" title="Número de veces que se repetirá la progresión" />
            </div>
            <div>
              <div class="label">Transposición</div>
              <input id="globalTranspose" type="number" min="-24" max="24" value="0" class="inputNumber" title="Sube o baja las fundamentales del cifrado por semitonos" />
            </div>
          </div>
          <div class="label" style="margin-top:10px">Anticipaciones</div>
          <div class="row">
            <label class="pill">
              <input id="clave23" type="checkbox" />
              <span>Clave 2-3</span>
            </label>
            <label class="pill">
              <input id="clave32" type="checkbox" />
              <span>Clave 3-2</span>
            </label>
          </div>
          <div class="hint">Controla la duración de cada acorde según el número de corcheas. En 4/4 se anticipan cambios de acordes según el preset elegido.</div>
        </div>
      </div>

      <div class="card">
        <div class="hd">
          <div class="title">Mezclador</div>
          <div class="mini" id="mixerSummary">0 instrumentos</div>
        </div>
        <div class="bd">
          <div class="mixerEmpty" id="mixerEmpty">Carga carpetas para ver instrumentos en el mezclador.</div>
          <div class="mixerGrid" id="mixerGrid"></div>
        </div>
      </div>
    </div>
  </div>
</div>


<div class="modal" id="helpModal" aria-hidden="true">
  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modalHd">
      <h2 id="helpTitle">Ayuda</h2>
      <div class="row">
        <button class="btn" id="btnHelpClose" title="Cerrar ayuda">Cerrar</button>
      </div>
    </div>
    <div class="modalBd">
      <p><b>Manual rápido</b></p>
      <ul>
        <li><b>1) Cargar referencias:</b> pulsa <span class="kbd">Cargar carpetas</span> y elige dos o más carpetas con los mismos nombres de archivo.</li>
        <li><b>2) Ajustes:</b> define compases por archivo, compases por acorde, BPM fijo, crossfades y fundamental inicial.</li>
        <li><b>3) Progresión:</b> escribe con barras. Ej: <span class="kbd">| Dm7 G7 | Cmaj7 |</span>.</li>
        <li><b>4) Calidades:</b> revisa el indicador de coincidencias para ver si falta algún acorde.</li>
        <li><b>5) Mezclador:</b> ajusta volumen, solo y mute por instrumento.</li>
        <li><b>6) Guardar:</b> usa <span class="kbd">Guardar</span>, <span class="kbd">Exportar</span> para llevarte todas y <span class="kbd">Cargar archivo</span> para reimportarlas.</li>
        <li><b>7) Escuchar:</b> pulsa <span class="kbd">Reproducir</span>. Usa <span class="kbd">Stop</span> para detener.</li>
        <li><b>8) Exportar:</b> guarda el audio con <span class="kbd">Exportar audio</span>.</li>
      </ul>
      <p class="mini">Atajo: <span class="kbd">Espacio</span> alterna Reproducir / Stop (cuando no estás escribiendo).</p>

    </div>
  </div>
</div>

<script type="module">

(() => {
  const el = (id) => document.getElementById(id);
  const logEl = el("log");
  const readyText = el("readyText");
  const dotReady = el("dotReady");
  const audioFolderStatus = el("audioFolderStatus");
  const loopStatus = el("loopStatus");
  const qualityChips = el("qualityChips");
  const qualityMismatchText = el("qualityMismatchText");
  const qualityMismatchDot = el("qualityMismatchDot");
  const progPreview = el("progPreview");
  const mixerGrid = el("mixerGrid");
  const mixerEmpty = el("mixerEmpty");
  const mixerSummary = el("mixerSummary");

  const prog = el("prog");
  const progName = el("progName");
  const savedProgSelect = el("savedProgSelect");
  const btnSaveProg = el("btnSaveProg");
  const btnLoadProg = el("btnLoadProg");
  const btnDeleteProg = el("btnDeleteProg");
  const btnExportProgs = el("btnExportProgs");
  const btnImportProgs = el("btnImportProgs");
  const importProgFile = el("importProgFile");
  const savedCount = el("savedCount");
  const repeatCount = el("repeatCount");
  const globalTranspose = el("globalTranspose");
  const barsPerFileInput = el("barsPerFile");
  const barsPerChordInput = el("barsPerChord");
  const timeSignatureInput = el("timeSignature");
  const refBpmInput = el("refBpm");
  const crossfadeMsInput = el("crossfadeMs");
  const loopBarsInput = el("loopBars");
  const loopRestartOffsetInput = el("loopRestartOffset");
  const startRootInput = el("startRoot");
  const loopVolumeInput = el("loopVolume");
  const loopVolumeValue = el("loopVolumeValue");
  const btnLoopToggle = el("btnLoopToggle");
  const btnLoopProgression = el("btnLoopProgression");
  const clave23Input = el("clave23");
  const clave32Input = el("clave32");

  const NOTE_TO_SEMI = new Map([
    ["C",0], ["B#",0],
    ["C#",1], ["DB",1],
    ["D",2],
    ["D#",3], ["EB",3],
    ["E",4], ["FB",4],
    ["F",5], ["E#",5],
    ["F#",6], ["GB",6],
    ["G",7],
    ["G#",8], ["AB",8],
    ["A",9],
    ["A#",10], ["BB",10],
    ["B",11], ["CB",11]
  ]);
  const SEMI_TO_NOTE_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const SEMI_TO_NOTE_FLAT = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];

  let audioCtx = null;
  let audioTracks = [];
  let audioQualities = [];
  let audioFolderLoaded = false;
  let isAudioPlaying = false;
  let audioNodes = [];
  let audioTimers = [];
  let currentGlobalTranspose = 0;
  let loopEnabled = true;
  let loopProgressionEnabled = false;
  let trackIdCounter = 0;
  let playbackLoopTimer = null;
  const PLAYBACK_SCHEDULE_AHEAD_SEC = 0.08;
  const RELEASE_TAIL_SEC = 0.05;
  const MIN_FADE_SEC = 0.005;
  const LOOP_CROSSFADE_SEC = 0.02;
  const LOOP_FADE_NO_OVERLAP_SEC = 0.01;
  const FADE_CURVE_SAMPLES = 128;
  const STORAGE_KEY = "jcg_saved_progressions";

  const buildEqualPowerCurve = (samples, fadeIn = true) => {
    const curve = new Float32Array(samples);
    for (let i = 0; i < samples; i += 1) {
      const t = i / (samples - 1);
      curve[i] = fadeIn ? Math.sin(t * Math.PI * 0.5) : Math.cos(t * Math.PI * 0.5);
    }
    return curve;
  };
  const FADE_IN_CURVE = buildEqualPowerCurve(FADE_CURVE_SAMPLES, true);
  const FADE_OUT_CURVE = buildEqualPowerCurve(FADE_CURVE_SAMPLES, false);

  const log = (msg, level = "INFO") => {
    const prefix = level === "ERROR" ? "❌" : level === "WARN" ? "⚠️" : "✅";
    const stamp = new Date().toLocaleTimeString();
    if (!logEl) {
      const method = level === "ERROR" ? "error" : level === "WARN" ? "warn" : "log";
      console[method](`[${stamp}] ${prefix} ${msg}`);
      return;
    }
    logEl.textContent += `[${stamp}] ${prefix} ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  };

  const readSavedProgressions = () => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return [];
      return parsed.filter((item) => item && typeof item.name === "string" && typeof item.text === "string");
    } catch (_) {
      return [];
    }
  };

  const writeSavedProgressions = (list) => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(list));
    } catch (err) {
      log(`No pude guardar progresiones: ${String(err?.message || err)}`, "ERROR");
    }
  };

  const renderSavedProgressions = (list, selectedName = "") => {
    if (!savedProgSelect) return;
    savedProgSelect.innerHTML = "";
    if (!list.length) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "Sin progresiones guardadas";
      savedProgSelect.appendChild(opt);
      savedProgSelect.disabled = true;
      if (btnLoadProg) btnLoadProg.disabled = true;
      if (btnDeleteProg) btnDeleteProg.disabled = true;
      if (btnExportProgs) btnExportProgs.disabled = true;
    } else {
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "Selecciona una progresión";
      savedProgSelect.appendChild(placeholder);
      for (const item of list) {
        const opt = document.createElement("option");
        opt.value = item.name;
        opt.textContent = item.name;
        savedProgSelect.appendChild(opt);
      }
      savedProgSelect.disabled = false;
      if (btnLoadProg) btnLoadProg.disabled = false;
      if (btnExportProgs) btnExportProgs.disabled = false;
      if (selectedName) savedProgSelect.value = selectedName;
      if (btnDeleteProg) btnDeleteProg.disabled = !savedProgSelect.value;
    }
    if (savedCount) {
      savedCount.textContent = `${list.length} guardada${list.length === 1 ? "" : "s"}`;
    }
  };

  const getSavedProgressions = () => readSavedProgressions().sort((a, b) => a.name.localeCompare(b.name, "es"));

  const saveCurrentProgression = () => {
    const name = (progName?.value || "").trim();
    const text = (prog?.value || "").trim();
    if (!name) {
      log("Escribe un nombre para guardar la progresión.", "WARN");
      return;
    }
    if (!text) {
      log("Escribe una progresión antes de guardar.", "WARN");
      return;
    }
    const list = getSavedProgressions();
    const existingIndex = list.findIndex((item) => item.name.toLowerCase() === name.toLowerCase());
    const payload = { name, text, updatedAt: new Date().toISOString() };
    if (existingIndex >= 0) {
      list[existingIndex] = payload;
    } else {
      list.push(payload);
    }
    writeSavedProgressions(list);
    renderSavedProgressions(list, name);
    log(`Progresión "${name}" guardada.`, "OK");
  };

  const loadSelectedProgression = () => {
    const name = savedProgSelect?.value || "";
    if (!name) {
      log("Selecciona una progresión guardada.", "WARN");
      return;
    }
    const list = getSavedProgressions();
    const item = list.find((p) => p.name === name);
    if (!item) {
      log("No encontré esa progresión.", "WARN");
      return;
    }
    prog.value = item.text;
    if (progName) progName.value = item.name;
    updateQualityMismatch();
    log(`Progresión "${item.name}" cargada.`, "OK");
  };

  const deleteSelectedProgression = () => {
    const name = savedProgSelect?.value || "";
    if (!name) {
      log("Selecciona una progresión guardada para eliminar.", "WARN");
      return;
    }
    const confirmed = window.confirm(`¿Eliminar la progresión "${name}"? Esta acción no se puede deshacer.`);
    if (!confirmed) return;
    const list = getSavedProgressions().filter((item) => item.name !== name);
    writeSavedProgressions(list);
    renderSavedProgressions(list);
    log(`Progresión "${name}" eliminada.`, "OK");
  };

  const exportProgressions = () => {
    const list = getSavedProgressions();
    if (!list.length) {
      log("No hay progresiones guardadas para exportar.", "WARN");
      return;
    }
    const blob = new Blob([JSON.stringify(list, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement("a");
    anchor.href = url;
    anchor.download = "progresiones_guardadas.json";
    document.body.appendChild(anchor);
    anchor.click();
    anchor.remove();
    URL.revokeObjectURL(url);
    log("Exportadas progresiones guardadas.", "OK");
  };

  const importProgressions = async (file) => {
    if (!file) return;
    try {
      const text = await file.text();
      const incoming = JSON.parse(text);
      if (!Array.isArray(incoming)) throw new Error("El archivo no tiene formato válido.");
      const sanitized = incoming
        .filter((item) => item && typeof item.name === "string" && typeof item.text === "string")
        .map((item) => ({ name: item.name.trim(), text: item.text.trim() }))
        .filter((item) => item.name && item.text);
      if (!sanitized.length) {
        log("No encontré progresiones válidas en el archivo.", "WARN");
        return;
      }
      const list = getSavedProgressions();
      const map = new Map(list.map((item) => [item.name.toLowerCase(), item]));
      for (const item of sanitized) {
        map.set(item.name.toLowerCase(), { ...item, updatedAt: new Date().toISOString() });
      }
      const merged = [...map.values()].sort((a, b) => a.name.localeCompare(b.name, "es"));
      writeSavedProgressions(merged);
      renderSavedProgressions(merged);
      log(`Importadas ${sanitized.length} progresiones.`, "OK");
    } catch (err) {
      log(`No pude importar: ${String(err?.message || err)}`, "ERROR");
    }
  };

  const clearLog = () => {
    if (logEl) logEl.textContent = "";
  };

  const setReady = (ready, text) => {
    if (ready) {
      dotReady.classList.remove("bad");
      dotReady.classList.add("ok");
    } else {
      dotReady.classList.remove("ok");
      dotReady.classList.add("bad");
    }
    readyText.textContent = text;
  };

  const normalizeAccidentals = (s) => s.replaceAll("♭","b").replaceAll("♯","#");

  const normalizeQuality = (q) => {
    let s = (q || "").trim();
    s = normalizeAccidentals(s);
    return s || null;
  };

  const isLoopFileName = (fullName) => {
    const base = fullName.replace(/\.[^.]+$/, "");
    return /loop_/i.test(base);
  };

  const scaleCurve = (curve, scale) => {
    if (scale === 1) return curve;
    const out = new Float32Array(curve.length);
    for (let i = 0; i < curve.length; i += 1) {
      out[i] = curve[i] * scale;
    }
    return out;
  };

  const parseChordToken = (tokRaw) => {
    const tok = normalizeAccidentals(tokRaw.trim());
    const m = tok.match(/^([A-Ga-g])([#b]?)(.*)$/);
    if (!m) throw new Error(`No entiendo el acorde: "${tokRaw}"`);
    const root = (m[1].toUpperCase() + (m[2]||"")).toUpperCase();
    const qualRaw = (m[3]||"").trim();
    const qualKey = normalizeQuality(qualRaw);
    if (!qualKey) throw new Error(`Calidad faltante en "${tokRaw}". Ej: Dm7, G9, A7alt, Cmaj7.`);
    const rootSemi = NOTE_TO_SEMI.get(root.toUpperCase());
    if (rootSemi === undefined) throw new Error(`Fundamental inválida: "${root}"`);
    return { root, rootSemi, quality: qualKey, token: tokRaw };
  };

  const getTimeSignature = () => {
    const raw = timeSignatureInput.value || "4/4";
    const [numRaw, denRaw] = raw.split("/");
    const num = Math.max(1, parseInt(numRaw, 10) || 4);
    const den = Math.max(1, parseInt(denRaw, 10) || 4);
    return { num, den };
  };

  const getEighthsPerBar = () => {
    const { num, den } = getTimeSignature();
    const eighths = Math.round((num * 8) / den);
    return Math.max(1, eighths);
  };

  const durationsForBar = (chordCount, eighthsPerBar) => {
    if (eighthsPerBar === 8) {
      if (chordCount === 1) return [8];
      if (chordCount === 2) return [4, 4];
      if (chordCount === 3) return [4, 2, 2];
      return [2, 2, 2, 2];
    }
    const base = Math.floor(eighthsPerBar / chordCount);
    let remainder = eighthsPerBar % chordCount;
    return Array.from({ length: chordCount }, () => {
      const extra = remainder > 0 ? 1 : 0;
      remainder = Math.max(0, remainder - 1);
      return base + extra;
    });
  };

  const parseProgression = (text, opts = {}) => {
    const { maxChordsPerBar = 4 } = opts;
    const raw = text.replace(/\r/g, "").trim();
    if (!raw) throw new Error("Escribe una progresión.");
    const parts = raw.split("|").map((s) => s.trim()).filter(Boolean);
    if (!parts.length) throw new Error("Usa barras | |. Ej: | Bbmaj7 Gm9 | ...");

    const segments = [];
    let startEighth = 0;
    let lastBarChords = null;
    const eighthsPerBar = getEighthsPerBar();

    const addBar = (barChords, source = "", barIndex = 0) => {
      if (!barChords || !barChords.length) {
        throw new Error(`Barra inválida: "${source || ""}". Solo 1 a ${maxChordsPerBar} acordes por compás.`);
      }
      if (barChords.length < 1 || barChords.length > maxChordsPerBar) {
        throw new Error(`Barra inválida: "${source || barChords.join(" ")}". Solo 1 a ${maxChordsPerBar} acordes por compás.`);
      }

      const chordCount = barChords.length;
      const durations = durationsForBar(chordCount, eighthsPerBar);
      const stored = [];

      for (const [idx, c] of barChords.entries()) {
        const parsed = parseChordToken(c);
        segments.push({
          ...parsed,
          startEighth,
          durEighth: durations[idx],
          barIndex,
          barChordCount: chordCount,
          barChordIndex: idx,
          windowFromStart: chordCount === 4 || (chordCount === 3 && idx > 0),
        });
        startEighth += durations[idx];
        stored.push(c);
      }

      lastBarChords = stored;
    };

    for (const [barIndex, bar] of parts.entries()) {
      if (bar === "%") {
        if (!lastBarChords) throw new Error("El signo % solo se puede usar después del primer compás.");
        addBar(lastBarChords, bar, barIndex);
        continue;
      }
      const chords = bar.split(/\s+/).map((s) => s.trim()).filter(Boolean);
      addBar(chords, bar, barIndex);
    }

    applyClaveAnticipations(segments, eighthsPerBar, getClaveMode());

    const totalEighth = parts.length * eighthsPerBar;
    if (segments.length >= 2) {
      for (let i = 0; i < segments.length - 1; i++) {
        segments[i].durEighth = segments[i + 1].startEighth - segments[i].startEighth;
      }
      segments[segments.length - 1].durEighth = totalEighth - segments[segments.length - 1].startEighth;
      for (const s of segments) {
        s.durEighth = Math.max(1, s.durEighth);
      }
    }

    return { segments, totalEighth, totalBars: parts.length };
  };

  const repeatSegments = (segments, totalEighth, times) => {
    const t = Math.max(1, parseInt(times, 10) || 1);
    if (t === 1) return { segments, totalEighth };
    const out = [];
    for (let i = 0; i < t; i++) {
      const offset = i * totalEighth;
      for (const s of segments) {
        out.push({ ...s, startEighth: s.startEighth + offset });
      }
    }
    return { segments: out, totalEighth: totalEighth * t };
  };

  const getBarsPerFile = () => Math.max(1, parseInt(barsPerFileInput.value, 10) || 1);
  const getBarsPerChord = () => Math.max(1, parseInt(barsPerChordInput.value, 10) || 1);
  const getRefBpm = () => Math.max(20, parseInt(refBpmInput.value, 10) || 90);
  const getCrossfadeSeconds = () => Math.max(0, parseInt(crossfadeMsInput.value, 10) || 0) / 1000;
  const getLoopBars = () => Math.max(1, parseInt(loopBarsInput?.value, 10) || 1);
  const getLoopRestartOffsetMs = () => parseInt(loopRestartOffsetInput?.value, 10) || 0;
  const getClaveMode = () => {
    if (clave23Input?.checked) return "2-3";
    if (clave32Input?.checked) return "3-2";
    return "none";
  };

  const findBpmInFolderName = (name) => {
    if (!name) return null;
    const match = name.match(/(\d+(?:[.,]\d+)?)\s*bpm\b/i);
    if (!match) return null;
    const parsed = parseFloat(match[1].replace(",", "."));
    if (!Number.isFinite(parsed)) return null;
    return parsed;
  };

  const applyFolderBpm = (name) => {
    if (!refBpmInput) return;
    const parsed = findBpmInFolderName(name);
    if (!Number.isFinite(parsed)) return;
    const clamped = Math.min(300, Math.max(20, parsed));
    refBpmInput.value = String(clamped);
    log(`BPM fijo detectado en carpeta: ${clamped}.`, "OK");
  };

  const findClaveInFolderName = (name) => {
    if (!name) return "none";
    if (name.includes("2-3")) return "2-3";
    if (name.includes("3-2")) return "3-2";
    return "none";
  };

  const applyFolderClave = (name) => {
    const claveMode = findClaveInFolderName(name);
    if (clave23Input) clave23Input.checked = claveMode === "2-3";
    if (clave32Input) clave32Input.checked = claveMode === "3-2";
  };

  const sameChord = (a, b) => a && b && a.rootSemi === b.rootSemi && a.quality === b.quality;

  const applyClaveAnticipations = (segments, eighthsPerBar, claveMode) => {
    if (!segments.length || eighthsPerBar !== 8) return segments;
    if (claveMode !== "2-3" && claveMode !== "3-2") return segments;

    const byBar = new Map();
    for (const seg of segments) {
      if (!byBar.has(seg.barIndex)) byBar.set(seg.barIndex, []);
      byBar.get(seg.barIndex).push(seg);
    }

    const sortedBars = [...byBar.keys()].sort((a, b) => a - b);
    for (let i = 0; i < sortedBars.length - 1; i += 2) {
      const barA = byBar.get(sortedBars[i]) || [];
      const barB = byBar.get(sortedBars[i + 1]) || [];
      if (barA.length === 1 && barB.length === 1) {
        if (!sameChord(barA[0], barB[0])) {
          const shift = claveMode === "2-3" ? 1 : 2;
          barB[0].startEighth = Math.max(0, barB[0].startEighth - shift);
        }
      } else if (barA.length === 2 && barB.length === 2) {
        barA[1].startEighth = Math.max(0, barA[1].startEighth - 1);
        if (claveMode === "2-3") {
          barB[0].startEighth = Math.max(0, barB[0].startEighth - 1);
          barB[1].startEighth = Math.max(0, barB[1].startEighth - 2);
        } else {
          barB[0].startEighth = Math.max(0, barB[0].startEighth - 2);
          barB[1].startEighth = Math.max(0, barB[1].startEighth - 1);
        }
      }
    }

    return segments;
  };

  const buildRootBarStartMap = () => {
    const map = new Map();
    const startRoot = (startRootInput.value || "G").toUpperCase();
    const startSemi = NOTE_TO_SEMI.get(startRoot);
    if (startSemi == null) return map;
    const barsPerChord = getBarsPerChord();
    for (let i = 0; i < 12; i++) {
      const rootSemi = (startSemi + i) % 12;
      map.set(rootSemi, i * barsPerChord);
    }
    return map;
  };

  const getRefBarSeconds = () => {
    const { num, den } = getTimeSignature();
    const bpm = getRefBpm();
    return (60 / bpm) * num * (4 / den);
  };

  const getRefSecondsPerEighth = () => {
    const bpm = getRefBpm();
    return (60 / bpm) / 2;
  };
  const transposeRootLabel = (root, delta, preferFlat = false) => {
    const baseSemi = NOTE_TO_SEMI.get(root.toUpperCase());
    if (baseSemi == null) return root;
    const target = ((baseSemi + delta) % 12 + 12) % 12;
    const dict = preferFlat ? SEMI_TO_NOTE_FLAT : SEMI_TO_NOTE_SHARP;
    return dict[target] ?? root;
  };

  const transposeChordTokenText = (tok, delta) => {
    if (!delta) return tok;
    const normalized = normalizeAccidentals(tok.trim());
    const m = normalized.match(/^([A-Ga-g])([#b]?)(.*)$/);
    if (!m) return tok;
    const rootKey = (m[1].toUpperCase() + (m[2] || "" )).toUpperCase();
    const preferFlat = m[2] === "b" || m[2] === "♭";
    if (!NOTE_TO_SEMI.has(rootKey)) return tok;
    const rest = m[3] || "";
    const newRoot = transposeRootLabel(rootKey, delta, preferFlat);
    return newRoot + rest;
  };

  const transposeProgressionText = (text, delta) => {
    if (!delta) return text;
    const bars = text.replace(/\r/g, "").split("|");
    const mapped = bars.map((bar) => {
      const trimmed = bar.trim();
      if (!trimmed) return "";
      const tokens = trimmed.split(/\s+/).filter(Boolean).map((tok) => tok === "%" ? tok : transposeChordTokenText(tok, delta));
      return tokens.length ? ` ${tokens.join(" ")} ` : "";
    });
    return mapped.join("|");
  };

  const clampGlobalTranspose = () => {
    let n = parseInt(globalTranspose.value, 10);
    if (!Number.isFinite(n)) n = 0;
    n = Math.max(-24, Math.min(24, n));
    globalTranspose.value = String(n);
    return n;
  };

  const applyGlobalTranspose = () => {
    const desired = clampGlobalTranspose();
    const delta = desired - currentGlobalTranspose;
    if (delta === 0) return;
    prog.value = transposeProgressionText(prog.value, delta);
    currentGlobalTranspose = desired;
    updateQualityMismatch();
  };

  const insertAtCursor = (input, text) => {
    const start = input.selectionStart || 0;
    const end = input.selectionEnd || 0;
    const value = input.value;
    input.value = value.slice(0, start) + text + value.slice(end);
    const pos = start + text.length;
    input.selectionStart = input.selectionEnd = pos;
    input.focus();
  };

  const renderQualityChips = () => {
    qualityChips.innerHTML = "";
    if (!audioQualities.length) {
      const s = document.createElement("span");
      s.className = "mini";
      s.textContent = "Carga carpetas de audio para ver las calidades disponibles.";
      qualityChips.appendChild(s);
      return;
    }
    for (const q of audioQualities) {
      const chip = document.createElement("button");
      chip.type = "button";
      chip.className = "pill";
      chip.textContent = q;
      chip.title = "Insertar calidad";
      chip.addEventListener("click", () => insertAtCursor(prog, q));
      qualityChips.appendChild(chip);
    }
  };

  const renderProgressionPreview = (parsed, parseError, missingSet) => {
    if (!progPreview) return;
    progPreview.innerHTML = "";
    const raw = prog.value.trim();
    if (!raw) {
      const empty = document.createElement("span");
      empty.className = "previewEmpty";
      empty.textContent = "Escribe una progresión para verla aquí.";
      progPreview.appendChild(empty);
      return;
    }
    if (parseError) {
      const errText = document.createElement("span");
      errText.className = "previewError";
      errText.textContent = `Progresión inválida: ${String(parseError?.message || parseError)}`;
      progPreview.appendChild(errText);
      return;
    }
    if (!parsed) return;

    const bars = Array.from({ length: parsed.totalBars }, () => []);
    for (const seg of parsed.segments) {
      if (bars[seg.barIndex]) bars[seg.barIndex].push(seg);
    }
    bars.forEach((barSegs) => {
      const barRow = document.createElement("div");
      barRow.className = "barRow";
      const barStart = document.createElement("span");
      barStart.className = "barSep";
      barStart.textContent = "|";
      barRow.appendChild(barStart);

      for (const seg of barSegs) {
        const token = document.createElement("span");
        token.className = "chordToken";
        token.textContent = seg.token || `${seg.root}${seg.quality}`;
        if (missingSet && missingSet.has(seg.quality)) {
          token.classList.add("bad");
        }
        barRow.appendChild(token);
      }

      const barEnd = document.createElement("span");
      barEnd.className = "barSep";
      barEnd.textContent = "|";
      barRow.appendChild(barEnd);
      progPreview.appendChild(barRow);
    });
  };

  const updateQualityMismatch = () => {
    let parsed = null;
    let parseError = null;
    try {
      parsed = parseProgression(prog.value, { maxChordsPerBar: 4 });
    } catch (err) {
      parseError = err;
    }
    if (!audioFolderLoaded || !audioQualities.length) {
      qualityMismatchText.textContent = "Carga referencias de audio para validar calidades.";
      qualityMismatchDot.classList.remove("ok");
      qualityMismatchDot.classList.add("bad");
      renderProgressionPreview(parsed, parseError, null);
      return;
    }

    if (parseError) {
      qualityMismatchText.textContent = `Progresión inválida: ${String(parseError?.message || parseError)}`;
      qualityMismatchDot.classList.remove("ok");
      qualityMismatchDot.classList.add("bad");
      renderProgressionPreview(parsed, parseError, null);
      return;
    }

    try {
      const qualities = new Set(parsed.segments.map((s) => s.quality));
      const missing = [...qualities].filter((q) => !audioQualities.includes(q));
      const missingSet = new Set(missing);
      if (missing.length) {
        qualityMismatchText.textContent = `Faltan referencias para: ${missing.join(", ")}`;
        qualityMismatchDot.classList.remove("ok");
        qualityMismatchDot.classList.add("bad");
      } else {
        qualityMismatchText.textContent = "Todas las calidades están cubiertas por las referencias.";
        qualityMismatchDot.classList.remove("bad");
        qualityMismatchDot.classList.add("ok");
      }
      renderProgressionPreview(parsed, null, missingSet);
    } catch (err) {
      qualityMismatchText.textContent = `Progresión inválida: ${String(err?.message || err)}`;
      qualityMismatchDot.classList.remove("ok");
      qualityMismatchDot.classList.add("bad");
      renderProgressionPreview(parsed, err, null);
    }
  };

  const ensureAudioContext = () => {
    if (!audioCtx) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) throw new Error("AudioContext no disponible en este navegador.");
      const options = { latencyHint: "playback" };
      try {
        audioCtx = new Ctx(options);
      } catch (_) {
        audioCtx = new Ctx();
      }
    }
    return audioCtx;
  };

  const parseAudioFileName = (fullName) => {
    if (!fullName) return null;
    if (!/\.wav$/i.test(fullName)) return null;
    if (isLoopFileName(fullName)) return null;
    const base = fullName.replace(/\.[^.]+$/, "");
    const qualityKey = normalizeQuality(base);
    if (!qualityKey) return null;
    return qualityKey;
  };

  const getLoopVolume = () => {
    const value = parseFloat(loopVolumeInput?.value ?? "0");
    if (!Number.isFinite(value)) return 0;
    return Math.max(0, Math.min(1, value));
  };

  const updateLoopControls = () => {
    const totalLoops = audioTracks.reduce((sum, track) => sum + track.loopBuffers.length, 0);
    if (loopVolumeValue) {
      loopVolumeValue.textContent = `${Math.round(getLoopVolume() * 100)}%`;
    }
    if (btnLoopToggle) {
      btnLoopToggle.textContent = loopEnabled ? "Loop base: ON" : "Loop base: OFF";
      btnLoopToggle.classList.toggle("bad", !loopEnabled);
      btnLoopToggle.classList.toggle("ghost", loopEnabled);
      btnLoopToggle.disabled = totalLoops === 0;
    }
    if (loopStatus) {
      if (!totalLoops) {
        loopStatus.textContent = "Sin loop cargado.";
      } else {
        const trackCount = audioTracks.filter((track) => track.loopBuffers.length).length;
        loopStatus.textContent = `${totalLoops} loop(s) cargado(s) en ${trackCount} instrumento(s).`;
      }
    }
  };

  const updatePlaybackLoopControls = () => {
    if (!btnLoopProgression) return;
    btnLoopProgression.textContent = loopProgressionEnabled ? "Loop progresión: ON" : "Loop progresión: OFF";
    btnLoopProgression.classList.toggle("purple", loopProgressionEnabled);
    btnLoopProgression.classList.toggle("ghost", !loopProgressionEnabled);
  };

  const getAnySolo = () => audioTracks.some((track) => track.solo);

  const getTrackEffectiveVolume = (track) => {
    if (track.mute) return 0;
    if (getAnySolo() && !track.solo) return 0;
    return Math.max(0, Math.min(1, track.volume));
  };

  const updateMixerSummary = () => {
    if (!mixerSummary) return;
    const count = audioTracks.length;
    const soloActive = getAnySolo();
    mixerSummary.textContent = `${count} instrumento${count === 1 ? "" : "s"}${soloActive ? " · Solo activo" : ""}`;
  };

  const renderMixer = () => {
    if (!mixerGrid || !mixerEmpty) return;
    mixerGrid.innerHTML = "";
    const hasTracks = audioTracks.length > 0;
    mixerEmpty.style.display = hasTracks ? "none" : "block";
    if (!hasTracks) {
      updateMixerSummary();
      return;
    }

    for (const track of audioTracks) {
      const card = document.createElement("div");
      card.className = "mixerTrack";

      const title = document.createElement("div");
      title.className = "trackName";
      title.textContent = track.name;

      const sliderRow = document.createElement("div");
      sliderRow.className = "row";
      sliderRow.style.gap = "8px";
      sliderRow.style.alignItems = "center";

      const slider = document.createElement("input");
      slider.type = "range";
      slider.min = "0";
      slider.max = "1";
      slider.step = "0.01";
      slider.value = String(track.volume);

      const value = document.createElement("span");
      value.className = "trackValue";
      value.textContent = `${Math.round(track.volume * 100)}%`;

      slider.addEventListener("input", () => {
        const next = parseFloat(slider.value);
        track.volume = Number.isFinite(next) ? next : 0;
        value.textContent = `${Math.round(track.volume * 100)}%`;
      });

      sliderRow.appendChild(slider);
      sliderRow.appendChild(value);

      const buttons = document.createElement("div");
      buttons.className = "trackButtons";

      const soloBtn = document.createElement("button");
      soloBtn.type = "button";
      soloBtn.className = "btn sm ghost";
      soloBtn.textContent = "Solo";

      const muteBtn = document.createElement("button");
      muteBtn.type = "button";
      muteBtn.className = "btn sm ghost";
      muteBtn.textContent = "Mute";

      const syncButtons = () => {
        soloBtn.classList.toggle("purple", track.solo);
        soloBtn.classList.toggle("ghost", !track.solo);
        soloBtn.textContent = track.solo ? "Solo: ON" : "Solo";
        muteBtn.classList.toggle("bad", track.mute);
        muteBtn.classList.toggle("ghost", !track.mute);
        muteBtn.textContent = track.mute ? "Mute: ON" : "Mute";
        updateMixerSummary();
      };

      soloBtn.addEventListener("click", () => {
        track.solo = !track.solo;
        syncButtons();
      });

      muteBtn.addEventListener("click", () => {
        track.mute = !track.mute;
        syncButtons();
      });

      syncButtons();

      buttons.appendChild(soloBtn);
      buttons.appendChild(muteBtn);

      card.appendChild(title);
      card.appendChild(sliderRow);
      card.appendChild(buttons);

      mixerGrid.appendChild(card);
    }

    updateMixerSummary();
  };

  const collectFoldersFromFileList = (list) => {
    const byFolder = new Map();
    for (const file of list) {
      const rel = file.webkitRelativePath || file.name || "";
      const top = rel.split("/")[0] || "carpeta";
      if (!byFolder.has(top)) byFolder.set(top, []);
      byFolder.get(top).push(file);
    }
    return [...byFolder.entries()].map(([name, files]) => ({ name, files }));
  };

  const loadFoldersViaPicker = async () => {
    if (window.showDirectoryPicker) {
      const folders = [];
      let keepPicking = true;
      while (keepPicking) {
        let dir;
        try {
          dir = await window.showDirectoryPicker();
        } catch (err) {
          if (err?.name === "AbortError") break;
          throw err;
        }
        const collect = async (handle, acc) => {
          for await (const [, child] of handle.entries()) {
            if (child.kind === "file") {
              acc.push(await child.getFile());
            } else if (child.kind === "directory") {
              await collect(child, acc);
            }
          }
        };
        const files = [];
        await collect(dir, files);
        folders.push({ name: dir.name || "carpeta", files });
        keepPicking = window.confirm("¿Deseas agregar otra carpeta de instrumento?");
      }
      return folders;
    }

    return await new Promise((resolve, reject) => {
      const input = el("audioFolderFallback");
      input.onchange = () => {
        const list = [...input.files];
        if (!list.length) reject(new Error("No se encontraron archivos en esa carpeta."));
        else resolve(collectFoldersFromFileList(list));
      };
      input.click();
    });
  };

  const updateReadyState = () => {
    setReady(!!audioFolderLoaded, audioFolderLoaded ? "Listo" : "No listo");
  };

  const resetAudioTracks = () => {
    for (const track of audioTracks) {
      for (const url of track.urlsByQuality.values()) {
        URL.revokeObjectURL(url);
      }
    }
    audioTracks = [];
    audioQualities = [];
    renderQualityChips();
    renderMixer();
  };

  const loadAudioFolders = async () => {
    clearLog();
    resetAudioTracks();

    audioFolderLoaded = false;
    audioFolderStatus.textContent = "Cargando…";
    if (loopStatus) loopStatus.textContent = "Cargando…";
    updateReadyState();

    try {
      const ctx = ensureAudioContext();
      const folders = await loadFoldersViaPicker();
      if (!folders.length) {
        throw new Error("No se encontraron carpetas con audio.");
      }
      if (folders.length < 2) {
        throw new Error("Selecciona al menos dos carpetas de instrumentos.");
      }

      const bpmValues = folders.map((folder) => findBpmInFolderName(folder.name)).filter((v) => Number.isFinite(v));
      if (bpmValues.length) {
        if (bpmValues.length !== folders.length) {
          throw new Error("Todas las carpetas deben incluir el BPM en el nombre.");
        }
        const refBpm = bpmValues[0];
        if (bpmValues.some((v) => Math.abs(v - refBpm) > 0.01)) {
          throw new Error("Las carpetas tienen BPM distintos. Usa el mismo BPM en todas.");
        }
      }

      const claveValues = folders.map((folder) => findClaveInFolderName(folder.name));
      const claveWithValue = claveValues.filter((c) => c !== "none");
      if (claveWithValue.length) {
        const target = claveWithValue[0];
        if (claveValues.some((c) => c !== target)) {
          throw new Error("Las carpetas tienen clave distinta. Usa la misma clave en todas.");
        }
      }

      if (bpmValues.length) {
        applyFolderBpm(folders[0].name);
      }
      if (claveWithValue.length) {
        applyFolderClave(folders[0].name);
      }

      for (const folder of folders) {
        const track = {
          id: trackIdCounter += 1,
          name: (folder.name || "").trim() || `Instrumento ${trackIdCounter}`,
          buffersByQuality: new Map(),
          urlsByQuality: new Map(),
          loopBuffers: [],
          volume: 1,
          mute: false,
          solo: false,
          qualities: [],
        };

        const skipped = [];
        const dups = [];
        const loopSkipped = [];

        for (const f of folder.files) {
          const fullName = (f.name || "").trim();
          if (!fullName) { skipped.push("(sin nombre)"); continue; }
          if (isLoopFileName(fullName)) {
            if (!/\.wav$/i.test(fullName)) { skipped.push(fullName); continue; }
            try {
              const buf = await f.arrayBuffer();
              const audioBuf = await ctx.decodeAudioData(buf.slice(0));
              track.loopBuffers.push({ name: fullName, buffer: audioBuf });
            } catch (err) {
              loopSkipped.push(fullName);
            }
            continue;
          }
          const qualityKey = parseAudioFileName(fullName);
          if (!qualityKey) { skipped.push(fullName); continue; }
          if (track.buffersByQuality.has(qualityKey)) {
            dups.push(qualityKey);
            const oldUrl = track.urlsByQuality.get(qualityKey);
            if (oldUrl) URL.revokeObjectURL(oldUrl);
          }

          try {
            const buf = await f.arrayBuffer();
            const audioBuf = await ctx.decodeAudioData(buf.slice(0));
            track.buffersByQuality.set(qualityKey, audioBuf);
            const objectUrl = URL.createObjectURL(f);
            track.urlsByQuality.set(qualityKey, objectUrl);
          } catch (err) {
            skipped.push(fullName);
          }
        }

        track.qualities = [...new Set(track.buffersByQuality.keys())].sort((a, b) => a.localeCompare(b, "en"));
        if (!track.qualities.length) {
          throw new Error(`No encontré WAVs válidos en la carpeta "${track.name}".`);
        }

        if (!audioQualities.length) {
          audioQualities = [...track.qualities];
        } else {
          const missing = audioQualities.filter((q) => !track.qualities.includes(q));
          const extra = track.qualities.filter((q) => !audioQualities.includes(q));
          if (missing.length || extra.length) {
            const details = [
              missing.length ? `Faltan: ${missing.join(", ")}` : "",
              extra.length ? `Sobran: ${extra.join(", ")}` : "",
            ].filter(Boolean).join(" — ");
            throw new Error(`Las calidades de "${track.name}" no coinciden con las demás. ${details}`);
          }
        }

        if (skipped.length) {
          log(`(${track.name}) Archivos ignorados (no WAV / nombre inválido): ${skipped.join(", ")}`, "WARN");
        }
        if (dups.length) {
          log(`(${track.name}) Duplicados: se usó el último WAV para: ${[...new Set(dups)].join(", ")}`, "WARN");
        }
        if (loopSkipped.length) {
          log(`(${track.name}) Loops ignorados (error al leer): ${loopSkipped.join(", ")}`, "WARN");
        }
        if (track.loopBuffers.length) {
          log(`(${track.name}) Loops cargados: ${track.loopBuffers.length}.`, "OK");
        }

        const expectedSeconds = getBarsPerFile() * getRefBarSeconds();
        for (const [quality, buffer] of track.buffersByQuality.entries()) {
          if (buffer.duration + 0.1 < expectedSeconds) {
            log(`(${track.name}) "${quality}": duración corta (${buffer.duration.toFixed(2)}s). Esperaba ~${expectedSeconds.toFixed(2)}s.`, "WARN");
          }
        }

        log(`(${track.name}) Cargados ${track.qualities.length} WAV(s) de referencia.`, "OK");
        audioTracks.push(track);
      }

      renderQualityChips();
      renderMixer();
      updateQualityMismatch();
      updateLoopControls();

      const instrumentNames = audioTracks.map((track) => track.name).join(", ");
      audioFolderStatus.textContent = `Instrumentos cargados: ${instrumentNames}.`;
      audioFolderLoaded = true;
      updateReadyState();
    } catch (err) {
      resetAudioTracks();
      audioFolderLoaded = false;
      audioFolderStatus.textContent = "Error al cargar carpetas.";
      log(String(err?.message || err), "ERROR");
      updateLoopControls();
      updateReadyState();
    }
  };

  const stopAudioPlayback = () => {
    isAudioPlaying = false;
    if (playbackLoopTimer) {
      clearTimeout(playbackLoopTimer);
      playbackLoopTimer = null;
    }
    for (const t of audioTimers) {
      clearTimeout(t);
    }
    audioTimers = [];
    for (const node of audioNodes) {
      try {
        node.source?.stop();
      } catch (_) {}
      try {
        node.source?.disconnect();
        node.gain?.disconnect();
      } catch (_) {}
    }
    audioNodes = [];
  };

  const scheduleAudioChord = ({
    ctx,
    buffer,
    startTime,
    endTime,
    bufferOffset,
    trackNodes = true,
    gainValue = 1,
    fadeInSec = null,
    fadeOutSec = null,
  }) => {
    if (!buffer) return;
    const source = ctx.createBufferSource();
    source.buffer = buffer;

    const gain = ctx.createGain();
    gain.gain.value = 0;
    source.connect(gain).connect(ctx.destination);

    const duration = Math.max(0, endTime - startTime);
    const safeOffset = Math.max(0, Math.min(buffer.duration - 0.002, bufferOffset));
    const maxPlayable = Math.max(0, buffer.duration - safeOffset);
    const playDuration = Math.min(duration, maxPlayable);
    if (playDuration <= 0) return;

    const baseFade = Math.max(MIN_FADE_SEC, getCrossfadeSeconds());
    const attackRequest = fadeInSec == null ? baseFade : Math.max(0, fadeInSec);
    const releaseRequest = fadeOutSec == null ? baseFade : Math.max(0, fadeOutSec);
    const maxFade = Math.max(MIN_FADE_SEC, playDuration / 2);
    const attack = Math.min(attackRequest, maxFade);
    const release = Math.min(releaseRequest, maxFade);
    const effectiveEnd = startTime + playDuration;
    const sustainStart = startTime + attack;
    const releaseStart = Math.max(sustainStart, effectiveEnd - release);

    gain.gain.setValueAtTime(0, startTime);
    if (attack > 0) {
      gain.gain.setValueCurveAtTime(scaleCurve(FADE_IN_CURVE, gainValue), startTime, attack);
    } else {
      gain.gain.setValueAtTime(gainValue, startTime);
    }
    if (effectiveEnd > sustainStart) {
      gain.gain.setValueAtTime(gainValue, releaseStart);
    }
    if (release > 0) {
      gain.gain.setValueCurveAtTime(scaleCurve(FADE_OUT_CURVE, gainValue), releaseStart, release);
    } else {
      gain.gain.setValueAtTime(0, effectiveEnd);
    }

    source.start(startTime, safeOffset, playDuration);
    source.stop(effectiveEnd + release + RELEASE_TAIL_SEC);

    if (trackNodes) {
      audioNodes.push({ source, gain });
    }
  };

  const buildAudioSegments = () => {
    const parsed = parseProgression(prog.value, { maxChordsPerBar: 4 });
    const repeated = repeatSegments(parsed.segments, parsed.totalEighth, parseInt(repeatCount.value, 10) || 1);
    return { segments: repeated.segments, totalEighth: repeated.totalEighth };
  };

  const scheduleLoopLayer = ({ ctx, baseTime, totalEighth, secPerEighth, barSeconds, trackNodes, loopBufferSet, loopGain }) => {
    if (!loopEnabled || !loopBufferSet.length) return;
    const loopVolume = getLoopVolume();
    if (loopVolume <= 0) return;
    const effectiveLoopGain = loopVolume * Math.max(0, Math.min(1, loopGain ?? 1));
    if (effectiveLoopGain <= 0) return;
    const totalBars = Math.ceil(totalEighth / getEighthsPerBar());
    const loopBars = getLoopBars();
    const overlapSec = LOOP_CROSSFADE_SEC;
    for (const loop of loopBufferSet) {
      const duration = Math.max(loop.buffer.duration, 0.001);
      for (let bar = 0; bar < totalBars; bar += 1) {
        const startTime = baseTime + bar * barSeconds;
        const loopBarIndex = loopBars > 0 ? bar % loopBars : bar;
        const bufferOffset = (loopBarIndex * barSeconds) % duration;
        const safeOffset = Math.max(0, Math.min(loop.buffer.duration - 0.002, bufferOffset));
        const maxPlayable = Math.max(0, loop.buffer.duration - safeOffset);
        const useOverlap = maxPlayable >= barSeconds + overlapSec;
        const endTime = startTime + (useOverlap ? barSeconds + overlapSec : barSeconds);
        const fadeInSec = useOverlap ? overlapSec : LOOP_FADE_NO_OVERLAP_SEC;
        const fadeOutSec = useOverlap ? overlapSec : LOOP_FADE_NO_OVERLAP_SEC;
        scheduleAudioChord({
          ctx,
          buffer: loop.buffer,
          startTime,
          endTime,
          bufferOffset,
          trackNodes,
          gainValue: effectiveLoopGain,
          fadeInSec,
          fadeOutSec,
        });
      }
    }
  };

  const playAudio = async () => {
    if (!audioFolderLoaded || !audioTracks.length) {
      log("Carga carpetas de WAVs para reproducir.", "ERROR");
      return;
    }
    let parsed;
    try {
      parsed = buildAudioSegments();
    } catch (err) {
      log(String(err?.message || err), "ERROR");
      updateQualityMismatch();
      return;
    }

    const segments = parsed.segments;
    if (!segments.length) {
      log("No hay acordes para reproducir.", "ERROR");
      return;
    }

    const rootBarMap = buildRootBarStartMap();
    const barsPerChord = getBarsPerChord();
    const eighthsPerBar = getEighthsPerBar();
    const segmentEighths = eighthsPerBar * barsPerChord;
    const tracks = audioTracks;

    for (const seg of segments) {
      if (!rootBarMap.has(seg.rootSemi)) {
        log(`Fundamental inválida para audio: ${seg.root}.`, "ERROR");
        return;
      }
    }
    for (const track of tracks) {
      for (const seg of segments) {
        if (!track.buffersByQuality.has(seg.quality)) {
          log(`(${track.name}) No tengo WAV para la calidad "${seg.quality}".`, "ERROR");
          return;
        }
      }
    }

    stopAudioPlayback();
    isAudioPlaying = true;

    const ctx = ensureAudioContext();
    const secPerEighth = getRefSecondsPerEighth();
    const barSeconds = getRefBarSeconds();
    const baseTime = ctx.currentTime + PLAYBACK_SCHEDULE_AHEAD_SEC;
    const anyAudible = tracks.some((track) => getTrackEffectiveVolume(track) > 0);
    if (!anyAudible) {
      log("Todos los instrumentos están en mute/solo silencioso.", "WARN");
      isAudioPlaying = false;
      return;
    }

    for (const track of tracks) {
      const trackGain = getTrackEffectiveVolume(track);
      if (trackGain <= 0) continue;

      scheduleLoopLayer({
        ctx,
        baseTime,
        totalEighth: parsed.totalEighth,
        secPerEighth,
        barSeconds,
        trackNodes: true,
        loopBufferSet: track.loopBuffers,
        loopGain: trackGain,
      });

      for (const seg of segments) {
        const buffer = track.buffersByQuality.get(seg.quality);
        const rootBarStart = rootBarMap.get(seg.rootSemi);
        const offsetEighthInSegment = seg.startEighth % segmentEighths;
        const offsetSeconds = offsetEighthInSegment * secPerEighth;
        const loopStart = rootBarStart * barSeconds;

        const startTime = baseTime + seg.startEighth * secPerEighth;
        const endTime = startTime + seg.durEighth * secPerEighth;
        const startFromBeginning = !!seg.windowFromStart;
        const bufferOffset = startFromBeginning ? loopStart : loopStart + offsetSeconds;

        scheduleAudioChord({
          ctx,
          buffer,
          startTime,
          endTime,
          bufferOffset,
          trackNodes: true,
          gainValue: trackGain,
        });
      }
    }

    const playbackDurationSec = parsed.totalEighth * secPerEighth;
    const doneTimer = setTimeout(() => {
      isAudioPlaying = false;
    }, playbackDurationSec * 1000);
    audioTimers.push(doneTimer);
    const loopDelayMs = Math.max(0, (playbackDurationSec - PLAYBACK_SCHEDULE_AHEAD_SEC) * 1000 + getLoopRestartOffsetMs());
    playbackLoopTimer = setTimeout(() => {
      if (!loopProgressionEnabled) return;
      playAudio();
    }, loopDelayMs);
    log("Playback iniciado.", "OK");
  };

  const encodeWavFromBuffer = (buffer) => {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const length = buffer.length;
    const bytesPerSample = 4;
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = length * blockAlign;
    const bufferSize = 44 + dataSize;
    const wavBuffer = new ArrayBuffer(bufferSize);
    const view = new DataView(wavBuffer);

    const writeString = (offset, str) => {
      for (let i = 0; i < str.length; i += 1) {
        view.setUint8(offset + i, str.charCodeAt(i));
      }
    };

    writeString(0, "RIFF");
    view.setUint32(4, 36 + dataSize, true);
    writeString(8, "WAVE");
    writeString(12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 3, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bytesPerSample * 8, true);
    writeString(36, "data");
    view.setUint32(40, dataSize, true);

    const channelData = [];
    for (let ch = 0; ch < numChannels; ch += 1) {
      channelData.push(buffer.getChannelData(ch));
    }

    let offset = 44;
    for (let i = 0; i < length; i += 1) {
      for (let ch = 0; ch < numChannels; ch += 1) {
        const sample = Math.max(-1, Math.min(1, channelData[ch][i]));
        view.setFloat32(offset, sample, true);
        offset += bytesPerSample;
      }
    }

    return wavBuffer;
  };

  const exportAudio = async () => {
    if (!audioFolderLoaded || !audioTracks.length) {
      log("Carga carpetas de WAVs para exportar audio.", "ERROR");
      return;
    }
    let parsed;
    try {
      parsed = buildAudioSegments();
    } catch (err) {
      log(String(err?.message || err), "ERROR");
      updateQualityMismatch();
      return;
    }

    const segments = parsed.segments;
    if (!segments.length) {
      log("No hay acordes para exportar.", "ERROR");
      return;
    }

    const rootBarMap = buildRootBarStartMap();
    const barsPerChord = getBarsPerChord();
    const eighthsPerBar = getEighthsPerBar();
    const segmentEighths = eighthsPerBar * barsPerChord;
    const tracks = audioTracks;

    for (const seg of segments) {
      if (!rootBarMap.has(seg.rootSemi)) {
        log(`Fundamental inválida para audio: ${seg.root}.`, "ERROR");
        return;
      }
    }

    for (const track of tracks) {
      for (const seg of segments) {
        if (!track.buffersByQuality.has(seg.quality)) {
          log(`(${track.name}) No tengo WAV para la calidad "${seg.quality}".`, "ERROR");
          return;
        }
      }
    }

    const allBuffers = tracks.flatMap((track) => [...track.buffersByQuality.values()]);
    const sampleRate = allBuffers[0]?.sampleRate || 44100;
    const numChannels = Math.max(1, ...allBuffers.map((buf) => buf.numberOfChannels || 1));
    const secPerEighth = getRefSecondsPerEighth();
    const totalDuration = parsed.totalEighth * secPerEighth;
    const renderLength = Math.ceil((totalDuration + 0.4) * sampleRate);
    const offlineCtx = new OfflineAudioContext(numChannels, renderLength, sampleRate);

    log("Renderizando audio en segundo plano…", "OK");

    const barSeconds = getRefBarSeconds();

    const anyAudible = tracks.some((track) => getTrackEffectiveVolume(track) > 0);
    if (!anyAudible) {
      log("Todos los instrumentos están en mute/solo silencioso.", "WARN");
      return;
    }

    for (const track of tracks) {
      const trackGain = getTrackEffectiveVolume(track);
      if (trackGain <= 0) continue;

      scheduleLoopLayer({
        ctx: offlineCtx,
        baseTime: 0,
        totalEighth: parsed.totalEighth,
        secPerEighth,
        barSeconds,
        trackNodes: false,
        loopBufferSet: track.loopBuffers,
        loopGain: trackGain,
      });

      for (const seg of segments) {
        const buffer = track.buffersByQuality.get(seg.quality);
        const rootBarStart = rootBarMap.get(seg.rootSemi);
        const offsetEighthInSegment = seg.startEighth % segmentEighths;
        const offsetSeconds = offsetEighthInSegment * secPerEighth;
        const loopStart = rootBarStart * barSeconds;

        const startTime = seg.startEighth * secPerEighth;
        const endTime = startTime + seg.durEighth * secPerEighth;
        const startFromBeginning = !!seg.windowFromStart;
        const bufferOffset = startFromBeginning ? loopStart : loopStart + offsetSeconds;

        scheduleAudioChord({
          ctx: offlineCtx,
          buffer,
          startTime,
          endTime,
          bufferOffset,
          trackNodes: false,
          gainValue: trackGain,
        });
      }
    }

    let rendered;
    try {
      rendered = await offlineCtx.startRendering();
    } catch (err) {
      log(`Error al renderizar WAV: ${String(err?.message || err)}`, "ERROR");
      return;
    }

    const wavBuffer = encodeWavFromBuffer(rendered);
    const blob = new Blob([wavBuffer], { type: "audio/wav" });
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement("a");
    anchor.href = url;
    anchor.download = `referencia_${getRefBpm()}bpm.wav`;
    document.body.appendChild(anchor);
    anchor.click();
    anchor.remove();
    URL.revokeObjectURL(url);
    log(`Exportado audio: ${anchor.download}`, "OK");
  };

  const btnHelp = el("btnHelp");
  const btnHelpClose = el("btnHelpClose");
  const helpModal = el("helpModal");
  const openHelp = () => {
    helpModal.classList.add("open");
    helpModal.setAttribute("aria-hidden", "false");
  };
  const closeHelp = () => {
    helpModal.classList.remove("open");
    helpModal.setAttribute("aria-hidden", "true");
  };
  btnHelp.addEventListener("click", openHelp);
  btnHelpClose.addEventListener("click", closeHelp);
  helpModal.addEventListener("click", (e) => { if (e.target === helpModal) closeHelp(); });
  window.addEventListener("keydown", (e) => { if (e.key === "Escape") closeHelp(); });

  el("btnPickAudioFolder").addEventListener("click", loadAudioFolders);
  el("btnPlay").addEventListener("click", playAudio);
  el("btnStop").addEventListener("click", stopAudioPlayback);
  el("btnExportAudio").addEventListener("click", exportAudio);
  loopVolumeInput.addEventListener("input", updateLoopControls);
  btnLoopToggle.addEventListener("click", () => {
    loopEnabled = !loopEnabled;
    updateLoopControls();
  });
  btnLoopProgression.addEventListener("click", () => {
    loopProgressionEnabled = !loopProgressionEnabled;
    updatePlaybackLoopControls();
  });
  btnSaveProg.addEventListener("click", saveCurrentProgression);
  btnLoadProg.addEventListener("click", loadSelectedProgression);
  btnDeleteProg.addEventListener("click", deleteSelectedProgression);
  btnExportProgs.addEventListener("click", exportProgressions);
  btnImportProgs.addEventListener("click", () => importProgFile.click());
  importProgFile.addEventListener("change", (e) => {
    const file = e.target.files?.[0];
    if (file) {
      importProgressions(file);
    }
    e.target.value = "";
  });
  savedProgSelect.addEventListener("change", () => {
    if (btnDeleteProg) btnDeleteProg.disabled = !savedProgSelect.value;
  });

  prog.addEventListener("input", updateQualityMismatch);
  repeatCount.addEventListener("input", updateQualityMismatch);
  barsPerFileInput.addEventListener("input", updateQualityMismatch);
  barsPerChordInput.addEventListener("input", updateQualityMismatch);
  timeSignatureInput.addEventListener("change", updateQualityMismatch);
  refBpmInput.addEventListener("input", () => {
    updateQualityMismatch();
  });
  crossfadeMsInput.addEventListener("input", updateQualityMismatch);
  loopBarsInput.addEventListener("input", updateQualityMismatch);
  loopRestartOffsetInput.addEventListener("input", updateQualityMismatch);
  startRootInput.addEventListener("change", updateQualityMismatch);
  globalTranspose.addEventListener("input", applyGlobalTranspose);
  if (clave23Input && clave32Input) {
    clave23Input.addEventListener("change", () => {
      if (clave23Input.checked) clave32Input.checked = false;
    });
    clave32Input.addEventListener("change", () => {
      if (clave32Input.checked) clave23Input.checked = false;
    });
  }

  window.addEventListener("keydown", (e) => {
    if (e.code !== "Space" && e.key !== " ") return;
    const ae = document.activeElement;
    const tag = ae && ae.tagName ? ae.tagName.toLowerCase() : "";
    const typing = tag === "textarea" || tag === "input" || tag === "select" || (ae && ae.isContentEditable);
    if (typing) return;
    e.preventDefault();
    if (isAudioPlaying) stopAudioPlayback();
    else playAudio();
  });

  prog.value = "";
  renderQualityChips();
  renderMixer();
  renderSavedProgressions(getSavedProgressions());
  updateQualityMismatch();
  updateReadyState();
  updateLoopControls();
  updatePlaybackLoopControls();
})();
</script>
</body>
</html>
