<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jazz Comping Generator - Jaime Jaramillo Arias</title>
  <style>
    :root{
      --bg:#121826;
      --panel:#182238;
      --panel2:#1d2a45;
      --txt:#eef2ff;
      --muted:#aab6cc;
      --line:#2b3b57;
      --accent:#38bdf8;
      --accent2:#a78bfa;
      --bad:#fb7185;
      --ok:#34d399;
      --shadow: 0 10px 24px rgba(0,0,0,.28);
      --r:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(900px 520px at 18% 12%, rgba(56,189,248,.10), transparent 60%), radial-gradient(900px 520px at 82% 18%, rgba(167,139,250,.10), transparent 60%), var(--bg);
color:var(--txt);
    }
    .wrap{
      max-width:1100px; margin:24px auto; padding:0 18px 40px;
    }
    header{display:flex; align-items:flex-end; justify-content:space-between; gap:14px; margin-bottom:18px}
    h1{margin:0; font-size:32px; letter-spacing:.2px; font-weight:800}
    .sub{color:var(--muted); font-size:12px; margin-top:6px}
    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:16px;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.035));
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(35,50,74,.8);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background: rgba(24,34,56,.75);
    }
    .card .hd .title{font-size:13px; color:var(--muted); letter-spacing:.4px; text-transform:uppercase}
    .card .bd{padding:14px}
    textarea{
      width:100%; min-height:150px; padding:12px 12px;
      border-radius:14px; border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--txt); font-size:14px; line-height:1.35;
      outline:none;
    }
    textarea:focus{border-color: rgba(125,211,252,.6); box-shadow:0 0 0 3px rgba(125,211,252,.12)}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .btn{
      border:1px solid rgba(35,50,74,.9);
      background: rgba(255,255,255,.07);
      color:var(--txt);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:650;
      font-size:13px;
      transition: transform .06s ease, border-color .15s ease, background .15s ease;
      user-select:none;
    }
    .btn:hover{border-color: rgba(125,211,252,.55); background: rgba(14,22,38,.85)}
    .btn:active{transform: translateY(1px)}
    .btn.primary{border-color: rgba(125,211,252,.65); background: rgba(125,211,252,.10)}
    .btn.purple{border-color: rgba(167,139,250,.6); background: rgba(167,139,250,.10)}
    .btn.bad{border-color: rgba(251,113,133,.65); background: rgba(251,113,133,.08)}
    .btn:disabled{opacity:.45; cursor:not-allowed}
    select,
    input[type="number"]{
      width:100%;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--txt);
      outline:none;
    }
    select:focus,
    input[type="number"]:focus{border-color: rgba(125,211,252,.6); box-shadow:0 0 0 3px rgba(125,211,252,.12)}
    .label{font-size:12px; color:var(--muted); margin-bottom:6px; display:flex; align-items:center; gap:8px}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(14,22,38,.55);
      color:var(--txt);
      font-size:12px;
      cursor:pointer;
      user-select:none;
    }
    .pill:hover{border-color: rgba(125,211,252,.55)}
    .pill small{color:var(--muted); font-weight:600}
    .chips{display:flex; flex-wrap:wrap; gap:8px}
    .split{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    .kpi{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .dot{width:9px; height:9px; border-radius:50%}
    .dot.ok{background:var(--ok)}
    .dot.bad{background:var(--bad)}
    .mono{font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
    .log{
      max-height:260px; overflow:auto; padding:10px 12px;
      border-radius:14px; border:1px solid rgba(35,50,74,.9);
      background: rgba(255,255,255,.06); color:var(--muted);
      font-size:12px; line-height:1.35;
      white-space:pre-wrap;
    }
    .sliderRow{display:flex; align-items:center; gap:12px}
    input[type="range"]{width:100%}
    .mini{font-size:12px; color:var(--muted)}
    .inputNumber{width:120px}
    .advancedBox{margin-top:14px; border:1px solid var(--line); border-radius:12px; padding:10px 12px; background: rgba(14,22,38,.45);}
    .advancedBox summary{cursor:pointer; font-weight:700; color:var(--muted); letter-spacing:.2px; text-transform:uppercase; font-size:11px;}
    .advancedBox[open]{padding-bottom:12px}
    .warn{color: #fbbf24}
    .ok{color: var(--ok)}
    .bad{color: var(--bad)}
    .hint{color:var(--muted); font-size:12px; margin-top:10px; line-height:1.35}
    .hint code{color:#c7d2fe}
    
    .topActions{display:flex; gap:10px; align-items:center}
    .btn.ghost{background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.12)}
    .btn.ghost:hover{background: rgba(255,255,255,.10)}
    .helpBtn{display:inline-flex; align-items:center; gap:8px}
    .helpBtn .q{display:inline-flex; width:18px; height:18px; border-radius:999px; align-items:center; justify-content:center;
      border:1px solid rgba(255,255,255,.18); color: var(--txt); font-weight:800; font-size:12px; background: rgba(255,255,255,.06);
    }

    /* Modal */
    .modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; padding:18px; background: rgba(0,0,0,.35); z-index:9999;}
    .modal.open{display:flex}
    .modalCard{
      width:min(860px, 100%);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      box-shadow: 0 18px 44px rgba(0,0,0,.30);
      overflow:hidden;
    }
    .modalHd{padding:14px 14px 10px; border-bottom:1px solid rgba(255,255,255,.12); display:flex; justify-content:space-between; align-items:center; gap:12px}
    .modalHd h2{margin:0; font-size:14px; letter-spacing:.3px}
    .modalBd{padding:14px}
    .modalBd p{margin:0 0 10px; color: var(--muted); font-size:13px; line-height:1.45}
    .modalBd ul{margin:8px 0 14px 18px; color: var(--muted); font-size:13px; line-height:1.45}
    .kbd{font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace; padding:2px 6px; border-radius:8px;
      border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06); color: var(--txt); font-size:12px;
    }

    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr}
    }
  
    /* Requested UI changes (no deletion, only hiding) */
    #swingBlock{display:none}
    #logBlock{display:none}
    #ppqPill{display:none}

    /* Modal: solid (no translucency) */
    .modalCard{background: var(--panel) !important;}

    /* Theme toggle */
    html[data-theme="dark"]{
      --bg:#121826;
      --panel:#182238;
      --panel2:#1d2a45;
      --txt:#eef2ff;
      --muted:#aab6cc;
      --line:#2b3b57;
      --accent:#38bdf8;
      --accent2:#a78bfa;
      --bad:#fb7185;
      --ok:#34d399;
      --shadow: 0 10px 24px rgba(0,0,0,.28);
    }
    html[data-theme="light"]{
      --bg:#e8edf6;
      --panel:#f3f6fb;
      --panel2:#e9eff8;
      --txt:#121826;
      --muted:#445066;
      --line:#c9d3e3;
      --accent:#0ea5e9;
      --accent2:#7c3aed;
      --bad:#ef476f;
      --ok:#0f9d58;
      --shadow: 0 10px 24px rgba(12,18,40,.12);
    }
    html[data-theme="light"] body{
      background: radial-gradient(900px 520px at 18% 12%, rgba(14,165,233,.10), transparent 60%),
                  radial-gradient(900px 520px at 82% 18%, rgba(124,58,237,.10), transparent 60%),
                  var(--bg);
      color:var(--txt);
    }
    html[data-theme="light"] textarea,
    html[data-theme="light"] select,
    html[data-theme="light"] input[type="number"]{
      background: rgba(18,24,38,.04);
      color: var(--txt);
      border-color: var(--line);
    }
    html[data-theme="light"] .btn{
      background: rgba(18,24,38,.04);
      color: var(--txt);
      border-color: var(--line);
    }
    html[data-theme="light"] .btn:hover{
      background: rgba(18,24,38,.07);
      border-color: rgba(14,165,233,.35);
    }
    html[data-theme="light"] .pill{
      background: rgba(18,24,38,.04);
      border-color: var(--line);
      color: var(--txt);
    }

  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Jazz Comping Generator - Jaime Jaramillo Arias</h1>
      <div class="sub">Escribe una progresión, genera variaciones de comping, escucha por tu salida MIDI y exporta el resultado.</div>
    </div>
    <div class="kpi">
      <div class="pill" title="Estado de carga de carpeta y MIDI">
        <span class="dot bad" id="dotReady"></span>
        <span id="readyText">No listo</span>
      </div>
      <div class="pill" id="ppqPill" title="PPQ detectado en los archivos de referencia">
        <small>PPQ</small>
        <span class="mono" id="ppqText">—</span>
      </div>
    </div>
    <div class="topActions">
      <button class="btn ghost helpBtn" id="btnHelp" title="Abrir ayuda">
        <span class="q">?</span><span>Ayuda</span>
      </button>
      <button class="btn ghost" id="btnTheme" title="Cambiar modo claro/oscuro">Modo</button>
    </div>
  </header>

  <div class="grid">
    <section class="card">
      <div class="hd">
        <div class="title">Progresión</div>
        <div class="row">
<button class="btn primary" id="btnRegenerate" title="Generar de nuevo con variación aleatoria">Regenerar</button>
          <button class="btn" id="btnClean" title="Insertar NoteOff en notas demasiado largas y limpiar artefactos">Limpiar artefactos MIDI</button>
          <button class="btn purple" id="btnExport" title="Exportar el MIDI generado">Exportar</button>
        </div>
      </div>
      <div class="bd">
        <div class="label">Repeticiones</div>
        <div class="row" style="gap:14px; align-items:flex-end">
          <input id="repeatCount" type="number" min="1" max="64" value="1" class="inputNumber" title="Número de veces que se repetirá la progresión en el MIDI generado" />
          <div class="mini">Cuántas veces se repetirá la progresión al reproducir o exportar el MIDI.</div>
        </div>

        <div style="height:10px"></div>

        <textarea id="prog" spellcheck="false" title="Escribe la progresión usando barras: | Cmaj7 | o | Dm7 G7 |" placeholder="Escribe una progresión con barras. Ej: | Cmaj7 | o | Dm7 G7 |" ></textarea>

        <div style="height:12px"></div>

        <div class="label">Cifrados disponibles (calidades) <span class="mini">(clic para insertar)</span></div>
        <div class="chips" id="qualityChips"></div>


        <div class="hint">
          <div><b>Calidades:</b> aparecen en la lista después de cargar tus patrones.</div>
          <div style="margin-top:6px">Usa exactamente las calidades que ves (ej: <code>G7alt</code>, <code>F13(b9)</code>).</div>
        </div>

        <details class="advancedBox">
          <summary>Menú avanzado</summary>
          <div style="height:8px"></div>
          <div class="label">Despoblado / denso</div>
          <div class="sliderRow">
            <div class="mini" style="width:90px">Despoblado</div>
            <input id="density" type="range" min="0" max="100" value="100" />
            <div class="mini" style="width:60px; text-align:right">Denso</div>
            <div class="mono" style="width:56px; text-align:right" id="densityVal">100%</div>
            <div class="mini" style="width:60px; text-align:right">Spread</div>
          </div>

          <div style="height:10px"></div>
          <label class="row" style="gap:10px; align-items:center">
            <input type="checkbox" id="densityProgressive" />
            <span class="mini">Densidad progresiva</span>
          </label>

          <label class="row" style="gap:10px; align-items:center; margin-top:2px">
            <input type="checkbox" id="progressiveSkips" />
            <span class="mini">Skips/spreads progresivos</span>
          </label>

          <div style="height:12px"></div>
          <div class="label">Límite inferior para subir 8va</div>
          <div class="row" style="gap:14px; align-items:flex-end">
            <input id="raiseFloor" type="number" min="0" max="120" value="58" class="inputNumber" title="Notas por debajo de este valor se transportan +12 al generar" />
            <div class="mini">Las notas por debajo de este límite se transportan una octava arriba.</div>
          </div>

          <div style="height:12px"></div>
          <label class="row" style="gap:10px; align-items:center">
            <input type="checkbox" id="skipClosed" />
            <span class="mini">Cerrado</span>
          </label>
          <label class="row" style="gap:10px; align-items:center">
            <input type="checkbox" id="skip2Simple" />
            <span class="mini">Skip 2</span>
          </label>
          <label class="row" style="gap:10px; align-items:center">
            <input type="checkbox" id="skip2Oct" />
            <span class="mini">Skip 2 octavado</span>
          </label>
          <label class="row" style="gap:10px; align-items:center">
            <input type="checkbox" id="skipSpread" />
            <span class="mini">Spreads</span>
          </label>
          <label class="row" style="gap:10px; align-items:center">
            <input type="checkbox" id="soloing" />
            <span class="mini">Soloing</span>
          </label>
        </details>
      </div>
    </section>

    <aside class="card">
      <div class="hd"><div class="title">Salida / Preview</div></div>
      <div class="bd">
        <div class="split">
          <div>
            <div class="label">Carpeta MIDI de referencia</div>
            <div class="row">
              <button class="btn" id="btnPickFolder" title="Cargar carpeta con archivos MIDI de referencia">Cargar carpeta</button>
              <input id="folderFallback" type="file" webkitdirectory multiple style="display:none" />
            </div>
            <div class="mini" id="folderStatus" style="margin-top:8px">Sin carpeta cargada.</div>
          </div>

          <div>
            <div class="label">Puerto MIDI de salida</div>
            <select id="midiOut" title="Elige el puerto MIDI de salida (destino) para la reproducción"></select>
            <div class="mini" id="midiStatus" style="margin-top:8px">Salida MIDI: —</div>
          </div>
        </div>

        <div style="height:14px"></div>

        <div class="label">Controles</div>
        <div class="row">
          <button class="btn primary" id="btnPlay" title="Reproducir el MIDI generado por el puerto seleccionado">Reproducir</button>
          <button class="btn bad" id="btnStop" title="Detener reproducción">Stop</button>
        </div>

        <div style="height:14px"></div>

        <div class="label">Tempo (BPM) — solo playback</div>
        <div class="sliderRow">
          <input id="tempo" type="range" min="40" max="240" value="120" />
          <div class="mono" style="width:56px; text-align:right" id="tempoVal">120</div>
        </div>

        <div style="height:10px"></div>
        <div id="swingBlock">

        <div class="label">Swing (%) — solo playback</div>
        <div class="sliderRow">
          <input id="swing" type="range" min="50" max="75" value="50" />
          <div class="mono" style="width:56px; text-align:right" id="swingVal">50</div>
        </div>

        <div style="height:10px"></div>
        </div>


        <div class="label">Bajo (velocidad 0–67) — solo playback <span class="mini" title="El bajo no se exporta, solo suena al previsualizar">(no exporta)</span></div>
        <div class="sliderRow">
          <input id="bassVel" type="range" min="0" max="67" value="42" title="Velocidad MIDI del bajo (0–67). Solo afecta la reproducción en la app." />
          <div class="mono" style="width:56px; text-align:right" id="bassVelVal">42</div>
        </div>

        <div style="height:14px"></div>
        <div id="logBlock">

        <div class="label">Log</div>
        <div class="log" id="log"></div>

        <div class="hint">
          Si WebMIDI o “cargar carpeta” no aparecen, abre esto desde <code>http://localhost</code>.
          En mac: <code>python3 -m http.server 8000</code> y abre <code>http://localhost:8000</code>.
        </div>
        </div>

      </div>
    </aside>
  </div>
</div>


<div class="modal" id="helpModal" aria-hidden="true">
  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modalHd">
      <h2 id="helpTitle">Ayuda</h2>
      <div class="row">
        <button class="btn" id="btnHelpClose" title="Cerrar ayuda">Cerrar</button>
      </div>
    </div>
    <div class="modalBd">
      <p><b>Manual rápido</b></p>
      <ul>
        <li><b>1) Cargar patrones:</b> pulsa <span class="kbd">Cargar carpeta</span> y elige la carpeta con tus patrones MIDI.</li>
        <li><b>2) Progresión:</b> escribe con barras. Ej: <span class="kbd">| Dm7 G7 | Cmaj7 |</span>.</li>
        <li><b>3) Calidades:</b> haz clic en la lista para insertar la calidad exacta.</li>
        <li><b>4) Regenerar:</b> crea una nueva variación.</li>
        <li><b>5) Escuchar:</b> selecciona tu <b>Puerto MIDI de salida</b> y pulsa <span class="kbd">Reproducir</span>. Usa <span class="kbd">Stop</span> para detener.</li>
        <li><b>6) Ajustes de escucha:</b> cambia el <b>Tempo</b> y la <b>Velocidad del bajo</b> (solo para la pre-escucha).</li>
        <li><b>7) Exportar:</b> guarda el resultado con <span class="kbd">Exportar</span>.</li>
      </ul>
      <p class="mini">Atajo: <span class="kbd">Espacio</span> alterna Reproducir / Stop (cuando no estás escribiendo).</p>

    </div>
  </div>
</div>


<script>
// -- MIDI utils embebidos para funcionar sin servidor (file://)
// Copiado de midi-utils.browser.js
function readU32(dv, o){ return dv.getUint32(o, false); }
function readU16(dv, o){ return dv.getUint16(o, false); }

function readVarLen(u8, i) {
  let value = 0;
  for (let k=0; k<4; k++){
    const b = u8[i++];
    value = (value << 7) | (b & 0x7F);
    if ((b & 0x80) === 0) return [value, i];
  }
  return [value, i];
}

function writeVarLen(n) {
  let buffer = n & 0x7F;
  const bytes = [];
  while ((n >>= 7) > 0) {
    buffer <<= 8;
    buffer |= ((n & 0x7F) | 0x80);
  }
  while (true) {
    bytes.push(buffer & 0xFF);
    if (buffer & 0x80) buffer >>= 8;
    else break;
  }
  return Uint8Array.from(bytes);
}

function str4(u8, o) {
  return String.fromCharCode(u8[o],u8[o+1],u8[o+2],u8[o+3]);
}

function parseTrack(trackU8) {
  let i = 0;
  let absTick = 0;
  let runningStatus = null;
  let trackName = null;
  const events = [];

  while (i < trackU8.length) {
    let delta; [delta, i] = readVarLen(trackU8, i);
    absTick += delta;

    let status = trackU8[i++];

    if (status < 0x80) {
      if (runningStatus === null) throw new Error("Running status inválido.");
      i--;
      status = runningStatus;
    } else {
      runningStatus = status;
    }

    if (status === 0xFF) {
      const type = trackU8[i++];
      let mlen; [mlen, i] = readVarLen(trackU8, i);
      const meta = trackU8.slice(i, i+mlen);
      i += mlen;

      if (type === 0x03) {
        try { trackName = new TextDecoder().decode(meta).trim(); } catch(_){}
      }
      continue;
    }

    if (status === 0xF0 || status === 0xF7) {
      let slen; [slen, i] = readVarLen(trackU8, i);
      i += slen;
      runningStatus = null;
      continue;
    }

    const hi = status & 0xF0;
    let d1, d2;
    if (hi === 0xC0 || hi === 0xD0) {
      d1 = trackU8[i++]; d2 = null;
    } else {
      d1 = trackU8[i++]; d2 = trackU8[i++];
    }

    events.push({ tick: absTick, status, ch: status & 0x0F, d1, d2 });
  }

  return { name: trackName, events, endTick: absTick };
}

function parseMidi(input) {
  const u8 = (input instanceof Uint8Array) ? input : new Uint8Array(input);
  const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
  let i = 0;

  if (str4(u8,i) !== "MThd") throw new Error("No es un MIDI válido (falta MThd).");
  const hlen = readU32(dv, i+4);
  const format = readU16(dv, i+8);
  const ntrks = readU16(dv, i+10);
  const division = readU16(dv, i+12);
  if (division & 0x8000) throw new Error("SMPTE timecode no soportado.");
  const ppq = division;
  i += 8 + hlen;

  const tracks = [];
  for (let t=0; t<ntrks; t++){
    if (str4(u8,i) !== "MTrk") throw new Error("No es un MIDI válido (falta MTrk).");
    const len = readU32(dv, i+4);
    const start = i + 8;
    const end = start + len;
    const data = u8.slice(start, end);
    tracks.push(parseTrack(data));
    i = end;
  }

  return { format, ppq, tracks };
}

function buildMidiFile({ division, tracks }) {
  const chunks = [];
  const encoder = new TextEncoder();

  const hdr = new Uint8Array(14);
  const dv = new DataView(hdr.buffer);
  hdr.set(encoder.encode("MThd"), 0);
  dv.setUint32(4, 6, false);
  dv.setUint16(8, tracks.length === 1 ? 0 : 1, false);
  dv.setUint16(10, tracks.length, false);
  dv.setUint16(12, division, false);
  chunks.push(hdr);

  for (const track of tracks) {
    const bytes = [];
    let prevTick = 0;
    for (const e of track.events) {
      const delta = e.absTick - prevTick;
      prevTick = e.absTick;
      const deltaBytes = writeVarLen(delta);
      bytes.push(...deltaBytes);

      if (e.type === "meta") {
        bytes.push(0xFF, e.metaType);
        const lenBytes = writeVarLen(e.data.length);
        bytes.push(...lenBytes, ...e.data);
      }
      else if (e.type === "sysex") {
        const prefix = e.status ?? 0xF0;
        bytes.push(prefix);
        const lenBytes = writeVarLen(e.data.length);
        bytes.push(...lenBytes, ...e.data);
      }
      else if (e.type === "midi") {
        const status = ((e.eType & 0x0F) << 4) | (e.ch & 0x0F);
        bytes.push(status, e.d1 & 0x7F);
        if (e.d2 !== null && e.d2 !== undefined) {
          bytes.push(e.d2 & 0x7F);
        }
      }
    }

    const endOfTrack = [0x00, 0xFF, 0x2F, 0x00];
    bytes.push(...endOfTrack);

    const trackArr = Uint8Array.from(bytes);
    const trk = new Uint8Array(8 + trackArr.length);
    const dvTrk = new DataView(trk.buffer);
    trk.set(encoder.encode("MTrk"), 0);
    dvTrk.setUint32(4, trackArr.length, false);
    trk.set(trackArr, 8);
    chunks.push(trk);
  }

  const totalLength = chunks.reduce((sum, c) => sum + c.length, 0);
  const out = new Uint8Array(totalLength);
  let pos = 0;
  for (const c of chunks) {
    out.set(c, pos);
    pos += c.length;
  }
  return out;
}

function sanitizeEvents(events) {
  const evs = events.slice().sort((a,b)=> (a.tick-b.tick) || (a.order-b.order));
  const active = new Map();
  const cleaned = [];

  const keyOf = (ch, note) => ch + "-" + note;
  const pushOff = (tick, ch, note, order) => cleaned.push({ tick, status: (0x80 | ch), d1: note, d2: 0, order });

  let lastTick = 0;

  for (const e of evs) {
    const status = e.status & 0xFF;
    const hi = status & 0xF0;
    const ch = status & 0x0F;
    const d1 = e.d1 & 0x7F;
    const d2 = (e.d2 ?? 0) & 0x7F;

    if (typeof e.tick === "number") lastTick = Math.max(lastTick, e.tick);

    if (hi === 0xB0 && (d1 === 120 || d1 === 123 || d1 === 121)) {
      active.clear();
      cleaned.push({ ...e, d1, d2 });
      continue;
    }

    if (hi === 0x90 && d2 > 0) {
      const k = keyOf(ch, d1);
      const prevCount = active.get(k) || 0;
      if (prevCount > 0) {
        const offOrder = (typeof e.order === "number") ? Math.max(0, e.order - 1) : 2;
        for (let i=0; i<prevCount; i++) pushOff(e.tick, ch, d1, offOrder);
      }
      active.set(k, 1);
      cleaned.push({ ...e, d1, d2 });
      continue;
    }

    if (hi === 0x80 || (hi === 0x90 && d2 === 0)) {
      const k = keyOf(ch, d1);
      const prevCount = active.get(k) || 0;
      if (prevCount > 0) {
        active.set(k, prevCount - 1);
      }
      cleaned.push({ ...e, d1, d2 });
      continue;
    }

    cleaned.push({ ...e, d1, d2 });
  }

  if (active.size) {
    const cleanupTick = lastTick + 1;
    for (const [key, count] of active.entries()) {
      if (count <= 0) continue;
      const [chStr, noteStr] = key.split("-");
      const ch = parseInt(chStr, 10);
      const note = parseInt(noteStr, 10);
      const safeCount = Math.max(1, count);
      for (let i=0; i<safeCount; i++) pushOff(cleanupTick, ch, note, 5);
    }
  }

  return cleaned;
}

function enforceMaxNoteLength(events, tickPerEighth, maxEighths=3) {
  if (!events?.length) return events;
  const maxDur = tickPerEighth * Math.max(1, maxEighths);
  const evs = events.slice().sort((a,b)=> (a.tick - b.tick) || ((a.order ?? 0) - (b.order ?? 0)));
  const active = new Map();
  const out = [];
  let lastTick = 0;

  const keyOf = (ch, note) => `${ch}-${note}`;
  const pushOff = (tick, ch, note, order=3) => {
    out.push({ tick, status: 0x80 | (ch & 0x0F), d1: note & 0x7F, d2: 0, order });
  };

  for (const e of evs) {
    const status = e.status & 0xFF;
    const hi = status & 0xF0;
    const ch = status & 0x0F;
    const note = e.d1 & 0x7F;
    const vel = (e.d2 ?? 0) & 0x7F;
    const order = e.order;

    if (typeof e.tick === "number") lastTick = Math.max(lastTick, e.tick);

    if (hi === 0x90 && vel > 0) {
      const entry = active.get(keyOf(ch, note)) || [];
      entry.push({ deadline: e.tick + maxDur, order });
      active.set(keyOf(ch, note), entry);
      out.push({ ...e, d1: note, d2: vel });
      continue;
    }

    if (hi === 0x80 || (hi === 0x90 && vel === 0)) {
      const key = keyOf(ch, note);
      const stack = active.get(key);
      if (stack?.length) {
        const state = stack.shift();
        if (!stack.length) active.delete(key);
        const offTick = Math.min(e.tick, state.deadline);
        lastTick = Math.max(lastTick, offTick);
        out.push({ ...e, tick: offTick, d1: note, d2: 0 });
      } else {
        out.push({ ...e, d1: note, d2: 0 });
      }
      continue;
    }

    out.push({ ...e, d1: note, d2: vel });
  }

  if (active.size) {
    for (const [key, stack] of active.entries()) {
      const [chStr, noteStr] = key.split("-");
      const ch = parseInt(chStr, 10) || 0;
      const note = parseInt(noteStr, 10) || 0;
      for (const state of stack) {
        const offTick = Math.max(lastTick, state.deadline);
        pushOff(offTick, ch, note, state.order ?? 3);
      }
    }
  }

  return out.sort((a,b)=> (a.tick - b.tick) || ((a.order ?? 0) - (b.order ?? 0)));
}

function dropLongNotesAndSustain(events, tickPerEighth, maxEighths=4) {
  if (!events?.length || !tickPerEighth) return events;

  const maxDur = tickPerEighth * Math.max(1, maxEighths);
  const indexed = events.map((e, idx) => ({ ...e, _idx: idx }));
  const sorted = indexed.slice().sort((a,b)=> (a.tick - b.tick) || ((a.order ?? 0) - (b.order ?? 0)));

  const active = new Map();
  const toRemove = new Set();

  const keyOf = (ch, note) => `${ch}-${note}`;

  for (const ev of sorted) {
    const status = ev.status & 0xFF;
    const hi = status & 0xF0;
    const ch = status & 0x0F;
    const note = ev.d1 & 0x7F;
    const vel = (ev.d2 ?? 0) & 0x7F;

    if (hi === 0xB0 && note === 64) {
      toRemove.add(ev._idx);
      continue;
    }

    if (hi === 0x90 && vel > 0) {
      const stack = active.get(keyOf(ch, note)) || [];
      stack.push(ev);
      active.set(keyOf(ch, note), stack);
      continue;
    }

    const isOff = hi === 0x80 || (hi === 0x90 && vel === 0);
    if (isOff) {
      const key = keyOf(ch, note);
      const stack = active.get(key);
      const onEv = stack?.shift();
      if (stack && stack.length === 0) active.delete(key);

      if (onEv) {
        const dur = ev.tick - onEv.tick;
        if (dur > maxDur) {
          toRemove.add(onEv._idx);
          toRemove.add(ev._idx);
        }
      }
    }
  }

  if (active.size) {
    for (const stack of active.values()) {
      for (const onEv of stack) {
        toRemove.add(onEv._idx);
      }
    }
  }

  return events.filter((_, idx) => !toRemove.has(idx));
}

function disableUnsupportedMidiMessages(events) {
  if (!events?.length) return events;

  const allowed = [];
  for (const e of events) {
    const status = e.status & 0xFF;
    const hi = status & 0xF0;
    const d1 = e.d1 & 0x7F;
    const vel = (e.d2 ?? 0) & 0x7F;

    const isNoteOn = hi === 0x90 && vel > 0;
    const isNoteOff = hi === 0x80 || (hi === 0x90 && vel === 0);
    if (isNoteOn || isNoteOff) {
      allowed.push({ ...e, d1, d2: vel });
    }
  }

  return allowed;
}

const MidiUtils = {
  readU32,
  readU16,
  readVarLen,
  writeVarLen,
  str4,
  parseTrack,
  parseMidi,
  buildMidiFile,
  sanitizeEvents,
  enforceMaxNoteLength,
  dropLongNotesAndSustain,
  disableUnsupportedMidiMessages,
};

if (typeof globalThis !== "undefined") {
  globalThis.MidiUtils = MidiUtils;
}
</script>
<script>
(() => {
  const {
    buildMidiFile,
    disableUnsupportedMidiMessages,
    dropLongNotesAndSustain,
    enforceMaxNoteLength,
    parseMidi,
    sanitizeEvents,
  } = globalThis.MidiUtils ?? {};

  if (!buildMidiFile) {
    throw new Error("No se pudo cargar midi-utils en el navegador.");
  }
  // -------------------------
  // Config / constants
  // -------------------------
  let QUALITIES = []; // se llena desde los nombres de archivo de la carpeta cargada
  // Mapa: calidad exacta -> datos del MIDI de referencia

  // Reference MIDI assumptions (as per your spec)
  const TIME_SIG_NUM = 4;
  const TIME_SIG_DEN = 4;
  const REF_BPM_EXPORT = 120; // export tempo fixed

  // Ventana base: 16 corcheas (2 compases).
  // Si el archivo tiene 16 corcheas exactas, se usa completo (1 sola ventana).
  // Si el archivo tiene 32 corcheas o más, se crean ventanas de 16 corcheas y se escoge una al azar por bloque.
  const WINDOW_EIGHTS = 16; // 16 eighth-notes


  // -------------------------
  // UI handles
  // -------------------------
  const el = (id) => document.getElementById(id);
  const logEl = el("log");
  const dotReady = el("dotReady");
  const readyText = el("readyText");
  const ppqText = el("ppqText");
  const folderStatus = el("folderStatus");
  const midiOutSel = el("midiOut");
  const midiStatus = el("midiStatus");
  const tempo = el("tempo");
  const tempoVal = el("tempoVal");
  const swing = el("swing");
  const swingVal = el("swingVal");
  const bassVel = el("bassVel");
  const bassVelVal = el("bassVelVal");
  const repeatCount = el("repeatCount");
  const density = el("density");
  const densityVal = el("densityVal");
  const densityProgressive = el("densityProgressive");
  const progressiveSkips = el("progressiveSkips");
  const raiseFloor = el("raiseFloor");
  const skipClosed = el("skipClosed");
  const skip2Simple = el("skip2Simple");
  const skip2Oct = el("skip2Oct");
  const skipSpread = el("skipSpread");
  const soloing = el("soloing");

  function log(msg, cls="") {
    const line = cls ? `[${cls}] ${msg}` : msg;
    logEl.textContent += line + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }
  function clearLog() { logEl.textContent = ""; }

  function setReady(isReady, text) {
    dotReady.className = "dot " + (isReady ? "ok" : "bad");
    readyText.textContent = text;
  }

  // -------------------------
  // Random
  // -------------------------
  function randInt(maxExclusive) {
    const a = new Uint32Array(1);
    crypto.getRandomValues(a);
    return a[0] % maxExclusive;
  }
  function choice(arr) { return arr[randInt(arr.length)]; }
  const randUnit = () => randInt(0x100000000) / 0x100000000;

  // Bajo (solo playback): convierte semitonos desde C a una nota entre C1(24) y C3(48)
  function bassNoteFromTranspose(semi) {
    let note = 36 + (semi % 12); // base C2=36
    if (note > 48) note -= 12;
    if (note < 24) note += 12;
    return note;
  }

  // -------------------------
  // Note / root parsing + transpose mapping (up to F# upward, G..B downward)
  // -------------------------
  const NOTE_TO_SEMI = new Map([
    ["C",0], ["B#",0],
    ["C#",1], ["DB",1],
    ["D",2],
    ["D#",3], ["EB",3],
    ["E",4], ["FB",4],
    ["F",5], ["E#",5],
    ["F#",6], ["GB",6],
    ["G",7],
    ["G#",8], ["AB",8],
    ["A",9],
    ["A#",10], ["BB",10],
    ["B",11], ["CB",11]
  ]);

  function normalizeAccidentals(s) {
    return s.replaceAll("♭","b").replaceAll("♯","#");
  }

  function parseChordToken(tokRaw) {
    const tok = normalizeAccidentals(tokRaw.trim());
    const m = tok.match(/^([A-Ga-g])([#b]?)(.*)$/);
    if (!m) throw new Error(`No entiendo el acorde: "${tokRaw}"`);
    const root = (m[1].toUpperCase() + (m[2]||"")).toUpperCase();
    const qualRaw = (m[3]||"").trim();
    const qualKey = normalizeQuality(qualRaw);
    if (!qualKey) throw new Error(`Calidad faltante en "${tokRaw}". Ej: Dm7, G9, A7alt, Cmaj7.`);
    const semiUpward = NOTE_TO_SEMI.get(root.toUpperCase());
    if (semiUpward === undefined) throw new Error(`Fundamental inválida: "${root}"`);

    // Upward from C only until F# (0..6). For G..B, transpose downward from C.
    const transpose = semiUpward > 6 ? semiUpward - 12 : semiUpward;

    return { root, quality: qualKey, transpose };
  }

  function normalizeQuality(q) {
    // Exacto: la calidad es exactamente lo que se escribe después de la fundamental.
    // Sin alias ni conversiones (solo trim).
    let s = (q || "").trim();
    s = normalizeAccidentals(s);
    if (!s) return null;
    return s;
  }

  // -------------------------
  // Progression parsing (bars with | |)
  // Rules:
  // | X | -> 8 eighths
  // | X Y | -> 4 + 4 eighths
  // Anything else -> error (by spec)
  // -------------------------
  function parseProgression(text) {
    const raw = text.replace(/\r/g,"").trim();
    if (!raw) throw new Error("Escribe una progresión.");
    const parts = raw.split("|").map(s => s.trim()).filter(Boolean);
    if (parts.length === 0) throw new Error("Usa barras | |. Ej: | Bbmaj7 Gm9 | ...");

    const segments = [];
    let startEighth = 0;
    let lastBarChords = null;

    const addBar = (barChords, source="") => {
      if (!barChords || !barChords.length) {
        throw new Error(`Barra inválida: "${source || ''}". Solo 1 o 2 acordes por compás.`);
      }

      if (barChords.length !== 1 && barChords.length !== 2) {
        throw new Error(`Barra inválida: "${source || barChords.join(' ')}". Solo 1 o 2 acordes por compás.`);
      }

      const each = (barChords.length === 1) ? 8 : 4;
      const stored = [];
      for (const c of barChords) {
        const parsed = parseChordToken(c);
        segments.push({
          ...parsed,
          token: c,
          startEighth,
          durEighth: each
        });
        startEighth += each;
        stored.push(c);
      }

      lastBarChords = stored;
    };

    // 1) Construimos la progresión "recta" (sin síncopa):
    for (const bar of parts) {
      if (bar === "%") {
        if (!lastBarChords) throw new Error("El signo % solo se puede usar después del primer compás.");
        addBar(lastBarChords, bar);
        continue;
      }

      const chords = bar.split(/\s+/).map(s=>s.trim()).filter(Boolean);
      addBar(chords, bar);
    }

    const totalEighthNominal = startEighth;

    // 2) "Síncopa jazz" CON REGLA DE MÍNIMO:
    //    - Intentamos adelantar cada cambio 1 corchea.
    //    - Pero garantizamos que cada acorde dure al menos MEDIO COMPÁS (4 corcheas).
    //      (Esto evita acordes de 3 corcheas cuando hay 2 acordes por compás.)
    const MIN_CHORD_EIGHTS = 4;

    if (segments.length >= 2) {
      // Proponemos nuevos inicios (adelantados 1 corchea), pero sin violar el mínimo.
      for (let i = 1; i < segments.length; i++) {
        const prevStart = segments[i-1].startEighth;
        const proposed = Math.max(0, segments[i].startEighth - 1);
        const minAllowed = prevStart + MIN_CHORD_EIGHTS;
        segments[i].startEighth = Math.max(proposed, minAllowed);
      }

      // Asegura inicios estrictamente crecientes (por seguridad)
      for (let i = 1; i < segments.length; i++) {
        if (segments[i].startEighth <= segments[i-1].startEighth) {
          segments[i].startEighth = segments[i-1].startEighth + 1;
        }
      }

      // Recalcula duraciones: cada acorde dura hasta el siguiente inicio.
      for (let i = 0; i < segments.length - 1; i++) {
        segments[i].durEighth = segments[i+1].startEighth - segments[i].startEighth;
      }
      segments[segments.length - 1].durEighth = totalEighthNominal - segments[segments.length - 1].startEighth;

      // Safety: evita duraciones raras y respeta mínimo
      for (const s of segments) {
        if (s.durEighth <= 0) s.durEighth = 1;
        if (s.durEighth < MIN_CHORD_EIGHTS) s.durEighth = MIN_CHORD_EIGHTS;
      }
    }

// No cambiamos el "final" total: solo movemos fronteras internas.
    return { segments, totalEighth: totalEighthNominal, totalBars: parts.length };
  }

  function repeatSegments(segments, totalEighth, times) {
    const t = Math.max(1, Math.floor(times));
    if (t === 1) return { segments, totalEighth };

    const out = [];
    for (let i = 0; i < t; i++) {
      const offset = i * totalEighth;
      for (const s of segments) {
        out.push({ ...s, startEighth: s.startEighth + offset });
      }
    }

    return { segments: out, totalEighth: totalEighth * t };
  }

  function getRepeatTimes() {
    let n = parseInt(repeatCount.value, 10);
    if (!Number.isFinite(n)) n = 1;
    n = Math.max(1, Math.min(64, n));
    repeatCount.value = String(n);
    return n;
  }

    // -------------------------
    // Reference library loading
    // -------------------------
  let midiAccess = null;
  let midiOutputs = [];
  let refByQuality = new Map(); // qualityKey -> {ppq, events, windowsPerFile, tickPerEighth, winTicks}
  let refPpq = null;
  let folderLoaded = false;

  function makeKeyVariants(name) {
    const base = name.toLowerCase().trim().replace(/\.(mid|midi)$/,"");
    const v = new Set();
    v.add(base);
    v.add(base.replace(/[\s_]/g,""));
    v.add(base.replace(/[()]/g,""));
    v.add(base.replace(/[()\s_]/g,""));
    return [...v];
  }

  function indexReferenceFile(qualityKey, midiObj) {
    const ppq = midiObj.ppq;
    if (refPpq === null) refPpq = ppq;
    if (ppq !== refPpq) throw new Error(`PPQ inconsistente. Esperaba ${refPpq}, encontré ${ppq}.`);

    // Requisito: UNA SOLA PISTA por archivo de referencia.
    if (!midiObj.tracks || midiObj.tracks.length !== 1) {
      throw new Error(`"${qualityKey}": el MIDI debe tener 1 sola pista. Encontré ${midiObj.tracks ? midiObj.tracks.length : 0}.`);
    }

    const tr = midiObj.tracks[0];
    let events = tr.events ? [...tr.events] : [];

    const tickPerEighth = ppq / 2;
    if ((ppq % 2) !== 0) {
      throw new Error(`"${qualityKey}": PPQ inválido (${ppq}). Debe ser par para poder contar corcheas.`);
    }

    const minTicks = WINDOW_EIGHTS * tickPerEighth; // 16 corcheas = 2 compases

    // Longitud real del archivo: no depende de Note On/Off; incluye silencios hasta End-Of-Track.
    let maxTick = 0;
    for (const e of events) if ((e.tick|0) > maxTick) maxTick = e.tick|0;

    const trackLenTicks = (typeof tr.endTick === "number" && tr.endTick > 0) ? (tr.endTick|0) : maxTick;

    // Dummy anchor si el archivo arranca en silencio: evita cortes y asegura conteo desde la primera corchea.
    let minTick = Infinity;
    for (const e of events) if ((e.tick|0) < minTick) minTick = (e.tick|0);
    const anchors = [];
    const pushDummyNote = (tick) => {
      anchors.push({ tick, status: 0x90, d1: 0, d2: 1 });
      anchors.push({ tick, status: 0x80, d1: 0, d2: 0 });
    };
    if (!Number.isFinite(minTick) || minTick > 0) pushDummyNote(0);

    if (trackLenTicks < minTicks) {
      throw new Error(`"${qualityKey}": demasiado corto. Debe tener al menos 16 corcheas (2 compases).`);
    }

    // El MIDI de referencia debe venir cuantizado a corcheas, aunque haya silencios.
    if ((trackLenTicks % tickPerEighth) !== 0) {
      throw new Error(`"${qualityKey}": longitud no cuantizada a corcheas. Ajusta el final del archivo a una corchea exacta.`);
    }

    const totalEighths = trackLenTicks / tickPerEighth;

    // Requisito: múltiplos de 16 corcheas por archivo de referencia.
    if ((totalEighths % WINDOW_EIGHTS) !== 0) {
      throw new Error(`"${qualityKey}": longitud inválida. Debe ser múltiplo de ${WINDOW_EIGHTS} corcheas; encontré ${totalEighths}.`);
    }

    const windowsPerFile = totalEighths / WINDOW_EIGHTS;
    const winTicks = WINDOW_EIGHTS * tickPerEighth; // ventana en ticks

    // Dummy anchors en cada ventana para respetar la primera corchea aunque sea silencio.
    for (let w = 0; w < windowsPerFile; w++) {
      pushDummyNote(w * winTicks);
    }

    if (anchors.length) {
      events = events.concat(anchors).sort((a,b)=> (a.tick - b.tick) || ((a.status&0xF0) - (b.status&0xF0)));
    }

    // Precomputo: evita seleccionar ventanas completamente silenciosas al azar.
    // Guardamos, por ventana de 16 corcheas, el primer NoteOn (vel>0) relativo a la ventana.
    // Si no hay notas en una ventana, queda Infinity.
    const firstNoteOnRel = new Array(windowsPerFile).fill(Infinity);
    for (const e of events) {
      const status = (e.status ?? 0) & 255;
      const hi = status & 0xF0;
      const vel = (e.d2 ?? 0) & 127;
      if (hi === 0x90 && vel > 0) {
        const w = Math.floor((e.tick|0) / winTicks);
        if (w >= 0 && w < windowsPerFile) {
          const rel = (e.tick|0) - (w * winTicks);
          if (rel < firstNoteOnRel[w]) firstNoteOnRel[w] = rel;
        }
      }
    }


    refByQuality.set(qualityKey, {
      ppq,
      tickPerEighth,
      winTicks,
      windowsPerFile,
      firstNoteOnRel,
      events
    });
  }

  async function loadFolderViaPicker() {
    // Prefer File System Access API if available
    if (window.showDirectoryPicker) {
      const dir = await window.showDirectoryPicker();
      const collect = async (handle, acc) => {
        for await (const [, child] of handle.entries()) {
          if (child.kind === "file") {
            acc.push(await child.getFile());
          } else if (child.kind === "directory") {
            await collect(child, acc);
          }
        }
      };

      const files = [];
      await collect(dir, files);
      return { name: dir.name || "carpeta", files };
    }

    // Fallback: <input webkitdirectory>
    return await new Promise((resolve, reject) => {
      const input = el("folderFallback");
      input.onchange = () => {
        const list = [...input.files];
        if (!list.length) reject(new Error("No se encontraron archivos en esa carpeta."));
        else resolve({ name: "carpeta", files: list });
      };
      input.click();
    });
  }

  async function loadReferenceFolder() {
    clearLog();
    refByQuality.clear();
    refPpq = null;
    QUALITIES = [];
    renderQualityChips();

    ppqText.textContent = "—";
    setReady(false, "Cargando…");
    folderLoaded = false;
    folderStatus.textContent = "Cargando…";

    try{
      const { name, files } = await loadFolderViaPicker();
      const folderFiles = files;

      folderStatus.textContent = `Carpeta: ${name} — ${folderFiles.length} archivo(s).`;

      const skipped = [];
      const dups = [];
      const found = [];

      for (const f of folderFiles) {
        const fullName = (f.name || "").trim();
        if (!fullName) { skipped.push("(sin nombre)"); continue; }

        // Calidad = nombre de archivo SIN la última extensión (si la hay)
        const base = fullName.replace(/\.[^.]+$/,"").trim();
        if (!base) { skipped.push(fullName); continue; }

        // No soportamos espacios en la "calidad" porque el parser separa por whitespace.
        if (/\s/.test(base)) { skipped.push(fullName); continue; }

        if (refByQuality.has(base)) { dups.push(base); }

        try{
          const buf = await f.arrayBuffer();
          const midi = parseMidi(buf);
          indexReferenceFile(base, midi);
          found.push(base);
        } catch(err) {
          skipped.push(fullName);
          continue;
        }
      }

      QUALITIES = [...new Set(refByQuality.keys())].sort((a,b)=>a.localeCompare(b, "en"));

      renderQualityChips();

      ppqText.textContent = (refPpq ?? "—");

      if (!QUALITIES.length) {
        log("No encontré calidades válidas. Revisa que los nombres de archivo no tengan espacios y que los archivos sean MIDI.", "ERROR");
        setReady(false, "No listo");
        return;
      }

      if (skipped.length) {
        log(`Archivos ignorados (no MIDI / nombre inválido / con espacios / demasiado cortos / más de una pista): ${skipped.join(", ")}`, "WARN");
      }
      if (dups.length) {
        log(`Duplicados: se usó el último archivo para: ${[...new Set(dups)].join(", ")}`, "WARN");
      }

      log(`Cargadas ${QUALITIES.length} calidad(es) desde la carpeta.`, "OK");
      folderLoaded = true;
      setReady(true, "Listo");
    } catch(err){
      setReady(false, "No listo");
      folderStatus.textContent = "Error al cargar carpeta.";
      QUALITIES = [];
      renderQualityChips();
      log(String(err?.message || err), "ERROR");
    }
  }

  // -------------------------
  // Generation (core)
  // -------------------------
    let generated = {
      ppq: null,
      events: [],     // channel events, abs ticks, include {tick, status, d1, d2, order}
    lengthTicks: 0,
    debug: {}
  };

  function ensureQualityLoaded(q) {
    if (!refByQuality.has(q)) throw new Error(`No tengo el MIDI de referencia para "${q}".`);
  }

  function channelEvent(tick, status, d1, d2, order=3) {
    return { tick, status: status & 255, d1: d1 & 127, d2: (d2==null?0:(d2&127)), order };
  }

  let raiseFloorValue = 58; // Default A#3/Bb3 floor (MIDI number)
  function setRaiseFloorValue(raw) {
    let v = parseInt(raw, 10);
    if (!Number.isFinite(v)) v = 58;
    v = Math.max(0, Math.min(120, v));
    raiseFloorValue = v;
    raiseFloor.value = String(v);
  }

  function raiseBelowFloor(note) {
    if (note < raiseFloorValue) return note + 12;
    return note;
  }

  function applyRaiseFloor(events) {
    if (!events?.length) return events;

    let changed = false;
    const mapped = events.map((ev) => {
      const status = ev.status & 0xF0;
      const isNoteOn = status === 0x90;
      const isNoteOff = status === 0x80 || (status === 0x90 && (ev.d2 ?? 0) === 0);
      if (!isNoteOn && !isNoteOff) return ev;

      const raised = raiseBelowFloor(ev.d1 ?? 0);
      if (raised === (ev.d1 ?? 0)) return ev;
      changed = true;
      return { ...ev, d1: raised };
    });

    return changed ? mapped : events;
  }

  function enforceChordsOnly(events) {
    if (!events?.length) return events;

    const noteOnByTick = new Map();
    const sorted = events.map((e, idx) => ({ e, idx }))
      .sort((a,b)=> (a.e.tick - b.e.tick) || ((a.e.order ?? 0) - (b.e.order ?? 0)));

    for (const { e, idx } of sorted) {
      const status = e.status & 0xFF;
      const hi = status & 0xF0;
      const vel = e.d2 ?? 0;
      if (!(hi === 0x90 && vel > 0)) continue;
      const key = e.tick;
      if (!noteOnByTick.has(key)) noteOnByTick.set(key, []);
      noteOnByTick.get(key).push(idx);
    }

    const toDrop = new Set();
    for (const arr of noteOnByTick.values()) {
      if (arr.length === 1) toDrop.add(arr[0]);
    }

    const active = new Map(); // "ch-note" -> stack of noteOn idx
    const offsToDrop = new Set();
    const keyOf = (ch, note) => ch + "-" + note;

    for (const { e, idx } of sorted) {
      const status = e.status & 0xFF;
      const hi = status & 0xF0;
      const ch = status & 0x0F;
      const note = e.d1 & 0x7F;
      const vel = e.d2 ?? 0;

      if (hi === 0x90 && vel > 0) {
        const k = keyOf(ch, note);
        if (!active.has(k)) active.set(k, []);
        active.get(k).push(idx);
      } else if (hi === 0x80 || (hi === 0x90 && vel === 0)) {
        const k = keyOf(ch, note);
        const stack = active.get(k);
        if (stack?.length) {
          const onIdx = stack.shift();
          if (!stack.length) active.delete(k);
          if (toDrop.has(onIdx)) offsToDrop.add(idx);
        }
      }
    }

    const remove = new Set([...toDrop, ...offsToDrop]);
    if (!remove.size) return events;
    return events.filter((_, idx) => !remove.has(idx));
  }

  function applySkip2Transform(events, mode) {
    if (!mode || !events?.length) return events;
    const shouldDouble = mode === "octavado";

    const sorted = events.slice().sort((a,b)=> (a.tick - b.tick) || ((a.order ?? 0) - (b.order ?? 0)));
    const toShift = new Set();
    const byTickCh = new Map();

    for (const e of sorted) {
      const status = e.status & 255;
      const hi = status & 0xF0;
      const ch = status & 0x0F;
      const vel = e.d2 ?? 0;
      if (!(hi === 0x90 && vel > 0)) continue;
      const key = `${e.tick}|${ch}`;
      if (!byTickCh.has(key)) byTickCh.set(key, []);
      byTickCh.get(key).push(e);
    }

    for (const group of byTickCh.values()) {
      if (group.length < 3) continue;
      const sortedGroup = group.slice().sort((a,b)=> (a.d1 ?? 0) - (b.d1 ?? 0));
      const target = sortedGroup[1];
      toShift.add(target);
    }

    const shiftedActive = new Map(); // ch-noteOriginal -> queue of [oct1, oct2]
    const extraEvents = [];
    const keyOf = (ch, note) => ch + "-" + note;

    for (const e of sorted) {
      const status = e.status & 255;
      const hi = status & 0xF0;
      const ch = status & 0x0F;
      const vel = e.d2 ?? 0;
      const note = e.d1 ?? 0;
      const baseOrder = (typeof e.order === "number") ? e.order : 3;

      if (hi === 0x90 && vel > 0) {
        if (toShift.has(e)) {
          const newNote1 = Math.min(127, note + 12);
          const newNote2 = shouldDouble ? Math.min(127, note + 24) : null;
          e.d1 = newNote1;

          if (shouldDouble && newNote2 != null) {
            const duplicate = { ...e, d1: newNote2, order: baseOrder + 0.1 };
            extraEvents.push(duplicate);
          }

          const k = keyOf(ch, note);
          if (!shiftedActive.has(k)) shiftedActive.set(k, []);
          shiftedActive.get(k).push([newNote1, newNote2]);
        }
      } else if (hi === 0x80 || (hi === 0x90 && vel === 0)) {
        const k = keyOf(ch, note);
        const stack = shiftedActive.get(k);
        if (stack?.length) {
          const mapped = stack.shift();
          const [oct1, oct2] = Array.isArray(mapped) ? mapped : [mapped, null];
          e.d1 = oct1;
          if (oct2 != null) {
            const off = { ...e, d1: oct2, order: baseOrder + 0.1 };
            extraEvents.push(off);
          }
          if (!stack.length) shiftedActive.delete(k);
        }
      }
    }

    if (!extraEvents.length) return events;
    return events.concat(extraEvents);
  }

  function applySpreadTransform(events) {
    if (!events?.length) return events;

    const sorted = events.slice().sort((a, b) => (a.tick - b.tick) || ((a.order ?? 0) - (b.order ?? 0)));
    const byTickCh = new Map();
    const toShift = new Set();
    const duplicates = [];

    const clampNote = (n) => Math.max(0, Math.min(127, n));

    for (const e of sorted) {
      const status = e.status & 255;
      const hi = status & 0xF0;
      const ch = status & 0x0F;
      const vel = e.d2 ?? 0;
      if (!(hi === 0x90 && vel > 0)) continue;
      const key = `${e.tick}|${ch}`;
      if (!byTickCh.has(key)) byTickCh.set(key, []);
      byTickCh.get(key).push(e);
    }

    for (const group of byTickCh.values()) {
      if (!group.length) continue;
      const ordered = group.slice().sort((a, b) => (a.d1 ?? 0) - (b.d1 ?? 0));
      const top = ordered[ordered.length - 1];
      duplicates.push({ src: top, note: clampNote((top.d1 ?? 0) + 12) });

      if (ordered.length >= 2) {
        const second = ordered[1];
        toShift.add(second);
        duplicates.push({ src: second, note: clampNote((second.d1 ?? 0) + 24) });
      }
    }

    if (!toShift.size && !duplicates.length) return events;

    const spreadActive = new Map(); // "ch-note" -> queue of {notes: number[]}
    const keyOf = (ch, note) => `${ch}-${note}`;
    const extraEvents = [];

    for (const e of sorted) {
      const status = e.status & 255;
      const hi = status & 0xF0;
      const ch = status & 0x0F;
      const vel = e.d2 ?? 0;
      const note = e.d1 ?? 0;
      const isOn = hi === 0x90 && vel > 0;
      const isOff = hi === 0x80 || (hi === 0x90 && vel === 0);
      const baseOrder = (typeof e.order === "number") ? e.order : 3;

      if (!isOn && !isOff) continue;

      if (isOn) {
        const shiftUp = toShift.has(e) ? 12 : 0;
        const baseNote = clampNote(note + shiftUp);
        e.d1 = baseNote;

        const dupNotes = duplicates
          .filter((d) => d.src === e)
          .map((d) => d.note)
          .filter((n) => typeof n === "number");

        for (const [idx, dupNote] of dupNotes.entries()) {
          const duplicateEv = { ...e, d1: dupNote, order: baseOrder + 0.1 + idx * 0.05 };
          extraEvents.push(duplicateEv);
        }

        const key = keyOf(ch, note);
        if (!spreadActive.has(key)) spreadActive.set(key, []);
        spreadActive.get(key).push({ notes: [baseNote, ...dupNotes] });
      } else if (isOff) {
        const key = keyOf(ch, note);
        const queue = spreadActive.get(key);
        if (queue?.length) {
          const { notes } = queue.shift();
          const [baseNote, ...dupNotes] = notes;
          e.d1 = baseNote;
          if (!queue.length) spreadActive.delete(key);

          for (const [idx, dupNote] of dupNotes.entries()) {
            const offEv = channelEvent(e.tick, status, dupNote, 0, (baseOrder ?? 3) + 0.1 + idx * 0.05);
            extraEvents.push(offEv);
          }
        }
      }
    }

    if (!extraEvents.length) return events;
    return sorted.concat(extraEvents).sort((a, b) => (a.tick - b.tick) || ((a.order ?? 0) - (b.order ?? 0)));
  }

  function addPanicAtTick(out, tick, channelsSet, order=2) {
    // Limpieza anti-artefactos: Reset All Controllers (121), Sustain Off (64), All Notes Off (123), All Sound Off (120)
    for (const ch of channelsSet) {
      out.push(channelEvent(tick, 0xB0 | ch, 121, 0, order));
      out.push(channelEvent(tick, 0xB0 | ch, 64, 0, order));
      out.push(channelEvent(tick, 0xB0 | ch, 123, 0, order));
      out.push(channelEvent(tick, 0xB0 | ch, 120, 0, order));
    }
  }

  function getSelectedSkipModes() {
    const modes = [];
    if (skipClosed?.checked) modes.push(null);
    if (skip2Simple?.checked) modes.push("simple");
    if (skip2Oct?.checked) modes.push("octavado");
    if (skipSpread?.checked) modes.push("spread");
    return modes;
  }

  function applyManualSkipModes(events, segments, tickPerEighth) {
    const modes = getSelectedSkipModes();
    if (!events?.length || !modes.length) return events;
    if (!segments?.length || !Number.isFinite(tickPerEighth)) {
      return applySkipMode(events, choice(modes));
    }

    const spans = segments.map((s) => ({
      startTick: s.startEighth * tickPerEighth,
      endTick: (s.startEighth + s.durEighth) * tickPerEighth,
    }));

    const findSegmentIndex = (tick) => {
      for (let i = 0; i < spans.length; i++) {
        const seg = spans[i];
        if (tick >= seg.startTick && tick < seg.endTick) return i;
      }
      return -1;
    };

    const grouped = new Map();
    const outside = [];

    for (const e of events) {
      const segIndex = findSegmentIndex(e.tick);
      if (segIndex < 0) {
        outside.push(e);
        continue;
      }
      if (!grouped.has(segIndex)) grouped.set(segIndex, []);
      grouped.get(segIndex).push(e);
    }

    const result = [];
    const orderedSegIndexes = [...grouped.keys()].sort((a, b) => a - b);
    for (const segIndex of orderedSegIndexes) {
      const mode = choice(modes);
      const chunk = grouped.get(segIndex) || [];
      const transformed = applySkipMode(chunk.slice(), mode);
      result.push(...transformed);
    }

    result.push(...outside);
    return result;
  }

  function applySkipMode(events, mode) {
    if (mode === "spread") return applySpreadTransform(events);
    if (mode === "simple" || mode === "octavado") return applySkip2Transform(events, mode);
    return events;
  }

  function isSoloingMode() {
    return !!soloing?.checked;
  }

  function applySoloingMode(events, endTick, ppqVal) {
    if (!isSoloingMode()) return events;
    if (!events?.length) return events;

    const sorted = events.slice().sort((a, b) => (a.tick - b.tick) || ((a.order ?? 0) - (b.order ?? 0)));
    const result = [];
    const active = new Map();

    for (const e of sorted) {
      const status = e.status & 0xF0;
      const ch = e.status & 0x0F;
      const note = e.d1 ?? 0;
      const vel = e.d2 ?? 0;
      const isOn = status === 0x90 && vel > 0;
      const isOff = status === 0x80 || (status === 0x90 && vel === 0);

      result.push(e);

      if (!isOn && !isOff) continue;

      const key = `${ch}-${note}`;
      if (isOn) active.set(key, { ch, note });
      else if (isOff) active.delete(key);
    }

    if (active.size) {
      const fallbackTick = sorted[sorted.length - 1]?.tick ?? 0;
      const computedOffTick = fallbackTick + (ppqVal ?? 0);
      const offTick = typeof endTick === "number" ? Math.min(endTick, computedOffTick) : computedOffTick;
      for (const { ch, note } of active.values()) {
        result.push(channelEvent(offTick, 0x80 | ch, note, 0, 3));
      }
    }

    return result.sort((a, b) => (a.tick - b.tick) || ((a.order ?? 0) - (b.order ?? 0)));
  }

  function insertNoteOffsForLongNotes(events, maxLenTicks, totalLength) {
    if (!events?.length) return events;
    const sorted = events.slice().sort((a, b) => (a.tick - b.tick) || ((a.order ?? 0) - (b.order ?? 0)));
    const active = new Map();
    const extra = [];

    for (const e of sorted) {
      const status = e.status & 0xF0;
      const ch = e.status & 0x0F;
      const note = e.d1 ?? 0;
      const vel = e.d2 ?? 0;
      const isOn = status === 0x90 && vel > 0;
      const isOff = status === 0x80 || (status === 0x90 && vel === 0);
      if (!isOn && !isOff) continue;

      const key = `${ch}-${note}`;

      if (isOn) {
        active.set(key, e.tick);
      } else {
        const start = active.get(key);
        if (start != null && (e.tick - start) > maxLenTicks) {
          const forcedTick = start + maxLenTicks;
          if (forcedTick < e.tick) extra.push(channelEvent(forcedTick, 0x80 | ch, note, 0, (e.order ?? 3) - 0.1));
        }
        active.delete(key);
      }
    }

    const endTick = typeof totalLength === "number" ? totalLength : (sorted[sorted.length - 1]?.tick ?? 0);
    for (const [key, start] of active.entries()) {
      const [chStr, noteStr] = key.split("-");
      const ch = parseInt(chStr, 10) || 0;
      const note = parseInt(noteStr, 10) || 0;
      const forcedTick = start + maxLenTicks;
      extra.push(channelEvent(Math.min(endTick, forcedTick), 0x80 | ch, note, 0, 3));
    }

    if (!extra.length) return sorted;
    return sorted.concat(extra).sort((a, b) => (a.tick - b.tick) || ((a.order ?? 0) - (b.order ?? 0)));
  }

  function sanitizeChannelEvents(events) {
    if (!events?.length) return [];

    const evs = events.slice().sort((a, b) => (a.tick - b.tick) || ((a.order ?? 0) - (b.order ?? 0)));
    const active = new Map();
    const cleaned = [];
    let lastTick = 0;

    const keyOf = (ch, note) => `${ch}-${note}`;
    const pushOff = (tick, ch, note, order) => cleaned.push({ tick, status: (0x80 | ch), d1: note, d2: 0, order });

    for (const e of evs) {
      const status = e.status & 0xFF;
      const hi = status & 0xF0;
      const ch = status & 0x0F;
      const d1 = e.d1 & 0x7F;
      const d2 = (e.d2 ?? 0) & 0x7F;

      if (typeof e.tick === "number") lastTick = Math.max(lastTick, e.tick);

      if (hi === 0xB0 && (d1 === 120 || d1 === 123 || d1 === 121)) {
        active.clear();
        cleaned.push({ ...e, d1, d2 });
        continue;
      }

      if (hi === 0x90 && d2 > 0) {
        const k = keyOf(ch, d1);
        const prevCount = active.get(k) || 0;
        if (prevCount > 0) {
          const offOrder = (typeof e.order === "number") ? Math.max(0, e.order - 1) : 2;
          for (let i = 0; i < prevCount; i++) pushOff(e.tick, ch, d1, offOrder);
        }
        active.set(k, prevCount + 1);
        cleaned.push({ ...e, d1, d2 });
        continue;
      }

      if (hi === 0x80 || (hi === 0x90 && d2 === 0)) {
        const k = keyOf(ch, d1);
        const prevCount = active.get(k) || 0;
        if (prevCount > 0) {
          active.set(k, prevCount - 1);
        }
        cleaned.push({ ...e, d1, d2 });
        continue;
      }

      cleaned.push({ ...e, d1, d2 });
    }

    if (active.size) {
      const cleanupTick = lastTick + 1;
      for (const [key, count] of active.entries()) {
        if (count <= 0) continue;
        const [chStr, noteStr] = key.split("-");
        const ch = parseInt(chStr, 10);
        const note = parseInt(noteStr, 10);
        const safeCount = Math.max(1, count);
        for (let i = 0; i < safeCount; i++) pushOff(cleanupTick, ch, note, 5);
      }
    }

    return cleaned;
  }

  function normalizeExportEvents(events) {
    if (!events?.length) return [];

    const sanitized = sanitizeChannelEvents(events);

    const filtered = sanitized
      .filter((e) => {
        const hi = e.status & 0xF0;
        const note = e.d1 & 0x7F;
        const vel = (e.d2 ?? 0) & 0x7F;
        const isNoteOn = hi === 0x90 && vel > 0;
        const isNoteOff = hi === 0x80 || (hi === 0x90 && vel === 0);

        if (!isNoteOn && !isNoteOff) return false;

        // Anchors/dummies: nota 0 con velocidad mínima insertada para mantener la
        // cuadrícula de corcheas en los archivos de referencia. No deben exportarse.
        const isAnchor = note === 0 && vel <= 1;
        return !isAnchor;
      })
      .map((e) => {
        const hi = e.status & 0xF0;
        const note = e.d1 & 0x7F;
        const vel = (e.d2 ?? 0) & 0x7F;
        const isNoteOff = hi === 0x80 || (hi === 0x90 && vel === 0);

        return {
          type: "midi",
          absTick: e.tick | 0,
          eType: isNoteOff ? 0x8 : 0x9,
          ch: 0, // fuerza TODO a un solo canal para evitar pistas extra al importar
          d1: note,
          d2: isNoteOff ? 0 : vel,
        };
      });

    return filtered.sort((a, b) => (a.absTick - b.absTick) || (a.d1 - b.d1));
  }

  function removeNotesOutsideRange(events, minLenTicks, maxLenTicks, totalLength) {
    if (!events?.length) return events;
    const sorted = events.slice().sort((a, b) => (a.tick - b.tick) || ((a.order ?? 0) - (b.order ?? 0)));
    const active = new Map();
    const toDrop = new Set();
    let lastTick = 0;

    const keyOf = (ch, note) => `${ch}-${note}`;
    const mark = (ev) => { if (ev) toDrop.add(ev); };

    for (const e of sorted) {
      const status = e.status & 0xF0;
      const ch = e.status & 0x0F;
      const note = e.d1 ?? 0;
      const vel = e.d2 ?? 0;
      const isOn = status === 0x90 && vel > 0;
      const isOff = status === 0x80 || (status === 0x90 && vel === 0);

      if (typeof e.tick === "number") lastTick = Math.max(lastTick, e.tick);

      if (!isOn && !isOff) continue;

      const key = keyOf(ch, note);

      if (isOn) {
        active.set(key, e);
        continue;
      }

      const startEv = active.get(key);
      if (startEv) {
        const dur = e.tick - startEv.tick;
        if (dur > maxLenTicks || dur < minLenTicks) {
          mark(startEv);
          mark(e);
        }
        active.delete(key);
      }
    }

    const finalTick = typeof totalLength === "number" ? totalLength : lastTick;
    for (const startEv of active.values()) {
      const dur = finalTick - startEv.tick;
      if (dur > maxLenTicks || dur < minLenTicks) mark(startEv);
    }

    if (!toDrop.size) return events;
    return events.filter((ev) => !toDrop.has(ev));
  }

  function applyProgressiveSkips(events, segments, tickPerEighth) {
    if (!progressiveSkips?.checked) return events;
    if (!events?.length || !segments?.length) return events;

    const spans = segments.map((s) => ({
      startTick: s.startEighth * tickPerEighth,
      endTick: (s.startEighth + s.durEighth) * tickPerEighth,
    }));

    const findSegmentIndex = (tick) => {
      for (let i = 0; i < spans.length; i++) {
        const seg = spans[i];
        if (tick >= seg.startTick && tick < seg.endTick) return i;
      }
      return -1;
    };

    const grouped = new Map();
    const outside = [];

    for (const e of events) {
      const segIndex = findSegmentIndex(e.tick);
      if (segIndex < 0) {
        outside.push(e);
        continue;
      }
      if (!grouped.has(segIndex)) grouped.set(segIndex, []);
      grouped.get(segIndex).push(e);
    }

    const result = [];
    const lastIndex = spans.length - 1;

    const modeForSeg = (segIndex) => {
      if (lastIndex <= 0) return null;
      const ratio = segIndex / lastIndex;
      if (ratio < 0.25) return null; // cerrado
      if (ratio < 0.5) return randUnit() < 0.7 ? "simple" : null;
      if (ratio < 0.75) return randUnit() < 0.5 ? "simple" : "octavado";
      return "spread";
    };

    const orderedSegIndexes = [...grouped.keys()].sort((a, b) => a - b);
    for (const segIndex of orderedSegIndexes) {
      const mode = modeForSeg(segIndex);
      const chunk = grouped.get(segIndex) || [];
      if (!mode) {
        result.push(...chunk);
        continue;
      }
      const transformed = applySkipMode(chunk.slice(), mode);
      result.push(...transformed);
    }

    result.push(...outside);
    return result;
  }

  function applySkipsAfterDensity(events, segments, tickPerEighth) {
    if (!events?.length) return events;
    if (progressiveSkips?.checked) return applyProgressiveSkips(events, segments, tickPerEighth);

    return applyManualSkipModes(events, segments, tickPerEighth);
  }

  function getDensityFactor() {
    let v = parseInt(density.value, 10);
    if (!Number.isFinite(v)) v = 100;
    v = Math.max(0, Math.min(100, v));
    density.value = String(v);
    return v / 100;
  }

  function getProgressiveDensityProfile(segments) {
    if (!densityProgressive.checked || !segments?.length) return null;
    if (segments.length === 1) return [1];

    const last = segments.length - 1;
    return segments.map((_, idx) => {
      const ratio = idx / last;
      return Math.max(0.2, Math.min(1, 0.2 + ratio * 0.8));
    });
  }

  function applyDensityFilter(events, segments, tickPerEighth, densityFactor, densityBySegment=null) {
    if (!events?.length) return events;
    if (!segments?.length) return events;

    const clampDensity = (v) => Math.max(0, Math.min(1, v));
    const hasProfile = Array.isArray(densityBySegment) && densityBySegment.length === segments.length;
    const minDensity = hasProfile ? Math.min(...densityBySegment.map(clampDensity)) : clampDensity(densityFactor);
    if (minDensity >= 0.999) return events;

    const removal = new Set();

    const segSpans = segments.map(s => ({
      startTick: s.startEighth * tickPerEighth,
      endTick: (s.startEighth + s.durEighth) * tickPerEighth
    }));

    const findSegmentIndex = (tick) => {
      for (let i=0; i<segSpans.length; i++) {
        const seg = segSpans[i];
        if (tick >= seg.startTick && tick < seg.endTick) return i;
      }
      return -1;
    };

    const getDensityForSeg = (segIndex) => {
      if (hasProfile && segIndex >= 0) return clampDensity(densityBySegment[segIndex]);
      return clampDensity(densityFactor);
    };
    const removalStrengthForSeg = (segIndex) => 1 - getDensityForSeg(segIndex);

    const sortedIdx = events
      .map((_,i)=>i)
      .sort((a,b)=> (events[a].tick - events[b].tick) || ((events[a].order ?? 0) - (events[b].order ?? 0)));

    const active = new Map();
    const notePairs = [];
    for (const idx of sortedIdx) {
      const e = events[idx];
      const status = e.status & 255;
      const hi = status & 0xF0;
      const ch = status & 0x0F;
      const vel = e.d2 ?? 0;

      if (hi === 0x90 && vel > 0) {
        const key = ch + "-" + (e.d1 ?? 0);
        if (!active.has(key)) active.set(key, []);
        active.get(key).push({ idx, tick: e.tick });
      } else if (hi === 0x80 || (hi === 0x90 && vel === 0)) {
        const key = ch + "-" + (e.d1 ?? 0);
        const stack = active.get(key);
        if (stack && stack.length) {
          const on = stack.pop();
          const segIndex = findSegmentIndex(on.tick);
          notePairs.push({
            onIdx: on.idx,
            offIdx: idx,
            onTick: on.tick,
            offTick: e.tick,
            dur: e.tick - on.tick,
            ch,
            note: e.d1 ?? 0,
            segIndex
          });
        }
      }
    }

    const eighthTol = tickPerEighth * 0.2;
    const sortedPairs = notePairs.slice().sort((a,b)=> a.onTick - b.onTick);
    for (let i=0; i<sortedPairs.length; i++) {
      const p = sortedPairs[i];
      if (Math.abs(p.dur - tickPerEighth) > eighthTol) continue;
      const prev = sortedPairs[i-1];
      const next = sortedPairs[i+1];
      const hasPrev = prev && Math.abs(p.onTick - prev.onTick) <= tickPerEighth * 1.25 && Math.abs(prev.dur - tickPerEighth) <= eighthTol;
      const hasNext = next && Math.abs(next.onTick - p.onTick) <= tickPerEighth * 1.25 && Math.abs(next.dur - tickPerEighth) <= eighthTol;
      const removalStrength = removalStrengthForSeg(p.segIndex);
      if (hasPrev && hasNext && removalStrength > 0 && randUnit() < removalStrength) {
        if (p.onIdx != null) removal.add(p.onIdx);
        if (p.offIdx != null) removal.add(p.offIdx);
      }
    }

    const groupsBySeg = new Map();
    const groupList = [];
    const byTick = new Map();
    for (const p of notePairs) {
      const arr = byTick.get(p.onTick) || [];
      arr.push(p);
      byTick.set(p.onTick, arr);
    }

    for (const [tick, arr] of byTick.entries()) {
      const segIndex = findSegmentIndex(tick);
      if (segIndex < 0) continue;
      if (arr.length >= 3) {
        const g = { tick, segIndex, pairs: arr.slice() };
        groupList.push(g);
        if (!groupsBySeg.has(segIndex)) groupsBySeg.set(segIndex, []);
        groupsBySeg.get(segIndex).push(g);
      }
    }

    for (const arr of groupsBySeg.values()) arr.sort((a,b)=> a.tick - b.tick);

    const chordRemovalProbForSeg = (segIndex) => Math.max(0, removalStrengthForSeg(segIndex) - 0.2);
    for (const g of groupList) {
      const segGroups = groupsBySeg.get(g.segIndex) || [];
      const mustKeep = segGroups.length <= 1;
      const chordRemovalProb = chordRemovalProbForSeg(g.segIndex);
      if (!mustKeep && chordRemovalProb > 0 && randUnit() < chordRemovalProb) {
        for (const p of g.pairs) {
          if (p.onIdx != null) removal.add(p.onIdx);
          if (p.offIdx != null) removal.add(p.offIdx);
        }
        g.removed = true;
      }
    }

    const voiceRemovalThreshold = 0.55;
    for (const g of groupList) {
      if (g.removed) continue;
      const removalStrength = removalStrengthForSeg(g.segIndex);
      if (removalStrength > voiceRemovalThreshold) {
        const voiceProb = Math.min(1, (removalStrength - voiceRemovalThreshold) / (1 - voiceRemovalThreshold));
        const survivors = g.pairs.filter(p => !removal.has(p.onIdx));
        if (survivors.length <= 3) continue; // mantener al menos triada

        if (randUnit() < voiceProb) {
          const ordered = survivors.slice().sort((a,b)=> a.note - b.note);
          const target = randUnit() < 0.5 ? ordered[0] : ordered[ordered.length - 1];
          if (survivors.length - 1 >= 3) {
            if (target.onIdx != null) removal.add(target.onIdx);
            if (target.offIdx != null) removal.add(target.offIdx);
          }
        }
      }
    }

    for (const [segIdx, groups] of groupsBySeg.entries()) {
      let hasChord = false;
      for (const g of groups) {
        const survivors = g.pairs.filter(p => !removal.has(p.onIdx));
        if (survivors.length >= 3) { hasChord = true; break; }
      }
      if (!hasChord && groups.length) {
        const g = groups[0];
        for (const p of g.pairs) {
          removal.delete(p.onIdx);
          removal.delete(p.offIdx);
        }
      }
    }

    return events.filter((_, idx) => !removal.has(idx));
  }

  function generateMidiFromProgression(text) {
    clearLog();

    const { segments: baseSegments, totalEighth: baseTotalEighth } = parseProgression(text);
    const repeatTimes = getRepeatTimes();
    const { segments, totalEighth } = repeatSegments(baseSegments, baseTotalEighth, repeatTimes);
    if (refPpq == null) throw new Error("Primero carga la carpeta de referencias.");
    const ppq = refPpq;
    const tickPerEighth = ppq / 2;
    const winTicks = 8 * ppq;

    // Random seed por bloque de 2 compases en la línea de tiempo de salida
    const totalBlocks = Math.ceil(totalEighth / WINDOW_EIGHTS);
    const blockWindowSeed = [];
    for (let b=0; b<totalBlocks; b++){
      blockWindowSeed.push(randInt(0x100000000));
    }
    const out = [];
    let maxTick = 0;

    const usingSoloing = isSoloingMode();

    // generate segment by segment
    for (const seg of segments) {
      ensureQualityLoaded(seg.quality);
      const ref = refByQuality.get(seg.quality);

      const startTickOut = seg.startEighth * tickPerEighth;
      const durTicks = seg.durEighth * tickPerEighth;
      const windowOffsetTicks = (seg.startEighth % WINDOW_EIGHTS) * tickPerEighth;
      const remainingWindowTicks = ref.winTicks - windowOffsetTicks;
      const effectiveSpan = Math.min(durTicks, remainingWindowTicks);
      const endTickOut = startTickOut + durTicks;

      const block = Math.floor(seg.startEighth / WINDOW_EIGHTS);

      // Selección de ventana:
      // - Si el archivo es EXACTAMENTE 16 corcheas (windowsPerFile===1), NO hay ventanas aleatorias.
      // - Si el archivo tiene 32 corcheas o más (windowsPerFile>1), se elige una ventana por bloque de 16 corcheas.
      //   PERO: evitamos ventanas silenciosas (para que ningún acorde quede sin notas).
      let srcWindow;
      if (ref.windowsPerFile === 1) {
        srcWindow = 0;
      } else {
        const cand = (blockWindowSeed[block] % ref.windowsPerFile);
        srcWindow = cand;

        // Si la ventana candidata no tiene ningún NoteOn antes de que termine el acorde, buscamos otra.
        const noteHorizon = ref.firstNoteOnRel ? ref.firstNoteOnRel[srcWindow] : Infinity;
        const withinSpan = noteHorizon < (windowOffsetTicks + effectiveSpan);
        if (!withinSpan) {
          for (let off = 1; off <= ref.windowsPerFile; off++) {
            const w = (cand + off) % ref.windowsPerFile;
            const altHorizon = ref.firstNoteOnRel ? ref.firstNoteOnRel[w] : Infinity;
            if (altHorizon < (windowOffsetTicks + effectiveSpan)) { srcWindow = w; break; }
          }
        }
      }

      // Regla: al cambiar de acorde, se debe usar el material desde el INICIO de la ventana elegida.
      // Manteniendo el offset real dentro de la ventana según la posición de la progresión.
      const srcStart = (srcWindow * ref.winTicks) + windowOffsetTicks;
      const srcEnd = srcStart + durTicks;

      // Archivo de referencia con UNA SOLA PISTA
      const srcEvents = ref.events;

      const gapEndTickOut = startTickOut;
      // collect channels used in this segment (post-filter)
      const channelsUsed = new Set();

      // anti-artifact: cleanup at boundary BEFORE start events
      // (note-offs from prior segment are handled per segment end)
      // We'll still send a short panic at each chord boundary (safe).
      // order=2 means after any "end cleanup" at same tick (order=1) but before copied notes (order=3).
      // We'll decide channels from extracted events; if none, we panic channel 0 just in case.
      const extracted = [];
      // Conteo por nota para evitar artefactos si aparece NoteOn repetido antes de su NoteOff
      const activeCount = new Map(); // "ch-note" -> int
      const carryVel = new Map();    // "ch-note" -> last velocity
      const winBase = srcWindow * ref.winTicks;

      // --- Carryover: si en el patrón hay notas sostenidas que empezaron antes de srcStart,
      // las activamos al inicio del segmento para que el acorde suene "completo".
      for (const e of srcEvents) {
        if (e.tick < winBase || e.tick >= srcStart) continue;

        const status = e.status & 255;
        const hi = status & 0xF0;
        const ch = status & 0x0F;

        if (hi !== 0x80 && hi !== 0x90) continue;

        let note = (e.d1 ?? 0) + seg.transpose;
        let vel = e.d2 ?? 0;
        note = raiseBelowFloor(note);
        if (note < 0 || note > 127) continue;

        const key = ch + "-" + note;
        const isOn = (hi === 0x90) && vel > 0;
        const isOff = (hi === 0x80) || ((hi === 0x90) && vel === 0);

        if (isOn) {
          const cnt = activeCount.get(key) || 0;
          activeCount.set(key, cnt + 1);
          carryVel.set(key, vel);
        } else if (isOff) {
          const cnt = activeCount.get(key) || 0;
          if (cnt > 0) activeCount.set(key, cnt - 1);
        }
      }

      // Emitimos NoteOn de carryover al inicio del segmento (order 1, después del panic order 0)
      for (const [key, cnt] of activeCount.entries()) {
        if (cnt <= 0) continue;
        const [chStr, noteStr] = key.split("-");
        const ch = parseInt(chStr, 10);
        const note = parseInt(noteStr, 10);
        const vel = (carryVel.get(key) ?? 80) & 127;

        channelsUsed.add(ch);
        if (gapEndTickOut < endTickOut) extracted.push(channelEvent(gapEndTickOut, 0x90 | ch, note, vel, 1));
      }

      for (const e of srcEvents) {
        if (e.tick < srcStart || e.tick >= srcEnd) continue;

        const rel = e.tick - srcStart;
        const t = startTickOut + rel;

        const status = e.status & 255;
        const hi = status & 0xF0;
        const ch = status & 0x0F;

        // keep only within segment; ignore garbage
        if (hi === 0x80 || hi === 0x90) {
          let note = e.d1;
          let vel = e.d2 ?? 0;

          // transpose from C (up to +6, roots G..B go downward)
          note = note + seg.transpose;
          note = raiseBelowFloor(note);
          if (note < 0 || note > 127) continue;

          const key = ch + "-" + note;
          channelsUsed.add(ch);

          const isOn = (hi === 0x90) && vel > 0;
          const isOff = (hi === 0x80) || ((hi === 0x90) && vel === 0);

          if (isOn) {
            const cnt = activeCount.get(key) || 0;

            // Si ya estaba sonando, forzamos un NoteOff en el mismo tick (order 2) antes del nuevo NoteOn (order 3)
            if (cnt > 0) {
              extracted.push(channelEvent(t, 0x80 | ch, note, 0, 2));
            }

            activeCount.set(key, cnt + 1);
            extracted.push(channelEvent(t, 0x90 | ch, note, vel, 3));
          } else if (isOff) {
            const cnt = activeCount.get(key) || 0;
            // Solo dejamos NoteOff si hubo NoteOn dentro de esta ventana (evita offs raros por corte)
            if (cnt > 0) {
              activeCount.set(key, cnt - 1);
              extracted.push(channelEvent(t, 0x80 | ch, note, 0, 3));
            }
          }
        } else {
          // other channel events: keep them (CC, pitch bend, program, etc.)
          channelsUsed.add(ch);

          if (hi === 0xC0 || hi === 0xD0) {
            extracted.push({ tick: t, status, d1: e.d1 & 127, d2: 0, order: 3 });
          } else {
            extracted.push({ tick: t, status, d1: e.d1 & 127, d2: (e.d2 ?? 0) & 127, order: 3 });
          }
        }
      }

      if (channelsUsed.size === 0) channelsUsed.add(0);

      // PANIC at segment start (order 2) to avoid carryover artifacts
      addPanicAtTick(out, startTickOut, channelsUsed, 0);

      // Copy extracted events
      for (const e of extracted) out.push(e);

      // Segment end cleanup: fuerza NoteOff de todas las notas que quedaron activas en esta ventana
      const endChannels = new Set(channelsUsed);
      for (const [key, cnt] of activeCount.entries()) {
        if (cnt <= 0) continue;
        const [chStr, noteStr] = key.split("-");
        const ch = parseInt(chStr,10);
        const note = parseInt(noteStr,10);
        out.push(channelEvent(endTickOut, 0x80 | ch, note, 0, 1)); // order 1: cleanup first
      }
      // also clear sustain / notes at segment end (order 1)
      addPanicAtTick(out, endTickOut, endChannels, 1);

      if (endTickOut > maxTick) maxTick = endTickOut;
      const transpLabel = seg.transpose >= 0 ? `+${seg.transpose}` : `${seg.transpose}`;
      log(`Seg: ${seg.token}  q=${seg.quality}  srcWin=${srcWindow+1}/${ref.windowsPerFile}  transp=${transpLabel}`, "OK");
    }

    // Final global panic
    const allCh = new Set([...Array(16)].map((_,i)=>i));
    addPanicAtTick(out, maxTick, allCh, 1);

    const segmentsForBass = segments.map(s => ({
      token: s.token,
      transpose: s.transpose, // semitonos relativos desde C (G..B bajan una octava)
      startTick: s.startEighth * tickPerEighth,
      endTick: (s.startEighth + s.durEighth) * tickPerEighth
    }));

    const floored = applyRaiseFloor(out);
    const chordsOnly = usingSoloing ? floored : enforceChordsOnly(floored);
    const progressiveProfile = usingSoloing ? null : getProgressiveDensityProfile(segments);
    const densityFactor = usingSoloing ? 1 : (densityProgressive.checked ? 1 : getDensityFactor());
    const densityApplied = usingSoloing ? chordsOnly : applyDensityFilter(chordsOnly, segments, tickPerEighth, densityFactor, progressiveProfile);
    const skipAdjusted = usingSoloing ? chordsOnly : applySkipsAfterDensity(densityApplied, segments, tickPerEighth);
    const soloed = applySoloingMode(skipAdjusted, maxTick, ppq);
    const lengthLimited = enforceMaxNoteLength(soloed, tickPerEighth, 3);
    const cleaned = sanitizeEvents(lengthLimited);
    const noteOnly = disableUnsupportedMidiMessages(cleaned);
    const pruned = dropLongNotesAndSustain(noteOnly, tickPerEighth, 4);
    generated = { ppq, events: pruned, lengthTicks: maxTick, debug: { segmentsForBass } };

    log(`Listo. Longitud: ${maxTick} ticks (${(maxTick/(ppq))* (60/REF_BPM_EXPORT)} s a 120bpm).`, "OK");
    return generated;

  }
  // -------------------------
  // Playback (WebMIDI) with tempo + swing (only playback)
  // -------------------------
  function tickToMsSwung(tick, ppq, bpm, swingPct) {
    const msPerTick = (60_000 / bpm) / ppq;

    // swingPct: 50..75 -> ratio r in 0.5..0.75 for the off-beat position in the quarter
    const r = Math.min(0.75, Math.max(0.50, swingPct/100));
    const q = ppq;          // quarter ticks
    const e = ppq / 2;      // eighth ticks

    // Map inside each quarter
    const quarterIndex = Math.floor(tick / q);
    const pos = tick - quarterIndex * q;

    let newPos = pos;
    if (pos >= e) {
      // pos in [e, q): remap to [r*q, q)
      const t = (pos - e) / (q - e); // 0..1
      newPos = (r * q) + t * (q - (r*q));
    }
    const swungTick = quarterIndex * q + newPos;
    return swungTick * msPerTick;
  }

  function getSelectedOutput() {
    const id = midiOutSel.value;
    return midiOutputs.find(o => o.id === id) || null;
  }

  function panicNow(out) {
    if (!out) return;
    for (let ch=0; ch<16; ch++){
      out.send([0xB0|ch, 64, 0]);
      out.send([0xB0|ch, 123, 0]);
      out.send([0xB0|ch, 120, 0]);
    }
  }

  // Estado de reproducción (para poder detener de verdad)
  let isPlaying = false;
  let playTimers = [];
  let playOut = null;

  function stopPlayback() {
    isPlaying = false;
    for (const t of playTimers) clearTimeout(t);
    playTimers = [];

    const out = playOut || getSelectedOutput();
    if (out) {
      panicNow(out);
      const t2 = setTimeout(() => panicNow(out), 60);
      playTimers.push(t2);
    }
  }

  function playGenerated() {
    const out = getSelectedOutput();
    if (!out) { log("Selecciona un puerto MIDI de salida.", "ERROR"); return; }
    if (!generated?.events?.length) { log("Primero genera MIDI (Regenerar).", "ERROR"); return; }

    if (isPlaying) stopPlayback();

    isPlaying = true;
    playOut = out;

    panicNow(out);

    const bpm = parseInt(tempo.value, 10);
    const sw = 50; // swing desactivado
    const ppq = generated.ppq;

    const leadIn = 80;
    const base = performance.now() + leadIn;

    const evs = generated.events.slice().sort((a,b)=> (a.tick-b.tick) || (a.order-b.order));

    const schedule = (fn, delayMs) => {
      const id = setTimeout(() => { if (isPlaying) fn(); }, delayMs);
      playTimers.push(id);
    };

    let lastDelay = 0;
    for (const e of evs) {
      const status = e.status & 255;
      const hi = status & 0xF0;
      const tMs = tickToMsSwung(e.tick, ppq, bpm, sw);
      const delay = Math.max(0, Math.round((base + tMs) - performance.now()));
      if (delay > lastDelay) lastDelay = delay;

      schedule(() => {
        if (hi === 0xC0 || hi === 0xD0) out.send([status, e.d1 & 127]);
        else out.send([status, e.d1 & 127, (e.d2 ?? 0) & 127]);
      }, delay);
    }

    // Bajo SOLO para playback (NO export)
    const segs = generated.debug?.segmentsForBass || [];
    const BASS_CH = 15;
    const BASS_VEL = Math.max(0, Math.min(67, parseInt(bassVel.value, 10) || 0));

    const barTicks = 4 * ppq;
    const quarter = ppq;

    let si = 0;
    for (let barStart = 0; barStart < generated.lengthTicks; barStart += barTicks) {
      const pulses = [barStart, barStart + 2 * quarter];
      for (const t0 of pulses) {
        if (t0 >= generated.lengthTicks) continue;

        while (si < segs.length && t0 >= segs[si].endTick) si++;
        if (si >= segs.length) continue;
        if (t0 < segs[si].startTick) continue;

        const note = bassNoteFromTranspose(segs[si].transpose);

        const onDelay = Math.max(0, Math.round((base + tickToMsSwung(t0, ppq, bpm, sw)) - performance.now()));
        const offDelay = Math.max(0, Math.round((base + tickToMsSwung(t0 + quarter, ppq, bpm, sw)) - performance.now()));
        if (offDelay > lastDelay) lastDelay = offDelay;

        schedule(() => out.send([0x90 | BASS_CH, note & 127, BASS_VEL & 127]), onDelay);
        schedule(() => out.send([0x80 | BASS_CH, note & 127, 0]), offDelay);
      }
    }

    schedule(() => { isPlaying = false; }, lastDelay + 120);
  }

  // -------------------------
  // Export
  // -------------------------
  function exportGenerated() {
    if (!generated?.events?.length) { log("No hay MIDI generado.", "ERROR"); return; }

    const tempoMicro = Math.round(60_000_000 / REF_BPM_EXPORT);
    const tempoMeta = { type: "meta", absTick: 0, metaType: 0x51, data: [
      (tempoMicro >> 16) & 0xFF,
      (tempoMicro >> 8) & 0xFF,
      tempoMicro & 0xFF,
    ]};

    const timeSigMeta = { type: "meta", absTick: 0, metaType: 0x58, data: [
      TIME_SIG_NUM & 0xFF,
      Math.log2(TIME_SIG_DEN) & 0xFF,
      24, // MIDI clocks per metronome click
      8,  // 32nd notes per 24 MIDI clocks
    ]};

    const trackEvents = [
      tempoMeta,
      timeSigMeta,
      ...normalizeExportEvents(generated.events),
    ];

    const bytes = buildMidiFile({
      division: generated.ppq,
      tracks: [{ events: trackEvents }],
    });
    const blob = new Blob([bytes], { type: "audio/midi" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "generated.mid";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
    log("Exportado: generated.mid (una sola pista/canal, tempo fijo 120; swing NO afecta exportación).", "OK");
  }

  function cleanGenerated() {
    if (!generated?.events?.length) { log("No hay MIDI generado.", "ERROR"); return; }
    const ppqVal = generated.ppq ?? 960;
    const tickPerEighth = ppqVal / 2;
    const maxLen = Math.max(1, Math.round(tickPerEighth * 4)); // 4 corcheas
    const minLen = Math.max(1, Math.round(ppqVal / 8)); // 1/32

    const sanitized = sanitizeChannelEvents(generated.events);
    const ranged = removeNotesOutsideRange(sanitized, minLen, maxLen, generated.lengthTicks);
    const lengthLimited = insertNoteOffsForLongNotes(ranged, maxLen, generated.lengthTicks);
    generated.events = sanitizeChannelEvents(lengthLimited);

    log("MIDI limpiado: sin notas huérfanas, fuera de rango ni sostenidas en exceso.", "OK");
  }

  // -------------------------
  // WebMIDI init
  // -------------------------
  async function initMIDI() {
    try{
      if (!navigator.requestMIDIAccess) {
        midiStatus.innerHTML = `<span class="bad">MIDI no soportado en este navegador.</span>`;
        midiOutSel.innerHTML = `<option value="">(sin MIDI)</option>`;
        return;
      }
      midiAccess = await navigator.requestMIDIAccess({ sysex: false });
      midiStatus.innerHTML = `<span class="ok">MIDI listo.</span>`;
      refreshOutputs();

      midiAccess.onstatechange = () => refreshOutputs();
    } catch(err) {
      midiStatus.innerHTML = `<span class="bad">MIDI bloqueado.</span>`;
      log(String(err?.message || err), "ERROR");
    }
  }

  function refreshOutputs() {
    midiOutputs = [];
    midiOutSel.innerHTML = "";
    if (!midiAccess) {
      midiOutSel.innerHTML = `<option value="">(sin MIDI)</option>`;
      return;
    }
    for (const out of midiAccess.outputs.values()) midiOutputs.push(out);

    if (!midiOutputs.length) {
      midiOutSel.innerHTML = `<option value="">(no hay salidas)</option>`;
      return;
    }
    for (const out of midiOutputs) {
      const opt = document.createElement("option");
      opt.value = out.id;
      opt.textContent = out.name || out.manufacturer || out.id;
      midiOutSel.appendChild(opt);
    }
  }

  // -------------------------
  // UI wiring
  // -------------------------
  function updateDensityLabel() {
    densityVal.textContent = densityProgressive.checked ? "20→100%" : `${density.value}%`;
  }

  tempo.addEventListener("input", () => tempoVal.textContent = tempo.value);
  // swing desactivado
  bassVel.addEventListener("input", () => bassVelVal.textContent = bassVel.value);
  density.addEventListener("input", updateDensityLabel);
  densityProgressive.addEventListener("change", updateDensityLabel);
  repeatCount.addEventListener("input", () => getRepeatTimes());
  setRaiseFloorValue(raiseFloor.value);
  raiseFloor.addEventListener("input", () => setRaiseFloorValue(raiseFloor.value));
  function clearManualSkips() {
    if (skip2Simple) skip2Simple.checked = false;
    if (skip2Oct) skip2Oct.checked = false;
    if (skipSpread) skipSpread.checked = false;
  }

  function handleManualSkipsChange() {
    if (progressiveSkips) progressiveSkips.checked = false;
  }

  function setAdvancedControlsEnabled(enabled) {
    const controls = [density, densityProgressive, progressiveSkips, raiseFloor, skipClosed, skip2Simple, skip2Oct, skipSpread];
    for (const ctrl of controls) {
      if (!ctrl) continue;
      ctrl.disabled = !enabled;
      if (!enabled && ctrl.type === "checkbox") ctrl.checked = false;
    }

    if (!enabled && density) {
      density.value = "100";
      updateDensityLabel();
    }
  }
  skip2Simple?.addEventListener("change", handleManualSkipsChange);
  skip2Oct?.addEventListener("change", handleManualSkipsChange);
  skipSpread?.addEventListener("change", handleManualSkipsChange);
  skipClosed?.addEventListener("change", handleManualSkipsChange);
  progressiveSkips?.addEventListener("change", () => {
    if (progressiveSkips.checked) {
      if (skipClosed) skipClosed.checked = false;
      clearManualSkips();
    }
  });
  soloing?.addEventListener("change", () => {
    const active = soloing.checked;
    setAdvancedControlsEnabled(!active);
    if (active) {
      clearManualSkips();
      if (skipClosed) skipClosed.checked = false;
      if (progressiveSkips) progressiveSkips.checked = false;
      if (densityProgressive) densityProgressive.checked = false;
      density.value = "100";
      updateDensityLabel();
    }
  });

  // Ayuda (modal)
  const helpModal = el("helpModal");
  const btnHelp = el("btnHelp");
  const btnHelpClose = el("btnHelpClose");
  function openHelp(){
    helpModal.classList.add("open");
    helpModal.setAttribute("aria-hidden","false");
  }
  function closeHelp(){
    helpModal.classList.remove("open");
    helpModal.setAttribute("aria-hidden","true");
  }
  btnHelp.addEventListener("click", openHelp);
  btnHelpClose.addEventListener("click", closeHelp);

  // Tema claro/oscuro
  const btnTheme = el("btnTheme");
  const root = document.documentElement;
  function setTheme(t){
    root.setAttribute("data-theme", t);
    try{ localStorage.setItem("jcg_theme", t); }catch(_){}
  }
  const savedTheme = (()=>{ try{ return localStorage.getItem("jcg_theme"); } catch(_){ return null; } })();
  setTheme(savedTheme || "dark");
  btnTheme.addEventListener("click", () => {
    const cur = root.getAttribute("data-theme") || "dark";
    setTheme(cur === "dark" ? "light" : "dark");
  });

  helpModal.addEventListener("click", (e) => { if (e.target === helpModal) closeHelp(); });
  window.addEventListener("keydown", (e) => { if (e.key === "Escape") closeHelp(); });

  // Barra espaciadora: Play/Stop (solo si NO estás escribiendo)
  window.addEventListener("keydown", (e) => {
    if (e.code !== "Space" && e.key != " ") return;

    const ae = document.activeElement;
    const tag = ae && ae.tagName ? ae.tagName.toLowerCase() : "";
    const typing = tag === "textarea" || tag === "input" || tag === "select" || (ae && ae.isContentEditable);
    if (typing) return;

    e.preventDefault();
    if (isPlaying) stopPlayback();
    else playGenerated();
  });

  el("btnPickFolder").addEventListener("click", loadReferenceFolder);

  el("btnRegenerate").addEventListener("click", () => {
    try{
      const g = generateMidiFromProgression(el("prog").value);
      // Si la carpeta está cargada, mantenemos el estado "Listo" aunque la progresión tenga un error.
      if (!folderLoaded) setReady(true, "Listo");
      else setReady(true, "Listo");
      ppqText.textContent = g.ppq ?? "—";
    } catch(err){
      log(String(err?.message || err), "ERROR");
      if (!folderLoaded) setReady(false, "No listo");
      else setReady(true, "Listo");
    }
  });

  el("btnPlay").addEventListener("click", playGenerated);
  el("btnStop").addEventListener("click", () => { stopPlayback(); });

  el("btnClean").addEventListener("click", cleanGenerated);
  el("btnExport").addEventListener("click", exportGenerated);

  // quality chips (dinámicos desde la carpeta)
  const chips = el("qualityChips");

  function insertAtCursor(textarea, txt) {
    textarea.focus();
    const start = textarea.selectionStart ?? textarea.value.length;
    const end = textarea.selectionEnd ?? textarea.value.length;
    const before = textarea.value.slice(0, start);
    const after = textarea.value.slice(end);

    // SIN espacio previo: "C" + click "maj7" => "Cmaj7"
    const needsSpaceAfter = after.length && !/^\s/.test(after);
    const insert = txt + (needsSpaceAfter ? " " : "");

    textarea.value = before + insert + after;
    const pos = (before + insert).length;
    textarea.selectionStart = textarea.selectionEnd = pos;
  }

  function renderQualityChips() {
    chips.innerHTML = "";
    if (!QUALITIES.length) {
      const s = document.createElement("span");
      s.className = "mini";
      s.textContent = "Carga una carpeta para ver las calidades disponibles.";
      chips.appendChild(s);
      return;
    }

    for (const q of QUALITIES) {
      const b = document.createElement("span");
      b.className = "pill";
      b.textContent = q;
      b.title = "Clic: insertar la calidad exacta en el cuadro de progresión";
      b.addEventListener("click", () => {
        insertAtCursor(el("prog"), q);
      });
      chips.appendChild(b);
    }
  }

  renderQualityChips(); // estado inicial

  // Initial defaults
  el("prog").value = ``;
  getRepeatTimes();

  setReady(false, "No listo");
  // init displayed values
  tempoVal.textContent = tempo.value;
  // swing desactivado
  bassVelVal.textContent = bassVel.value;
  updateDensityLabel();
  setAdvancedControlsEnabled(!soloing?.checked);

  initMIDI();
})();
</script>
</body>
</html>