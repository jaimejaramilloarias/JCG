<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jazz Comping Generator - Jaime Jaramillo Arias</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' x2='1' y1='1' y2='0'%3E%3Cstop stop-color='%2338bdf8'/%3E%3Cstop offset='.6' stop-color='%23a78bfa'/%3E%3Cstop offset='1' stop-color='%23fbbf24'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='64' height='64' rx='14' fill='%23121826'/%3E%3Cpath d='M18 46c5-4 9-9 14-18 4 8 9 13 14 17' fill='none' stroke='url(%23g)' stroke-width='6' stroke-linecap='round'/%3E%3Ccircle cx='18' cy='46' r='4' fill='%2338bdf8'/%3E%3Ccircle cx='32' cy='28' r='4' fill='%23a78bfa'/%3E%3Ccircle cx='46' cy='45' r='4' fill='%23fbbf24'/%3E%3C/svg%3E" />
  <style>
    :root{
      --bg:#0a0f1c;
      --panel:#0d1526;
      --panel2:#111f38;
      --txt:#e8edf7;
      --muted:#9bb1c9;
      --line:#1f2e46;
      --accent:#22d3ee;
      --accent2:#f97316;
      --accent3:#a855f7;
      --bad:#fb7185;
      --ok:#22c55e;
      --shadow: 0 12px 28px rgba(4,6,12,.32);
      --glow: 0 0 0 1px rgba(34,211,238,.26), 0 16px 30px rgba(0,0,0,.48);
      --frost: blur(18px);
      --r:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:'Inter', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1100px 620px at 12% 12%, rgba(29,212,242,.14), transparent 55%),
                  radial-gradient(1200px 760px at 88% 8%, rgba(245,158,11,.12), transparent 58%),
                  linear-gradient(145deg, #070c16 0%, #0d1323 48%, #070c16 100%);
      color:var(--txt);
      position:relative;
      min-height:100%;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      background: radial-gradient(720px 460px at 28% 78%, rgba(29,212,242,.10), transparent 60%), radial-gradient(660px 400px at 76% 80%, rgba(245,158,11,.12), transparent 60%);
      pointer-events:none;
      opacity:.85;
    }
    .wrap{
      max-width:1120px; margin:16px auto 28px; padding:0 14px 28px;
    }
    header{
      display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:16px; flex-wrap:wrap;
    }
    header.hero{padding:14px; border:1px solid rgba(255,255,255,.08); background: linear-gradient(135deg, rgba(255,255,255,.10), rgba(255,255,255,.02)); box-shadow: var(--glow); backdrop-filter: var(--frost); border-radius:16px;}
    .brand{display:flex; flex-direction:column; gap:6px;}
    .eyebrow{margin:0; font-size:11px; letter-spacing:.4px; text-transform:uppercase; color:rgba(255,255,255,.68); font-weight:800;}
    h1{margin:0; font-size:28px; letter-spacing:.1px; font-weight:800; color:#f8fafc; text-shadow:0 14px 40px rgba(0,0,0,.35); font-family:'Space Grotesk', 'Inter', system-ui, -apple-system, sans-serif;}
    .sub{color:var(--muted); font-size:12px; margin-top:2px; line-height:1.5;}
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
      backdrop-filter: var(--frost);
    }
    .megaCard{padding:6px 6px 12px; border:1px solid rgba(255,255,255,.06); box-shadow: var(--glow);}
    .megaHd{border-bottom:1px solid rgba(35,50,74,.7); background: linear-gradient(135deg, rgba(24,34,56,.9), rgba(18,30,56,.75)); padding:8px 12px; display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .megaHd .title{font-size:13px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted);}
    .megaHd .mini{color:rgba(255,255,255,.82); font-size:12px;}
    .megaBd{display:flex; flex-direction:column; gap:10px; padding:10px;}
    .heroMeta{display:flex; align-items:center; gap:14px; flex-wrap:wrap; justify-content:flex-end;}
    .controlBar{display:grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap:10px; align-items:stretch;}
    .controlCluster{border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px 12px; background: linear-gradient(180deg, rgba(18,30,54,.94), rgba(10,18,34,.96)); display:flex; flex-direction:column; gap:8px; box-shadow: 0 10px 22px rgba(0,0,0,.32); position:relative; overflow:hidden;}
    .controlCluster::before{content:""; position:absolute; inset:0; background: linear-gradient(135deg, rgba(34,211,238,.14), rgba(168,85,247,.08) 45%, transparent 70%); opacity:.9; pointer-events:none;}
    .controlCluster > *{position:relative;}
    .clusterTitle{font-size:11px; color:var(--muted); letter-spacing:.4px; text-transform:uppercase; font-weight:800;}
    .clusterActions{display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
    .miniStat{font-size:12px; color:var(--muted); margin-left:auto;}
    .card .hd{
      padding:10px 12px 8px;
      border-bottom:1px solid rgba(35,50,74,.8);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background: linear-gradient(135deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    }
    .card .hd .title{font-size:13px; color:var(--muted); letter-spacing:.4px; text-transform:uppercase; letter-spacing:.32px}
    .card .bd{padding:10px}
    textarea{
      width:100%; min-height:120px; padding:10px 12px;
      border-radius:14px; border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      color:var(--txt); font-size:14px; line-height:1.45;
      outline:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    textarea:focus{border-color: rgba(125,211,252,.6); box-shadow:0 0 0 4px rgba(125,211,252,.12)}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .btn{
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(135deg, rgba(255,255,255,.10), rgba(34,211,238,.12));
      color:var(--txt);
      padding:8px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      letter-spacing:.15px;
      font-size:13px;
      transition: transform .06s ease, border-color .15s ease, background .15s ease, box-shadow .15s ease;
      user-select:none;
      box-shadow: 0 10px 18px rgba(0,0,0,.28);
    }
    .btn:hover{border-color: rgba(34,211,238,.55); background: linear-gradient(135deg, rgba(255,255,255,.16), rgba(34,211,238,.14)); box-shadow: 0 14px 22px rgba(0,0,0,.32)}
    .btn:active{transform: translateY(1px)}
    .btn.primary{border-color: rgba(34,211,238,.85); background: linear-gradient(135deg, rgba(34,211,238,.30), rgba(34,211,238,.12))}
    .btn.purple{border-color: rgba(168,85,247,.7); background: linear-gradient(135deg, rgba(168,85,247,.24), rgba(168,85,247,.10))}
    .btn.bad{border-color: rgba(251,113,133,.65); background: linear-gradient(135deg, rgba(251,113,133,.22), rgba(251,113,133,.08))}
    .btn:disabled{opacity:.45; cursor:not-allowed}
    select,
    input[type="number"]{
      width:100%;
      padding:9px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      color:var(--txt);
      outline:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    select:focus,
    input[type="number"]:focus{border-color: rgba(125,211,252,.6); box-shadow:0 0 0 4px rgba(125,211,252,.12)}
    .label{font-size:11px; color:var(--muted); margin-bottom:6px; display:flex; align-items:center; gap:8px}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(135deg, rgba(255,255,255,.12), rgba(34,211,238,.08));
      color:var(--txt);
      font-size:12px;
      cursor:pointer;
      user-select:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .pill:hover{border-color: rgba(29,212,242,.42)}
    .pill.status{padding:8px 12px; font-weight:700; letter-spacing:.2px; box-shadow:0 10px 18px rgba(0,0,0,.28)}
    .pill small{color:var(--muted); font-weight:600}
    .chips{display:flex; flex-wrap:wrap; gap:8px}
    .split{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    .kpi{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .dot{width:9px; height:9px; border-radius:50%}
    .dot.ok{background:var(--ok)}
    .dot.bad{background:var(--bad)}
    .mono{font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
    .log{
      max-height:260px; overflow:auto; padding:12px 14px;
      border-radius:14px; border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02)); color:var(--muted);
      font-size:12px; line-height:1.35;
      white-space:pre-wrap;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .mini{font-size:12px; color:var(--muted)}
    .inputNumber{width:120px}
    .sectionGrid{display:grid; grid-template-columns: repeat(auto-fit, minmax(260px,1fr)); gap:10px;}
    .sectionCard{border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px 12px; background: linear-gradient(135deg, rgba(25,40,72,.95), rgba(12,24,44,.92)); display:flex; flex-direction:column; gap:8px; box-shadow: 0 10px 24px rgba(0,0,0,.26);}
    .sectionTitle{font-size:11px; color:var(--muted); letter-spacing:.4px; text-transform:uppercase; font-weight:800;}
    .inlineStats{display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-size:12px; color:var(--muted);}
    .pillRow{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .warn{color: #fbbf24}
    .ok{color: var(--ok)}
    .bad{color: var(--bad)}
    .hint{color:var(--muted); font-size:12px; margin-top:10px; line-height:1.35}
    .hint code{color:#c7d2fe}

    .topActions{display:flex; gap:8px; align-items:center}
    .btn.ghost{background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.12)}
    .btn.ghost:hover{background: rgba(255,255,255,.10)}
    .helpBtn{display:inline-flex; align-items:center; gap:8px}
    .helpBtn .q{display:inline-flex; width:18px; height:18px; border-radius:999px; align-items:center; justify-content:center;
      border:1px solid rgba(255,255,255,.18); color: var(--txt); font-weight:800; font-size:12px; background: rgba(255,255,255,.06);
    }
    .chordPreview{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(135deg, rgba(34,211,238,.16), rgba(17,24,39,.7));
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      min-height:56px;
    }
    .savedRow{display:grid; gap:8px; grid-template-columns: minmax(140px, 1.1fr) minmax(120px, 0.8fr); align-items:end;}
    .savedRow .btn{width:100%}
    .savedRow select,
    .savedRow input[type="text"]{width:100%}
    .savedMeta{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
    input[type="text"]{
      width:100%;
      padding:9px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      color:var(--txt);
      outline:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    input[type="text"]:focus{border-color: rgba(125,211,252,.6); box-shadow:0 0 0 4px rgba(125,211,252,.12)}
    .badge{
      font-size:11px;
      font-weight:700;
      color:#0b1220;
      background: linear-gradient(135deg, rgba(34,211,238,.9), rgba(168,85,247,.85));
      padding:4px 8px;
      border-radius:999px;
    }
    .barRow{display:flex; flex-wrap:wrap; align-items:center; gap:6px}
    .barSep{color:var(--muted); font-weight:700; letter-spacing:.4px}
    .chordToken{
      padding:6px 10px;
      border-radius:10px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.14);
      font-size:12px;
      font-weight:700;
      letter-spacing:.2px;
      color:#f8fafc;
    }
    .chordToken.bad{
      background: linear-gradient(135deg, rgba(251,113,133,.95), rgba(249,115,22,.85));
      border-color: rgba(251,113,133,.9);
      color:#0b0f1c;
      box-shadow: 0 0 0 1px rgba(251,113,133,.4), 0 8px 18px rgba(251,113,133,.35);
    }
    .previewEmpty,
    .previewError{
      color:var(--muted);
      font-size:12px;
    }

    /* Modal */
    .modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; padding:18px; background: rgba(0,0,0,.35); z-index:9999;}
    .modal.open{display:flex}
    .modalCard{
      width:min(860px, 100%);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      box-shadow: 0 18px 44px rgba(0,0,0,.30);
      overflow:hidden;
    }
    .modalHd{padding:14px 14px 10px; border-bottom:1px solid rgba(255,255,255,.12); display:flex; justify-content:space-between; align-items:center; gap:12px}
    .modalHd h2{margin:0; font-size:14px; letter-spacing:.3px}
    .modalBd{padding:14px}
    .modalBd p{margin:0 0 10px; color: var(--muted); font-size:13px; line-height:1.45}
    .modalBd ul{margin:8px 0 14px 18px; color: var(--muted); font-size:13px; line-height:1.45}
    .kbd{font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace; padding:2px 6px; border-radius:8px;
      border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06); color: var(--txt); font-size:12px;
    }

    @media (max-width: 980px){
      .controlBar{grid-template-columns: 1fr;}
    }

    /* Modal: solid (no translucency) */
    .modalCard{background: var(--panel) !important;}

    /* Theme toggle */
    html[data-theme="dark"]{
      --bg:#0a0f1c;
      --panel:#0f1628;
      --panel2:#12213c;
      --txt:#e8edf7;
      --muted:#9bb1c9;
      --line:#1f2e46;
      --accent:#1dd4f2;
      --accent2:#f59e0b;
      --bad:#f87171;
      --ok:#22c55e;
      --shadow: 0 14px 28px rgba(0,0,0,.32);
    }
    html[data-theme="light"]{
      --bg:#f3f6fb;
      --panel:#ffffff;
      --panel2:#f3f7fd;
      --txt:#0d1323;
      --muted:#4a5c76;
      --line:#d5deeb;
      --accent:#0891b2;
      --accent2:#c26d00;
      --bad:#e64967;
      --ok:#17804f;
      --shadow: 0 10px 24px rgba(12,18,40,.12);
      --glow: 0 0 0 1px rgba(12,145,178,.22), 0 16px 28px rgba(12,18,40,.16);
      --frost: blur(14px);
    }
    html[data-theme="light"] body{
      background: radial-gradient(900px 520px at 18% 12%, rgba(12,145,178,.12), transparent 60%),
                  radial-gradient(900px 520px at 82% 18%, rgba(194,109,0,.10), transparent 60%),
                  var(--bg);
      color:var(--txt);
    }
    html[data-theme="light"] textarea,
    html[data-theme="light"] select,
    html[data-theme="light"] input[type="number"],
    html[data-theme="light"] input[type="text"]{
      background: rgba(18,24,38,.04);
      color: var(--txt);
      border-color: var(--line);
    }
    html[data-theme="light"] .btn{
      background: rgba(18,24,38,.04);
      color: var(--txt);
      border-color: var(--line);
    }
    html[data-theme="light"] .btn:hover{
      background: rgba(18,24,38,.07);
      border-color: rgba(14,165,233,.35);
    }
    html[data-theme="light"] .pill{
      background: rgba(18,24,38,.04);
      border-color: var(--line);
      color: var(--txt);
    }

  </style>
</head>
<body>
<div class="wrap">
  <header class="hero card">
    <div class="brand">
      <h1>Jazz Comping Generator - Jaime Jaramillo Arias</h1>
      <div class="sub">Escribe una progresión, controla tus referencias de audio y genera playback desde archivos WAV.</div>
    </div>
    <div class="heroMeta">
      <div class="kpi">
        <div class="pill status" title="Estado de carga de referencias de audio">
          <span class="dot bad" id="dotReady"></span>
          <span id="readyText">No listo</span>
        </div>
      </div>
      <div class="topActions">
        <button class="btn ghost helpBtn" id="btnHelp" title="Abrir ayuda">
          <span class="q">?</span><span>Ayuda</span>
        </button>
        <button class="btn ghost" id="btnTheme" title="Cambiar modo claro/oscuro">Modo</button>
      </div>
    </div>
  </header>

  <div class="card megaCard">
    <div class="hd megaHd">
      <div class="title">Panel principal</div>
    </div>
    <div class="megaBd">
      <div class="controlBar">
        <div class="controlCluster">
          <div class="clusterTitle">Reproducción y export</div>
          <div class="clusterActions">
            <button class="btn primary" id="btnPlay" title="Reproducir la progresión usando tus referencias de audio">Reproducir</button>
            <button class="btn bad" id="btnStop" title="Detener reproducción">Stop</button>
            <button class="btn purple" id="btnExportAudio" title="Exportar el audio generado">Exportar audio</button>
          </div>
        </div>

        <div class="controlCluster">
          <div class="clusterTitle">Carpeta de audio</div>
          <div class="clusterActions">
            <button class="btn" id="btnPickAudioFolder" title="Cargar carpeta con archivos WAV de referencia">Cargar carpeta</button>
            <input id="audioFolderFallback" type="file" webkitdirectory multiple style="display:none" />
          </div>
          <div class="mini" id="audioFolderStatus" style="margin-top:8px">Sin carpeta cargada.</div>
        </div>

        <div class="controlCluster">
          <div class="clusterTitle">Ajustes de referencia</div>
          <div class="split">
            <div>
              <div class="label">Compases por archivo</div>
              <input id="barsPerFile" type="number" min="1" max="256" value="24" />
            </div>
            <div>
              <div class="label">Compases por acorde</div>
              <input id="barsPerChord" type="number" min="1" max="64" value="2" />
            </div>
            <div>
              <div class="label">Signatura de medida</div>
              <select id="timeSignature">
                <option value="2/4">2/4</option>
                <option value="3/4">3/4</option>
                <option value="4/4" selected>4/4</option>
                <option value="5/4">5/4</option>
                <option value="6/8">6/8</option>
                <option value="7/8">7/8</option>
              </select>
            </div>
            <div>
              <div class="label">BPM fijo referencias</div>
              <input id="refBpm" type="number" min="20" max="300" value="90" />
            </div>
            <div>
              <div class="label">Crossfade (ms)</div>
              <input id="crossfadeMs" type="number" min="0" max="2000" value="20" />
            </div>
            <div>
              <div class="label">Fundamental inicial</div>
              <select id="startRoot">
                <option value="A">A</option>
                <option value="A#">A#</option>
                <option value="B">B</option>
                <option value="C">C</option>
                <option value="C#">C#</option>
                <option value="D">D</option>
                <option value="D#">D#</option>
                <option value="E">E</option>
                <option value="F">F</option>
                <option value="F#">F#</option>
                <option value="G">G</option>
                <option value="G#">G#</option>
              </select>
            </div>
            <div>
              <div class="label">Repeticiones</div>
              <input id="repeatCount" type="number" min="1" max="64" value="1" class="inputNumber" title="Número de veces que se repetirá la progresión" />
            </div>
            <div>
              <div class="label">Transposición</div>
              <input id="globalTranspose" type="number" min="-24" max="24" value="0" class="inputNumber" title="Sube o baja las fundamentales del cifrado por semitonos" />
            </div>
          </div>
        </div>
      </div>

      <div class="sectionGrid">
        <div class="sectionCard">
          <div class="sectionTitle">Progresión y calidades</div>
          <div class="label">Progresión</div>
          <textarea id="prog" spellcheck="false" title="Escribe la progresión usando barras: | Cmaj7 | o | Dm7 G7 |" placeholder="Escribe una progresión con barras. Ej: | Cmaj7 | o | Dm7 G7 |" ></textarea>
          <div class="label" style="margin-top:8px">Guardar progresiones</div>
          <div class="savedRow">
            <div>
              <div class="label">Nombre de progresión</div>
              <input id="progName" type="text" placeholder="Ej: Blues en F, Turnaround" />
            </div>
            <div>
              <button class="btn primary" id="btnSaveProg" title="Guardar la progresión actual">Guardar</button>
            </div>
          </div>
          <div class="savedRow">
            <div>
              <div class="label">Progresiones guardadas</div>
              <select id="savedProgSelect"></select>
            </div>
            <div class="row" style="gap:8px">
              <button class="btn" id="btnLoadProg" title="Cargar la progresión seleccionada">Cargar</button>
              <button class="btn ghost" id="btnExportProgs" title="Exportar todas las progresiones guardadas">Exportar</button>
            </div>
          </div>
          <div class="savedMeta">
            <span class="badge" id="savedCount">0 guardadas</span>
            <button class="btn ghost" id="btnImportProgs" title="Importar progresiones guardadas">Importar</button>
            <input id="importProgFile" type="file" accept=".json,application/json" style="display:none" />
          </div>
          <div class="label" style="margin-top:8px">Vista rápida del cifrado</div>
          <div class="chordPreview" id="progPreview"></div>
          <div class="label">Cifrados disponibles (calidades) <span class="mini">(clic para insertar)</span></div>
          <div class="chips" id="qualityChips"></div>
          <div class="pillRow" style="margin-top:8px">
            <div class="pill status" id="qualityMismatch" title="Estado de coincidencia de calidades">
              <span class="dot bad" id="qualityMismatchDot"></span>
              <span id="qualityMismatchText">Carga referencias de audio para validar calidades.</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>


<div class="modal" id="helpModal" aria-hidden="true">
  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modalHd">
      <h2 id="helpTitle">Ayuda</h2>
      <div class="row">
        <button class="btn" id="btnHelpClose" title="Cerrar ayuda">Cerrar</button>
      </div>
    </div>
    <div class="modalBd">
      <p><b>Manual rápido</b></p>
      <ul>
        <li><b>1) Cargar referencias:</b> pulsa <span class="kbd">Cargar carpeta</span> y elige la carpeta con tus WAVs.</li>
        <li><b>2) Ajustes:</b> define compases por archivo, compases por acorde, BPM fijo, crossfades y fundamental inicial.</li>
        <li><b>3) Progresión:</b> escribe con barras. Ej: <span class="kbd">| Dm7 G7 | Cmaj7 |</span>.</li>
        <li><b>4) Calidades:</b> revisa el indicador de coincidencias para ver si falta algún acorde.</li>
        <li><b>5) Guardar:</b> usa <span class="kbd">Guardar</span> para guardar y <span class="kbd">Exportar</span> para llevarte todas.</li>
        <li><b>6) Escuchar:</b> pulsa <span class="kbd">Reproducir</span>. Usa <span class="kbd">Stop</span> para detener.</li>
        <li><b>7) Exportar:</b> guarda el audio con <span class="kbd">Exportar audio</span>.</li>
      </ul>
      <p class="mini">Atajo: <span class="kbd">Espacio</span> alterna Reproducir / Stop (cuando no estás escribiendo).</p>

    </div>
  </div>
</div>

<script>
(() => {
  const el = (id) => document.getElementById(id);
  const logEl = el("log");
  const readyText = el("readyText");
  const dotReady = el("dotReady");
  const audioFolderStatus = el("audioFolderStatus");
  const qualityChips = el("qualityChips");
  const qualityMismatchText = el("qualityMismatchText");
  const qualityMismatchDot = el("qualityMismatchDot");
  const progPreview = el("progPreview");

  const prog = el("prog");
  const progName = el("progName");
  const savedProgSelect = el("savedProgSelect");
  const btnSaveProg = el("btnSaveProg");
  const btnLoadProg = el("btnLoadProg");
  const btnExportProgs = el("btnExportProgs");
  const btnImportProgs = el("btnImportProgs");
  const importProgFile = el("importProgFile");
  const savedCount = el("savedCount");
  const repeatCount = el("repeatCount");
  const globalTranspose = el("globalTranspose");
  const barsPerFileInput = el("barsPerFile");
  const barsPerChordInput = el("barsPerChord");
  const timeSignatureInput = el("timeSignature");
  const refBpmInput = el("refBpm");
  const crossfadeMsInput = el("crossfadeMs");
  const startRootInput = el("startRoot");

  const NOTE_TO_SEMI = new Map([
    ["C",0], ["B#",0],
    ["C#",1], ["DB",1],
    ["D",2],
    ["D#",3], ["EB",3],
    ["E",4], ["FB",4],
    ["F",5], ["E#",5],
    ["F#",6], ["GB",6],
    ["G",7],
    ["G#",8], ["AB",8],
    ["A",9],
    ["A#",10], ["BB",10],
    ["B",11], ["CB",11]
  ]);
  const SEMI_TO_NOTE_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const SEMI_TO_NOTE_FLAT = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];

  let audioCtx = null;
  let audioBuffersByQuality = new Map();
  let audioUrlsByQuality = new Map();
  let audioQualities = [];
  let audioFolderLoaded = false;
  let isAudioPlaying = false;
  let audioNodes = [];
  let audioTimers = [];
  let currentGlobalTranspose = 0;
  const PLAYBACK_SCHEDULE_AHEAD_SEC = 0.08;
  const RELEASE_TAIL_SEC = 0.05;
  const MIN_FADE_SEC = 0.005;
  const FADE_CURVE_SAMPLES = 128;
  const STORAGE_KEY = "jcg_saved_progressions";

  const buildEqualPowerCurve = (samples, fadeIn = true) => {
    const curve = new Float32Array(samples);
    for (let i = 0; i < samples; i += 1) {
      const t = i / (samples - 1);
      curve[i] = fadeIn ? Math.sin(t * Math.PI * 0.5) : Math.cos(t * Math.PI * 0.5);
    }
    return curve;
  };
  const FADE_IN_CURVE = buildEqualPowerCurve(FADE_CURVE_SAMPLES, true);
  const FADE_OUT_CURVE = buildEqualPowerCurve(FADE_CURVE_SAMPLES, false);

  const log = (msg, level = "INFO") => {
    const prefix = level === "ERROR" ? "❌" : level === "WARN" ? "⚠️" : "✅";
    const stamp = new Date().toLocaleTimeString();
    if (!logEl) {
      const method = level === "ERROR" ? "error" : level === "WARN" ? "warn" : "log";
      console[method](`[${stamp}] ${prefix} ${msg}`);
      return;
    }
    logEl.textContent += `[${stamp}] ${prefix} ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  };

  const readSavedProgressions = () => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return [];
      return parsed.filter((item) => item && typeof item.name === "string" && typeof item.text === "string");
    } catch (_) {
      return [];
    }
  };

  const writeSavedProgressions = (list) => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(list));
    } catch (err) {
      log(`No pude guardar progresiones: ${String(err?.message || err)}`, "ERROR");
    }
  };

  const renderSavedProgressions = (list, selectedName = "") => {
    if (!savedProgSelect) return;
    savedProgSelect.innerHTML = "";
    if (!list.length) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "Sin progresiones guardadas";
      savedProgSelect.appendChild(opt);
      savedProgSelect.disabled = true;
      if (btnLoadProg) btnLoadProg.disabled = true;
      if (btnExportProgs) btnExportProgs.disabled = true;
    } else {
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "Selecciona una progresión";
      savedProgSelect.appendChild(placeholder);
      for (const item of list) {
        const opt = document.createElement("option");
        opt.value = item.name;
        opt.textContent = item.name;
        savedProgSelect.appendChild(opt);
      }
      savedProgSelect.disabled = false;
      if (btnLoadProg) btnLoadProg.disabled = false;
      if (btnExportProgs) btnExportProgs.disabled = false;
      if (selectedName) savedProgSelect.value = selectedName;
    }
    if (savedCount) {
      savedCount.textContent = `${list.length} guardada${list.length === 1 ? "" : "s"}`;
    }
  };

  const getSavedProgressions = () => readSavedProgressions().sort((a, b) => a.name.localeCompare(b.name, "es"));

  const saveCurrentProgression = () => {
    const name = (progName?.value || "").trim();
    const text = (prog?.value || "").trim();
    if (!name) {
      log("Escribe un nombre para guardar la progresión.", "WARN");
      return;
    }
    if (!text) {
      log("Escribe una progresión antes de guardar.", "WARN");
      return;
    }
    const list = getSavedProgressions();
    const existingIndex = list.findIndex((item) => item.name.toLowerCase() === name.toLowerCase());
    const payload = { name, text, updatedAt: new Date().toISOString() };
    if (existingIndex >= 0) {
      list[existingIndex] = payload;
    } else {
      list.push(payload);
    }
    writeSavedProgressions(list);
    renderSavedProgressions(list, name);
    log(`Progresión "${name}" guardada.`, "OK");
  };

  const loadSelectedProgression = () => {
    const name = savedProgSelect?.value || "";
    if (!name) {
      log("Selecciona una progresión guardada.", "WARN");
      return;
    }
    const list = getSavedProgressions();
    const item = list.find((p) => p.name === name);
    if (!item) {
      log("No encontré esa progresión.", "WARN");
      return;
    }
    prog.value = item.text;
    if (progName) progName.value = item.name;
    updateQualityMismatch();
    log(`Progresión "${item.name}" cargada.`, "OK");
  };

  const exportProgressions = () => {
    const list = getSavedProgressions();
    if (!list.length) {
      log("No hay progresiones guardadas para exportar.", "WARN");
      return;
    }
    const blob = new Blob([JSON.stringify(list, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement("a");
    anchor.href = url;
    anchor.download = "progresiones_guardadas.json";
    document.body.appendChild(anchor);
    anchor.click();
    anchor.remove();
    URL.revokeObjectURL(url);
    log("Exportadas progresiones guardadas.", "OK");
  };

  const importProgressions = async (file) => {
    if (!file) return;
    try {
      const text = await file.text();
      const incoming = JSON.parse(text);
      if (!Array.isArray(incoming)) throw new Error("El archivo no tiene formato válido.");
      const sanitized = incoming
        .filter((item) => item && typeof item.name === "string" && typeof item.text === "string")
        .map((item) => ({ name: item.name.trim(), text: item.text.trim() }))
        .filter((item) => item.name && item.text);
      if (!sanitized.length) {
        log("No encontré progresiones válidas en el archivo.", "WARN");
        return;
      }
      const list = getSavedProgressions();
      const map = new Map(list.map((item) => [item.name.toLowerCase(), item]));
      for (const item of sanitized) {
        map.set(item.name.toLowerCase(), { ...item, updatedAt: new Date().toISOString() });
      }
      const merged = [...map.values()].sort((a, b) => a.name.localeCompare(b.name, "es"));
      writeSavedProgressions(merged);
      renderSavedProgressions(merged);
      log(`Importadas ${sanitized.length} progresiones.`, "OK");
    } catch (err) {
      log(`No pude importar: ${String(err?.message || err)}`, "ERROR");
    }
  };

  const clearLog = () => {
    if (logEl) logEl.textContent = "";
  };

  const setReady = (ready, text) => {
    if (ready) {
      dotReady.classList.remove("bad");
      dotReady.classList.add("ok");
    } else {
      dotReady.classList.remove("ok");
      dotReady.classList.add("bad");
    }
    readyText.textContent = text;
  };

  const normalizeAccidentals = (s) => s.replaceAll("♭","b").replaceAll("♯","#");

  const normalizeQuality = (q) => {
    let s = (q || "").trim();
    s = normalizeAccidentals(s);
    return s || null;
  };

  const parseChordToken = (tokRaw) => {
    const tok = normalizeAccidentals(tokRaw.trim());
    const m = tok.match(/^([A-Ga-g])([#b]?)(.*)$/);
    if (!m) throw new Error(`No entiendo el acorde: "${tokRaw}"`);
    const root = (m[1].toUpperCase() + (m[2]||"")).toUpperCase();
    const qualRaw = (m[3]||"").trim();
    const qualKey = normalizeQuality(qualRaw);
    if (!qualKey) throw new Error(`Calidad faltante en "${tokRaw}". Ej: Dm7, G9, A7alt, Cmaj7.`);
    const rootSemi = NOTE_TO_SEMI.get(root.toUpperCase());
    if (rootSemi === undefined) throw new Error(`Fundamental inválida: "${root}"`);
    return { root, rootSemi, quality: qualKey, token: tokRaw };
  };

  const getTimeSignature = () => {
    const raw = timeSignatureInput.value || "4/4";
    const [numRaw, denRaw] = raw.split("/");
    const num = Math.max(1, parseInt(numRaw, 10) || 4);
    const den = Math.max(1, parseInt(denRaw, 10) || 4);
    return { num, den };
  };

  const getEighthsPerBar = () => {
    const { num, den } = getTimeSignature();
    const eighths = Math.round((num * 8) / den);
    return Math.max(1, eighths);
  };

  const durationsForBar = (chordCount, eighthsPerBar) => {
    if (eighthsPerBar === 8) {
      if (chordCount === 1) return [8];
      if (chordCount === 2) return [4, 4];
      if (chordCount === 3) return [4, 2, 2];
      return [2, 2, 2, 2];
    }
    const base = Math.floor(eighthsPerBar / chordCount);
    let remainder = eighthsPerBar % chordCount;
    return Array.from({ length: chordCount }, () => {
      const extra = remainder > 0 ? 1 : 0;
      remainder = Math.max(0, remainder - 1);
      return base + extra;
    });
  };

  const parseProgression = (text, opts = {}) => {
    const { maxChordsPerBar = 4 } = opts;
    const raw = text.replace(/\r/g, "").trim();
    if (!raw) throw new Error("Escribe una progresión.");
    const parts = raw.split("|").map((s) => s.trim()).filter(Boolean);
    if (!parts.length) throw new Error("Usa barras | |. Ej: | Bbmaj7 Gm9 | ...");

    const segments = [];
    let startEighth = 0;
    let lastBarChords = null;
    const eighthsPerBar = getEighthsPerBar();

    const addBar = (barChords, source = "", barIndex = 0) => {
      if (!barChords || !barChords.length) {
        throw new Error(`Barra inválida: "${source || ""}". Solo 1 a ${maxChordsPerBar} acordes por compás.`);
      }
      if (barChords.length < 1 || barChords.length > maxChordsPerBar) {
        throw new Error(`Barra inválida: "${source || barChords.join(" ")}". Solo 1 a ${maxChordsPerBar} acordes por compás.`);
      }

      const chordCount = barChords.length;
      const durations = durationsForBar(chordCount, eighthsPerBar);
      const stored = [];

      for (const [idx, c] of barChords.entries()) {
        const parsed = parseChordToken(c);
        segments.push({
          ...parsed,
          startEighth,
          durEighth: durations[idx],
          barIndex,
          barChordCount: chordCount,
          barChordIndex: idx,
          windowFromStart: chordCount === 4 || (chordCount === 3 && idx > 0),
        });
        startEighth += durations[idx];
        stored.push(c);
      }

      lastBarChords = stored;
    };

    for (const [barIndex, bar] of parts.entries()) {
      if (bar === "%") {
        if (!lastBarChords) throw new Error("El signo % solo se puede usar después del primer compás.");
        addBar(lastBarChords, bar, barIndex);
        continue;
      }
      const chords = bar.split(/\s+/).map((s) => s.trim()).filter(Boolean);
      addBar(chords, bar, barIndex);
    }

    const totalEighth = parts.length * eighthsPerBar;
    if (segments.length >= 2) {
      for (let i = 0; i < segments.length - 1; i++) {
        segments[i].durEighth = segments[i + 1].startEighth - segments[i].startEighth;
      }
      segments[segments.length - 1].durEighth = totalEighth - segments[segments.length - 1].startEighth;
      for (const s of segments) {
        s.durEighth = Math.max(1, s.durEighth);
      }
    }

    return { segments, totalEighth, totalBars: parts.length };
  };

  const repeatSegments = (segments, totalEighth, times) => {
    const t = Math.max(1, parseInt(times, 10) || 1);
    if (t === 1) return { segments, totalEighth };
    const out = [];
    for (let i = 0; i < t; i++) {
      const offset = i * totalEighth;
      for (const s of segments) {
        out.push({ ...s, startEighth: s.startEighth + offset });
      }
    }
    return { segments: out, totalEighth: totalEighth * t };
  };

  const getBarsPerFile = () => Math.max(1, parseInt(barsPerFileInput.value, 10) || 1);
  const getBarsPerChord = () => Math.max(1, parseInt(barsPerChordInput.value, 10) || 1);
  const getRefBpm = () => Math.max(20, parseInt(refBpmInput.value, 10) || 90);
  const getCrossfadeSeconds = () => Math.max(0, parseInt(crossfadeMsInput.value, 10) || 0) / 1000;

  const buildRootBarStartMap = () => {
    const map = new Map();
    const startRoot = (startRootInput.value || "A").toUpperCase();
    const startSemi = NOTE_TO_SEMI.get(startRoot);
    if (startSemi == null) return map;
    const barsPerChord = getBarsPerChord();
    for (let i = 0; i < 12; i++) {
      const rootSemi = (startSemi + i) % 12;
      map.set(rootSemi, i * barsPerChord);
    }
    return map;
  };

  const getBarSeconds = () => {
    const { num, den } = getTimeSignature();
    const bpm = getRefBpm();
    return (60 / bpm) * num * (4 / den);
  };

  const getSecondsPerEighth = () => {
    const bpm = getRefBpm();
    return (60 / bpm) / 2;
  };

  const transposeRootLabel = (root, delta, preferFlat = false) => {
    const baseSemi = NOTE_TO_SEMI.get(root.toUpperCase());
    if (baseSemi == null) return root;
    const target = ((baseSemi + delta) % 12 + 12) % 12;
    const dict = preferFlat ? SEMI_TO_NOTE_FLAT : SEMI_TO_NOTE_SHARP;
    return dict[target] ?? root;
  };

  const transposeChordTokenText = (tok, delta) => {
    if (!delta) return tok;
    const normalized = normalizeAccidentals(tok.trim());
    const m = normalized.match(/^([A-Ga-g])([#b]?)(.*)$/);
    if (!m) return tok;
    const rootKey = (m[1].toUpperCase() + (m[2] || "" )).toUpperCase();
    const preferFlat = m[2] === "b" || m[2] === "♭";
    if (!NOTE_TO_SEMI.has(rootKey)) return tok;
    const rest = m[3] || "";
    const newRoot = transposeRootLabel(rootKey, delta, preferFlat);
    return newRoot + rest;
  };

  const transposeProgressionText = (text, delta) => {
    if (!delta) return text;
    const bars = text.replace(/\r/g, "").split("|");
    const mapped = bars.map((bar) => {
      const trimmed = bar.trim();
      if (!trimmed) return "";
      const tokens = trimmed.split(/\s+/).filter(Boolean).map((tok) => tok === "%" ? tok : transposeChordTokenText(tok, delta));
      return tokens.length ? ` ${tokens.join(" ")} ` : "";
    });
    return mapped.join("|");
  };

  const clampGlobalTranspose = () => {
    let n = parseInt(globalTranspose.value, 10);
    if (!Number.isFinite(n)) n = 0;
    n = Math.max(-24, Math.min(24, n));
    globalTranspose.value = String(n);
    return n;
  };

  const applyGlobalTranspose = () => {
    const desired = clampGlobalTranspose();
    const delta = desired - currentGlobalTranspose;
    if (delta === 0) return;
    prog.value = transposeProgressionText(prog.value, delta);
    currentGlobalTranspose = desired;
    updateQualityMismatch();
  };

  const insertAtCursor = (input, text) => {
    const start = input.selectionStart || 0;
    const end = input.selectionEnd || 0;
    const value = input.value;
    input.value = value.slice(0, start) + text + value.slice(end);
    const pos = start + text.length;
    input.selectionStart = input.selectionEnd = pos;
    input.focus();
  };

  const renderQualityChips = () => {
    qualityChips.innerHTML = "";
    if (!audioQualities.length) {
      const s = document.createElement("span");
      s.className = "mini";
      s.textContent = "Carga una carpeta de audio para ver las calidades disponibles.";
      qualityChips.appendChild(s);
      return;
    }
    for (const q of audioQualities) {
      const chip = document.createElement("button");
      chip.type = "button";
      chip.className = "pill";
      chip.textContent = q;
      chip.title = "Insertar calidad";
      chip.addEventListener("click", () => insertAtCursor(prog, q));
      qualityChips.appendChild(chip);
    }
  };

  const renderProgressionPreview = (parsed, parseError, missingSet) => {
    if (!progPreview) return;
    progPreview.innerHTML = "";
    const raw = prog.value.trim();
    if (!raw) {
      const empty = document.createElement("span");
      empty.className = "previewEmpty";
      empty.textContent = "Escribe una progresión para verla aquí.";
      progPreview.appendChild(empty);
      return;
    }
    if (parseError) {
      const errText = document.createElement("span");
      errText.className = "previewError";
      errText.textContent = `Progresión inválida: ${String(parseError?.message || parseError)}`;
      progPreview.appendChild(errText);
      return;
    }
    if (!parsed) return;

    const bars = Array.from({ length: parsed.totalBars }, () => []);
    for (const seg of parsed.segments) {
      if (bars[seg.barIndex]) bars[seg.barIndex].push(seg);
    }
    bars.forEach((barSegs) => {
      const barRow = document.createElement("div");
      barRow.className = "barRow";
      const barStart = document.createElement("span");
      barStart.className = "barSep";
      barStart.textContent = "|";
      barRow.appendChild(barStart);

      for (const seg of barSegs) {
        const token = document.createElement("span");
        token.className = "chordToken";
        token.textContent = seg.token || `${seg.root}${seg.quality}`;
        if (missingSet && missingSet.has(seg.quality)) {
          token.classList.add("bad");
        }
        barRow.appendChild(token);
      }

      const barEnd = document.createElement("span");
      barEnd.className = "barSep";
      barEnd.textContent = "|";
      barRow.appendChild(barEnd);
      progPreview.appendChild(barRow);
    });
  };

  const updateQualityMismatch = () => {
    let parsed = null;
    let parseError = null;
    try {
      parsed = parseProgression(prog.value, { maxChordsPerBar: 4 });
    } catch (err) {
      parseError = err;
    }
    if (!audioFolderLoaded || !audioQualities.length) {
      qualityMismatchText.textContent = "Carga referencias de audio para validar calidades.";
      qualityMismatchDot.classList.remove("ok");
      qualityMismatchDot.classList.add("bad");
      renderProgressionPreview(parsed, parseError, null);
      return;
    }

    if (parseError) {
      qualityMismatchText.textContent = `Progresión inválida: ${String(parseError?.message || parseError)}`;
      qualityMismatchDot.classList.remove("ok");
      qualityMismatchDot.classList.add("bad");
      renderProgressionPreview(parsed, parseError, null);
      return;
    }

    try {
      const qualities = new Set(parsed.segments.map((s) => s.quality));
      const missing = [...qualities].filter((q) => !audioQualities.includes(q));
      const missingSet = new Set(missing);
      if (missing.length) {
        qualityMismatchText.textContent = `Faltan referencias para: ${missing.join(", ")}`;
        qualityMismatchDot.classList.remove("ok");
        qualityMismatchDot.classList.add("bad");
      } else {
        qualityMismatchText.textContent = "Todas las calidades están cubiertas por las referencias.";
        qualityMismatchDot.classList.remove("bad");
        qualityMismatchDot.classList.add("ok");
      }
      renderProgressionPreview(parsed, null, missingSet);
    } catch (err) {
      qualityMismatchText.textContent = `Progresión inválida: ${String(err?.message || err)}`;
      qualityMismatchDot.classList.remove("ok");
      qualityMismatchDot.classList.add("bad");
      renderProgressionPreview(parsed, err, null);
    }
  };

  const ensureAudioContext = () => {
    if (!audioCtx) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) throw new Error("AudioContext no disponible en este navegador.");
      const options = { latencyHint: "playback" };
      try {
        audioCtx = new Ctx(options);
      } catch (_) {
        audioCtx = new Ctx();
      }
    }
    return audioCtx;
  };

  const parseAudioFileName = (fullName) => {
    if (!fullName) return null;
    if (!/\.wav$/i.test(fullName)) return null;
    const base = fullName.replace(/\.[^.]+$/, "");
    const qualityKey = normalizeQuality(base);
    if (!qualityKey) return null;
    return qualityKey;
  };

  const loadFolderViaPicker = async () => {
    if (window.showDirectoryPicker) {
      const dir = await window.showDirectoryPicker();
      const collect = async (handle, acc) => {
        for await (const [, child] of handle.entries()) {
          if (child.kind === "file") {
            acc.push(await child.getFile());
          } else if (child.kind === "directory") {
            await collect(child, acc);
          }
        }
      };
      const files = [];
      await collect(dir, files);
      return { name: dir.name || "carpeta", files };
    }

    return await new Promise((resolve, reject) => {
      const input = el("audioFolderFallback");
      input.onchange = () => {
        const list = [...input.files];
        if (!list.length) reject(new Error("No se encontraron archivos en esa carpeta."));
        else resolve({ name: "carpeta", files: list });
      };
      input.click();
    });
  };

  const updateReadyState = () => {
    setReady(!!audioFolderLoaded, audioFolderLoaded ? "Listo" : "No listo");
  };

  const loadAudioFolder = async () => {
    clearLog();
    audioBuffersByQuality.clear();
    for (const url of audioUrlsByQuality.values()) {
      URL.revokeObjectURL(url);
    }
    audioUrlsByQuality.clear();
    audioQualities = [];
    renderQualityChips();

    audioFolderLoaded = false;
    audioFolderStatus.textContent = "Cargando…";
    updateReadyState();

    try {
      const ctx = ensureAudioContext();
      const { name, files } = await loadFolderViaPicker();
      const folderFiles = files;
      const statusLabel = `Carpeta (audio): ${name} — ${folderFiles.length} archivo(s).`;
      audioFolderStatus.textContent = statusLabel;

      const skipped = [];
      const dups = [];

      for (const f of folderFiles) {
        const fullName = (f.name || "").trim();
        if (!fullName) { skipped.push("(sin nombre)"); continue; }
        const qualityKey = parseAudioFileName(fullName);
        if (!qualityKey) { skipped.push(fullName); continue; }
        if (audioBuffersByQuality.has(qualityKey)) {
          dups.push(qualityKey);
          const oldUrl = audioUrlsByQuality.get(qualityKey);
          if (oldUrl) URL.revokeObjectURL(oldUrl);
        }

        try {
          const buf = await f.arrayBuffer();
          const audioBuf = await ctx.decodeAudioData(buf.slice(0));
          audioBuffersByQuality.set(qualityKey, audioBuf);
          const objectUrl = URL.createObjectURL(f);
          audioUrlsByQuality.set(qualityKey, objectUrl);
        } catch (err) {
          skipped.push(fullName);
        }
      }

      audioQualities = [...new Set(audioBuffersByQuality.keys())].sort((a, b) => a.localeCompare(b, "en"));
      renderQualityChips();
      updateQualityMismatch();

      if (!audioQualities.length) {
        log("No encontré WAVs válidos. Revisa nombres y extensiones.", "ERROR");
        audioFolderStatus.textContent = "Sin carpeta cargada.";
        audioFolderLoaded = false;
        updateReadyState();
        return;
      }

      if (skipped.length) {
        log(`Archivos ignorados (no WAV / nombre inválido): ${skipped.join(", ")}`, "WARN");
      }
      if (dups.length) {
        log(`Duplicados: se usó el último WAV para: ${[...new Set(dups)].join(", ")}`, "WARN");
      }

      const expectedSeconds = getBarsPerFile() * getBarSeconds();
      for (const [quality, buffer] of audioBuffersByQuality.entries()) {
        if (buffer.duration + 0.1 < expectedSeconds) {
          log(`"${quality}": duración corta (${buffer.duration.toFixed(2)}s). Esperaba ~${expectedSeconds.toFixed(2)}s.`, "WARN");
        }
      }

      log(`Cargados ${audioQualities.length} WAV(s) de referencia.`, "OK");
      audioFolderLoaded = true;
      updateReadyState();
    } catch (err) {
      audioFolderLoaded = false;
      audioFolderStatus.textContent = "Error al cargar carpeta.";
      log(String(err?.message || err), "ERROR");
      updateReadyState();
    }
  };

  const stopAudioPlayback = () => {
    isAudioPlaying = false;
    for (const t of audioTimers) {
      clearTimeout(t);
    }
    audioTimers = [];
    for (const node of audioNodes) {
      try {
        node.source?.stop();
      } catch (_) {}
      try {
        node.source?.disconnect();
        node.gain?.disconnect();
      } catch (_) {}
    }
    audioNodes = [];
  };

  const scheduleAudioChord = ({ ctx, buffer, startTime, endTime, bufferOffset, trackNodes = true }) => {
    if (!buffer) return;
    const source = ctx.createBufferSource();
    source.buffer = buffer;

    const gain = ctx.createGain();
    gain.gain.value = 0;
    source.connect(gain).connect(ctx.destination);

    const duration = Math.max(0, endTime - startTime);
    const safeOffset = Math.max(0, Math.min(buffer.duration - 0.002, bufferOffset));
    const maxPlayable = Math.max(0, buffer.duration - safeOffset);
    const playDuration = Math.min(duration, maxPlayable);
    if (playDuration <= 0) return;

    const requestedFade = Math.max(MIN_FADE_SEC, getCrossfadeSeconds());
    const maxFade = Math.max(MIN_FADE_SEC, playDuration / 2);
    const fade = Math.min(requestedFade, maxFade);
    const attack = fade;
    const release = fade;
    const effectiveEnd = startTime + playDuration;
    const sustainStart = startTime + attack;
    const releaseStart = Math.max(sustainStart, effectiveEnd - release);

    gain.gain.setValueAtTime(0, startTime);
    if (attack > 0) {
      gain.gain.setValueCurveAtTime(FADE_IN_CURVE, startTime, attack);
    } else {
      gain.gain.setValueAtTime(1, startTime);
    }
    if (effectiveEnd > sustainStart) {
      gain.gain.setValueAtTime(1, releaseStart);
    }
    if (release > 0) {
      gain.gain.setValueCurveAtTime(FADE_OUT_CURVE, releaseStart, release);
    } else {
      gain.gain.setValueAtTime(0, effectiveEnd);
    }

    source.start(startTime, safeOffset, playDuration);
    source.stop(effectiveEnd + release + RELEASE_TAIL_SEC);

    if (trackNodes) {
      audioNodes.push({ source, gain });
    }
  };

  const buildAudioSegments = () => {
    const parsed = parseProgression(prog.value, { maxChordsPerBar: 4 });
    const repeated = repeatSegments(parsed.segments, parsed.totalEighth, parseInt(repeatCount.value, 10) || 1);
    return { segments: repeated.segments, totalEighth: repeated.totalEighth };
  };

  const playAudio = () => {
    if (!audioFolderLoaded || !audioBuffersByQuality.size) {
      log("Carga una carpeta de WAVs para reproducir.", "ERROR");
      return;
    }
    let parsed;
    try {
      parsed = buildAudioSegments();
    } catch (err) {
      log(String(err?.message || err), "ERROR");
      updateQualityMismatch();
      return;
    }

    const segments = parsed.segments;
    if (!segments.length) {
      log("No hay acordes para reproducir.", "ERROR");
      return;
    }

    const rootBarMap = buildRootBarStartMap();
    const barsPerChord = getBarsPerChord();
    const eighthsPerBar = getEighthsPerBar();
    const segmentEighths = eighthsPerBar * barsPerChord;

    for (const seg of segments) {
      if (!audioBuffersByQuality.has(seg.quality)) {
        log(`No tengo WAV para la calidad "${seg.quality}".`, "ERROR");
        return;
      }
      if (!rootBarMap.has(seg.rootSemi)) {
        log(`Fundamental inválida para audio: ${seg.root}.`, "ERROR");
        return;
      }
    }

    stopAudioPlayback();
    isAudioPlaying = true;

    const ctx = ensureAudioContext();
    const secPerEighth = getSecondsPerEighth();
    const barSeconds = getBarSeconds();
    const baseTime = ctx.currentTime + PLAYBACK_SCHEDULE_AHEAD_SEC;

    for (const seg of segments) {
      const buffer = audioBuffersByQuality.get(seg.quality);
      const rootBarStart = rootBarMap.get(seg.rootSemi);
      const offsetEighthInSegment = seg.startEighth % segmentEighths;
      const offsetSeconds = offsetEighthInSegment * secPerEighth;
      const loopStart = rootBarStart * barSeconds;

      const startTime = baseTime + seg.startEighth * secPerEighth;
      const endTime = startTime + seg.durEighth * secPerEighth;
      const startFromBeginning = !!seg.windowFromStart;
      const bufferOffset = startFromBeginning ? loopStart : loopStart + offsetSeconds;

      scheduleAudioChord({
        ctx,
        buffer,
        startTime,
        endTime,
        bufferOffset,
        trackNodes: true,
      });
    }

    const doneTimer = setTimeout(
      () => { isAudioPlaying = false; },
      (parsed.totalEighth * secPerEighth + PLAYBACK_SCHEDULE_AHEAD_SEC + 0.4) * 1000
    );
    audioTimers.push(doneTimer);
    log("Playback iniciado.", "OK");
  };

  const encodeWavFromBuffer = (buffer) => {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const length = buffer.length;
    const bytesPerSample = 4;
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = length * blockAlign;
    const bufferSize = 44 + dataSize;
    const wavBuffer = new ArrayBuffer(bufferSize);
    const view = new DataView(wavBuffer);

    const writeString = (offset, str) => {
      for (let i = 0; i < str.length; i += 1) {
        view.setUint8(offset + i, str.charCodeAt(i));
      }
    };

    writeString(0, "RIFF");
    view.setUint32(4, 36 + dataSize, true);
    writeString(8, "WAVE");
    writeString(12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 3, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bytesPerSample * 8, true);
    writeString(36, "data");
    view.setUint32(40, dataSize, true);

    const channelData = [];
    for (let ch = 0; ch < numChannels; ch += 1) {
      channelData.push(buffer.getChannelData(ch));
    }

    let offset = 44;
    for (let i = 0; i < length; i += 1) {
      for (let ch = 0; ch < numChannels; ch += 1) {
        const sample = Math.max(-1, Math.min(1, channelData[ch][i]));
        view.setFloat32(offset, sample, true);
        offset += bytesPerSample;
      }
    }

    return wavBuffer;
  };

  const exportAudio = async () => {
    if (!audioFolderLoaded || !audioBuffersByQuality.size || !audioUrlsByQuality.size) {
      log("Carga una carpeta de WAVs para exportar audio.", "ERROR");
      return;
    }
    let parsed;
    try {
      parsed = buildAudioSegments();
    } catch (err) {
      log(String(err?.message || err), "ERROR");
      updateQualityMismatch();
      return;
    }

    const segments = parsed.segments;
    if (!segments.length) {
      log("No hay acordes para exportar.", "ERROR");
      return;
    }

    const rootBarMap = buildRootBarStartMap();
    const barsPerChord = getBarsPerChord();
    const eighthsPerBar = getEighthsPerBar();
    const segmentEighths = eighthsPerBar * barsPerChord;

    for (const seg of segments) {
      if (!audioBuffersByQuality.has(seg.quality) || !audioUrlsByQuality.has(seg.quality)) {
        log(`No tengo WAV para la calidad "${seg.quality}".`, "ERROR");
        return;
      }
      if (!rootBarMap.has(seg.rootSemi)) {
        log(`Fundamental inválida para audio: ${seg.root}.`, "ERROR");
        return;
      }
    }

    const buffers = [...audioBuffersByQuality.values()];
    const sampleRate = buffers[0]?.sampleRate || 44100;
    const numChannels = Math.max(1, ...buffers.map((buf) => buf.numberOfChannels || 1));
    const secPerEighth = getSecondsPerEighth();
    const totalDuration = parsed.totalEighth * secPerEighth;
    const renderLength = Math.ceil((totalDuration + 0.4) * sampleRate);
    const offlineCtx = new OfflineAudioContext(numChannels, renderLength, sampleRate);

    log("Renderizando audio en segundo plano…", "OK");

    const barSeconds = getBarSeconds();

    for (const seg of segments) {
      const buffer = audioBuffersByQuality.get(seg.quality);
      const rootBarStart = rootBarMap.get(seg.rootSemi);
      const offsetEighthInSegment = seg.startEighth % segmentEighths;
      const offsetSeconds = offsetEighthInSegment * secPerEighth;
      const loopStart = rootBarStart * barSeconds;

      const startTime = seg.startEighth * secPerEighth;
      const endTime = startTime + seg.durEighth * secPerEighth;
      const startFromBeginning = !!seg.windowFromStart;
      const bufferOffset = startFromBeginning ? loopStart : loopStart + offsetSeconds;

      scheduleAudioChord({
        ctx: offlineCtx,
        buffer,
        startTime,
        endTime,
        bufferOffset,
        trackNodes: false,
      });
    }

    let rendered;
    try {
      rendered = await offlineCtx.startRendering();
    } catch (err) {
      log(`Error al renderizar WAV: ${String(err?.message || err)}`, "ERROR");
      return;
    }

    const wavBuffer = encodeWavFromBuffer(rendered);
    const blob = new Blob([wavBuffer], { type: "audio/wav" });
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement("a");
    anchor.href = url;
    anchor.download = `referencia_${getRefBpm()}bpm.wav`;
    document.body.appendChild(anchor);
    anchor.click();
    anchor.remove();
    URL.revokeObjectURL(url);
    log(`Exportado audio: ${anchor.download}`, "OK");
  };

  const btnHelp = el("btnHelp");
  const btnHelpClose = el("btnHelpClose");
  const helpModal = el("helpModal");
  const openHelp = () => {
    helpModal.classList.add("open");
    helpModal.setAttribute("aria-hidden", "false");
  };
  const closeHelp = () => {
    helpModal.classList.remove("open");
    helpModal.setAttribute("aria-hidden", "true");
  };
  btnHelp.addEventListener("click", openHelp);
  btnHelpClose.addEventListener("click", closeHelp);
  helpModal.addEventListener("click", (e) => { if (e.target === helpModal) closeHelp(); });
  window.addEventListener("keydown", (e) => { if (e.key === "Escape") closeHelp(); });

  const btnTheme = el("btnTheme");
  const root = document.documentElement;
  const setTheme = (t) => {
    root.setAttribute("data-theme", t);
    try { localStorage.setItem("jcg_theme", t); } catch (_) {}
  };
  const savedTheme = (() => { try { return localStorage.getItem("jcg_theme"); } catch (_) { return null; } })();
  setTheme(savedTheme || "dark");
  btnTheme.addEventListener("click", () => {
    const cur = root.getAttribute("data-theme") || "dark";
    setTheme(cur === "dark" ? "light" : "dark");
  });

  el("btnPickAudioFolder").addEventListener("click", loadAudioFolder);
  el("btnPlay").addEventListener("click", playAudio);
  el("btnStop").addEventListener("click", stopAudioPlayback);
  el("btnExportAudio").addEventListener("click", exportAudio);
  btnSaveProg.addEventListener("click", saveCurrentProgression);
  btnLoadProg.addEventListener("click", loadSelectedProgression);
  btnExportProgs.addEventListener("click", exportProgressions);
  btnImportProgs.addEventListener("click", () => importProgFile.click());
  importProgFile.addEventListener("change", (e) => {
    const file = e.target.files?.[0];
    if (file) {
      importProgressions(file);
    }
    e.target.value = "";
  });

  prog.addEventListener("input", updateQualityMismatch);
  repeatCount.addEventListener("input", updateQualityMismatch);
  barsPerFileInput.addEventListener("input", updateQualityMismatch);
  barsPerChordInput.addEventListener("input", updateQualityMismatch);
  timeSignatureInput.addEventListener("change", updateQualityMismatch);
  refBpmInput.addEventListener("input", updateQualityMismatch);
  crossfadeMsInput.addEventListener("input", updateQualityMismatch);
  startRootInput.addEventListener("change", updateQualityMismatch);
  globalTranspose.addEventListener("input", applyGlobalTranspose);

  window.addEventListener("keydown", (e) => {
    if (e.code !== "Space" && e.key !== " ") return;
    const ae = document.activeElement;
    const tag = ae && ae.tagName ? ae.tagName.toLowerCase() : "";
    const typing = tag === "textarea" || tag === "input" || tag === "select" || (ae && ae.isContentEditable);
    if (typing) return;
    e.preventDefault();
    if (isAudioPlaying) stopAudioPlayback();
    else playAudio();
  });

  prog.value = "";
  renderQualityChips();
  renderSavedProgressions(getSavedProgressions());
  updateQualityMismatch();
  updateReadyState();
})();
</script>
</body>
</html>
