<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jazz Comping Generator - Jaime Jaramillo Arias</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' x2='1' y1='1' y2='0'%3E%3Cstop stop-color='%2338bdf8'/%3E%3Cstop offset='.6' stop-color='%23a78bfa'/%3E%3Cstop offset='1' stop-color='%23fbbf24'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='64' height='64' rx='14' fill='%23121826'/%3E%3Cpath d='M18 46c5-4 9-9 14-18 4 8 9 13 14 17' fill='none' stroke='url(%23g)' stroke-width='6' stroke-linecap='round'/%3E%3Ccircle cx='18' cy='46' r='4' fill='%2338bdf8'/%3E%3Ccircle cx='32' cy='28' r='4' fill='%23a78bfa'/%3E%3Ccircle cx='46' cy='45' r='4' fill='%23fbbf24'/%3E%3C/svg%3E" />
  <style>
    :root{
      --bg:#0f141b;
      --panel:#161c26;
      --panel2:#1c2430;
      --txt:#f0f4f8;
      --muted:#a1adbf;
      --line:#2b3646;
      --accent:#2f81f7;
      --bad:#f87171;
      --ok:#4ade80;
      --metal-purple-1:#5b3bce;
      --metal-purple-2:#8b5cf6;
      --metal-purple-3:#3b1a7a;
      --metal-orange-1:#f59e0b;
      --metal-orange-2:#f97316;
      --metal-orange-3:#b45309;
      --metal-green-1:#34d399;
      --metal-green-2:#22c55e;
      --metal-green-3:#15803d;
      --shadow: 0 18px 34px rgba(6,10,16,.55);
      --glow: 0 0 0 1px rgba(74,92,120,.35), 0 18px 36px rgba(0,0,0,.55);
      --frost: blur(16px);
      --r:18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:'Inter', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 720px at 10% 12%, rgba(46,129,247,.12), transparent 60%),
                  radial-gradient(1000px 640px at 84% 8%, rgba(66,83,108,.18), transparent 60%),
                  var(--bg);
      color:var(--txt);
      position:relative;
      min-height:100%;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      background: radial-gradient(680px 460px at 24% 78%, rgba(47,129,247,.08), transparent 62%),
                  radial-gradient(620px 420px at 78% 80%, rgba(64,78,98,.12), transparent 60%);
      pointer-events:none;
      opacity:.6;
    }
    .wrap{
      max-width:760px; margin:10px auto 18px; padding:0 12px 18px;
    }
    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px; flex-wrap:wrap;
    }
    header.hero{padding:12px; border:1px solid rgba(255,255,255,.08); background: linear-gradient(135deg, rgba(30,40,56,.95), rgba(22,30,44,.96)); box-shadow: var(--glow); backdrop-filter: var(--frost); border-radius:18px;}
    .brand{display:flex; flex-direction:column; gap:6px;}
    .eyebrow{margin:0; font-size:11px; letter-spacing:.4px; text-transform:uppercase; color:rgba(255,255,255,.68); font-weight:800;}
    h1{margin:0; font-size:28px; letter-spacing:.1px; font-weight:800; color:#f8fafc; text-shadow:0 14px 40px rgba(0,0,0,.35); font-family:'Space Grotesk', 'Inter', system-ui, -apple-system, sans-serif;}
    .sub{color:var(--muted); font-size:12px; margin-top:2px; line-height:1.5;}
    .legal{
      margin-top:6px;
      font-size:11px;
      color:rgba(255,255,255,.7);
      line-height:1.4;
    }
    .card{
      background: linear-gradient(180deg, rgba(22,30,44,.98), rgba(20,28,40,.94));
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
      backdrop-filter: var(--frost);
    }
    .megaCard{padding:4px 4px 10px; border:1px solid rgba(255,255,255,.08); box-shadow: var(--glow);}
    .megaHd{border-bottom:1px solid rgba(44,56,76,.8); background: linear-gradient(135deg, rgba(22,30,44,.98), rgba(18,26,38,.98)); padding:6px 10px; display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .megaHd .title{font-size:13px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted);}
    .megaHd .mini{color:rgba(255,255,255,.82); font-size:12px;}
    .megaBd{display:flex; flex-direction:column; gap:8px; padding:8px;}
    .heroMeta{display:flex; align-items:center; gap:14px; flex-wrap:wrap; justify-content:flex-end;}
    .controlBar{display:grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap:8px; align-items:stretch;}
    .controlCluster{border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:8px 10px; background: linear-gradient(180deg, rgba(19,26,38,.98), rgba(15,22,34,.98)); display:flex; flex-direction:column; gap:6px; box-shadow: 0 12px 24px rgba(0,0,0,.4); position:relative; overflow:hidden;}
    .controlCluster.draggable{cursor:grab;}
    .controlCluster.dragging{opacity:.6; transform:scale(.99); cursor:grabbing;}
    .controlCluster.drag-target{outline:2px dashed rgba(47,129,247,.6); outline-offset:3px;}
    .controlCluster::before{content:""; position:absolute; inset:0; background: linear-gradient(135deg, rgba(47,129,247,.12), rgba(45,57,78,.18) 55%, transparent 90%); opacity:.8; pointer-events:none;}
    .controlCluster > *{position:relative;}
    .clusterTitle{font-size:11px; color:var(--muted); letter-spacing:.4px; text-transform:uppercase; font-weight:800;}
    .clusterActions{display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
    .miniStat{font-size:12px; color:var(--muted); margin-left:auto;}
    .progressWrap{display:none; flex-direction:column; gap:4px; margin-top:6px;}
    .progressWrap.active{display:flex;}
    .progressRow{display:flex; align-items:center; justify-content:space-between; font-size:11px; color:var(--muted);}
    progress{width:100%; height:10px; border-radius:999px; overflow:hidden; appearance:none; background: rgba(255,255,255,.08);}
    progress::-webkit-progress-bar{background: rgba(255,255,255,.08); border-radius:999px;}
    progress::-webkit-progress-value{background: linear-gradient(90deg, rgba(47,129,247,.85), rgba(139,92,246,.9)); border-radius:999px;}
    progress::-moz-progress-bar{background: linear-gradient(90deg, rgba(47,129,247,.85), rgba(139,92,246,.9)); border-radius:999px;}
    .card .hd{
      padding:8px 10px 6px;
      border-bottom:1px solid rgba(35,50,74,.75);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background: linear-gradient(135deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    }
    .card .hd .title{font-size:13px; color:var(--muted); letter-spacing:.4px; text-transform:uppercase; letter-spacing:.32px}
    .card .bd{padding:8px}
    textarea{
      width:100%; min-height:96px; padding:8px 10px;
      border-radius:14px; border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      color:var(--txt); font-size:14px; line-height:1.45;
      outline:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    textarea:focus{border-color: rgba(47,129,247,.6); box-shadow:0 0 0 4px rgba(47,129,247,.15)}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .btn{
      border:1px solid rgba(136,92,255,.65);
      background: linear-gradient(160deg, var(--metal-purple-2), var(--metal-purple-1) 48%, var(--metal-purple-3) 100%);
      color:var(--txt);
      padding:7px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      letter-spacing:.15px;
      font-size:12px;
      transition: transform .06s ease, border-color .15s ease, background .15s ease, box-shadow .15s ease;
      user-select:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.45), inset 0 -1px 0 rgba(0,0,0,.45), 0 12px 22px rgba(8,6,24,.45), 0 0 0 1px rgba(63,46,120,.55);
      text-shadow: 0 1px 0 rgba(22,12,46,.6);
    }
    .btn:hover{border-color: rgba(172,129,255,.9); background: linear-gradient(160deg, #a78bfa, #6d4bd6 52%, #2c105e 100%); box-shadow: inset 0 1px 0 rgba(255,255,255,.5), 0 16px 26px rgba(12,6,28,.45), 0 0 0 1px rgba(118,84,192,.45)}
    .btn:active{transform: translateY(1px)}
    .btn.primary{border-color: rgba(34,197,94,.8); background: linear-gradient(160deg, var(--metal-green-1), var(--metal-green-2) 50%, var(--metal-green-3)); color:#052311}
    .btn.purple{border-color: rgba(139,92,246,.8); background: linear-gradient(160deg, rgba(167,139,250,.85), rgba(139,92,246,.75) 52%, rgba(76,29,149,.85)); color:#f8fafc}
    .btn.bad{border-color: rgba(249,115,22,.85); background: linear-gradient(160deg, var(--metal-orange-1), var(--metal-orange-2) 50%, var(--metal-orange-3)); color:#2a1204}
    .btn:disabled{opacity:.45; cursor:not-allowed}
    select,
    input[type="number"]{
      width:100%;
      padding:7px 9px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color:var(--txt);
      outline:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    select:focus,
    input[type="number"]:focus{border-color: rgba(47,129,247,.6); box-shadow:0 0 0 4px rgba(47,129,247,.15)}
    .label{font-size:11px; color:var(--muted); margin-bottom:6px; display:flex; align-items:center; gap:8px}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      color:#f8fafc;
      font-size:12px;
      cursor:pointer;
      user-select:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .folderChip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(47,129,247,.12);
      color:var(--txt);
      font-size:11px;
      font-weight:700;
      text-transform:uppercase;
      letter-spacing:.3px;
    }
    .pill:hover{border-color: rgba(47,129,247,.45)}
    .pill.status{padding:8px 12px; font-weight:700; letter-spacing:.2px; box-shadow:0 10px 18px rgba(0,0,0,.28)}
    .pill small{color:var(--muted); font-weight:600}
    .chips{display:flex; flex-wrap:wrap; gap:8px}
    .split{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    .kpi{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .dot{width:9px; height:9px; border-radius:50%}
    .dot.ok{background:var(--ok)}
    .dot.bad{background:var(--bad)}
    .mono{font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
    .log{
      max-height:260px; overflow:auto; padding:12px 14px;
      border-radius:14px; border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03); color:var(--muted);
      font-size:12px; line-height:1.35;
      white-space:pre-wrap;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .mini{font-size:12px; color:var(--muted)}
    .inputNumber{width:120px}
    .sectionGrid{display:grid; grid-template-columns: repeat(auto-fit, minmax(260px,1fr)); gap:8px;}
    .sectionCard{border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:8px 10px; background: linear-gradient(180deg, rgba(20,28,40,.98), rgba(17,24,36,.98)); display:flex; flex-direction:column; gap:6px; box-shadow: 0 12px 28px rgba(0,0,0,.35);}
    .sectionTitle{font-size:11px; color:var(--accent); letter-spacing:.6px; text-transform:uppercase; font-weight:800;}
    .inlineStats{display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-size:12px; color:var(--muted);}
    .pillRow{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .mixerGrid{display:grid; grid-template-columns: repeat(auto-fit, minmax(160px,1fr)); gap:10px;}
    .mixerTrack{border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:10px; background: linear-gradient(180deg, rgba(20,28,40,.98), rgba(17,24,36,.98)); display:flex; flex-direction:column; gap:8px; box-shadow: 0 12px 26px rgba(0,0,0,.35);}
    .mixerTrack .trackName{font-size:12px; font-weight:800; text-transform:uppercase; letter-spacing:.4px;}
    .mixerTrack .trackValue{font-size:11px; color:var(--muted);}
    .mixerTrack .trackButtons{display:flex; gap:6px; flex-wrap:wrap;}
    .mixerTrack .btn.sm{padding:5px 8px; font-size:11px;}
    .mixerEmpty{font-size:12px; color:var(--muted);}
    .warn{color: #fbbf24}
    .ok{color: var(--ok)}
    .bad{color: var(--bad)}
    .hint{color:var(--muted); font-size:12px; margin-top:10px; line-height:1.35}
    .hint code{color:#c7d2fe}

    .menuBar{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 8px;
      flex-wrap:wrap;
      position:relative;
      z-index:20;
      overflow:visible;
    }
    .menuGroup{position:relative;}
    .menuBtn{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color:var(--txt);
      padding:6px 10px;
      border-radius:10px;
      font-weight:700;
      font-size:12px;
      cursor:pointer;
      letter-spacing:.2px;
    }
    .menuBtn:hover{border-color: rgba(47,129,247,.45)}
    .menuBtn[aria-expanded="true"]{
      border-color: rgba(47,129,247,.65);
      box-shadow: 0 0 0 3px rgba(47,129,247,.18);
    }
    .menuPopup{
      position:absolute;
      top:calc(100% + 8px);
      left:0;
      min-width:260px;
      max-width:min(520px, 92vw);
      background: linear-gradient(180deg, rgba(22,30,44,.98), rgba(20,28,40,.98));
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      box-shadow: var(--shadow);
      padding:10px;
      display:none;
      z-index:30;
    }
    .menuPopup.open{display:block;}
    .menuSection{display:flex; flex-direction:column; gap:8px;}
    .menuSection + .menuSection{margin-top:10px; padding-top:10px; border-top:1px solid rgba(255,255,255,.08);}
    .menuSectionTitle{font-size:11px; text-transform:uppercase; letter-spacing:.4px; color:var(--muted); font-weight:800;}
    .menuRow{display:flex; flex-wrap:wrap; gap:8px; align-items:center;}
    .menuGrid{display:grid; grid-template-columns: repeat(auto-fit, minmax(150px,1fr)); gap:8px;}
    .menuFooter{font-size:11px; color:var(--muted);}

    .topActions{display:flex; gap:8px; align-items:center}
    .btn.ghost{background: rgba(91,59,206,.12); border-color: rgba(167,139,250,.55); color:var(--txt)}
    .btn.ghost:hover{background: rgba(167,139,250,.2)}
    .helpBtn{display:inline-flex; align-items:center; gap:8px}
    .helpBtn .q{display:inline-flex; width:18px; height:18px; border-radius:999px; align-items:center; justify-content:center;
      border:1px solid rgba(255,255,255,.18); color: var(--txt); font-weight:800; font-size:12px; background: rgba(255,255,255,.06);
    }
    .chordPreview{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(47,129,247,.08);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      min-height:56px;
    }
    .savedRow{display:grid; gap:6px; grid-template-columns: minmax(140px, 1.1fr) minmax(140px, 0.8fr); align-items:end;}
    .savedRow .btn{width:100%}
    .savedRow select,
    .savedRow input[type="text"]{width:100%}
    .savedMeta{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
    input[type="text"]{
      width:100%;
      padding:7px 9px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color:var(--txt);
      outline:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    input[type="text"]:focus{border-color: rgba(47,129,247,.6); box-shadow:0 0 0 4px rgba(47,129,247,.15)}
    .badge{
      font-size:11px;
      font-weight:700;
      color:#f8fafc;
      background: linear-gradient(180deg, rgba(47,129,247,.9), rgba(31,111,235,.9));
      padding:4px 8px;
      border-radius:999px;
    }
    .barRow{display:flex; flex-wrap:wrap; align-items:center; gap:6px}
    .barSep{color:var(--muted); font-weight:700; letter-spacing:.4px}
    .chordToken{
      padding:6px 10px;
      border-radius:10px;
      background: linear-gradient(140deg, rgba(139,92,246,.85), rgba(34,197,94,.6) 55%, rgba(249,115,22,.85));
      border:1px solid rgba(139,92,246,.55);
      font-size:12px;
      font-weight:700;
      letter-spacing:.2px;
      color:#f1f5f9;
      text-shadow: 0 1px 0 rgba(20,12,36,.6);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.5), inset 0 -1px 0 rgba(0,0,0,.35), 0 8px 16px rgba(12,6,26,.4);
    }
    .chordToken.bad{
      background: linear-gradient(150deg, rgba(253,186,116,.95), rgba(249,115,22,.95) 50%, rgba(180,83,9,.9));
      border-color: rgba(249,115,22,.85);
      color:#0b0f1c;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.55), inset 0 -1px 0 rgba(0,0,0,.35), 0 0 0 1px rgba(249,115,22,.4), 0 8px 18px rgba(180,83,9,.35);
    }
    .chordToken.mute{
      background: linear-gradient(150deg, rgba(100,116,139,.9), rgba(71,85,105,.9) 60%, rgba(51,65,85,.95));
      border-color: rgba(148,163,184,.7);
      color:#f8fafc;
      text-shadow: none;
    }
    .previewEmpty,
    .previewError{
      color:var(--muted);
      font-size:12px;
    }

    /* Modal */
    .modal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; padding:18px; background: rgba(9,13,20,.55); z-index:9999;}
    .modal.open{display:flex}
    .modalCard{
      width:min(860px, 100%);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      box-shadow: 0 18px 44px rgba(0,0,0,.30);
      overflow:hidden;
    }
    .modalHd{padding:14px 14px 10px; border-bottom:1px solid rgba(255,255,255,.12); display:flex; justify-content:space-between; align-items:center; gap:12px}
    .modalHd h2{margin:0; font-size:14px; letter-spacing:.3px}
    .modalBd{padding:14px}
    .modalBd p{margin:0 0 10px; color: var(--muted); font-size:13px; line-height:1.45}
    .modalBd ul{margin:8px 0 14px 18px; color: var(--muted); font-size:13px; line-height:1.45}
    .kbd{font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace; padding:2px 6px; border-radius:8px;
      border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06); color: var(--txt); font-size:12px;
    }

    @media (max-width: 980px){
      .controlBar{grid-template-columns: 1fr;}
    }

    /* Modal: solid (no translucency) */
    .modalCard{background: var(--panel) !important;}

    /* Theme toggle */
    html[data-theme="dark"]{
      --bg:#0f141b;
      --panel:#161c26;
      --panel2:#1c2430;
      --txt:#f0f4f8;
      --muted:#a1adbf;
      --line:#2b3646;
      --accent:#2f81f7;
      --bad:#f87171;
      --ok:#4ade80;
      --shadow: 0 18px 34px rgba(6,10,16,.55);
    }
    html[data-theme="light"]{
      --bg:#f2f4f8;
      --panel:#ffffff;
      --panel2:#f4f6fb;
      --txt:#0f1a2b;
      --muted:#52647c;
      --line:#d6dde9;
      --accent:#1f6feb;
      --bad:#e64967;
      --ok:#17804f;
      --shadow: 0 10px 24px rgba(12,18,40,.12);
      --glow: 0 0 0 1px rgba(31,111,235,.22), 0 16px 28px rgba(12,18,40,.16);
      --frost: blur(12px);
    }
    html[data-theme="light"] body{
      background: radial-gradient(900px 520px at 18% 12%, rgba(31,111,235,.08), transparent 60%),
                  radial-gradient(900px 520px at 82% 18%, rgba(82,100,124,.08), transparent 60%),
                  var(--bg);
      color:var(--txt);
    }
    html[data-theme="light"] textarea,
    html[data-theme="light"] select,
    html[data-theme="light"] input[type="number"],
    html[data-theme="light"] input[type="text"]{
      background: rgba(18,24,38,.04);
      color: var(--txt);
      border-color: var(--line);
    }
    html[data-theme="light"] .btn{
      background: linear-gradient(160deg, #c4b5fd, #8b5cf6 55%, #4c1d95);
      color: #1f1140;
      border-color: rgba(139,92,246,.7);
      text-shadow: 0 1px 0 rgba(255,255,255,.55);
    }
    html[data-theme="light"] .btn:hover{
      background: linear-gradient(160deg, #ddd6fe, #7c3aed 55%, #4c1d95);
      border-color: rgba(109,40,217,.55);
    }
    html[data-theme="light"] .btn.ghost{
      background: transparent;
      color: var(--txt);
      border-color: rgba(124,58,237,.45);
      text-shadow: none;
    }
    html[data-theme="light"] .btn.ghost:hover{
      background: rgba(124,58,237,.12);
    }
    html[data-theme="light"] .pill{
      background: rgba(18,24,38,.04);
      border-color: var(--line);
      color: var(--txt);
    }

  </style>
</head>
<body>
<div class="wrap">
  <header class="hero card">
    <div class="brand">
      <h1>Jazz Comping Generator - Jaime Jaramillo Arias</h1>
      <div class="sub">Escribe una progresión, controla tus referencias de audio y genera playback desde archivos WAV.</div>
      <div class="legal">Este código e interfaz no son de código abierto. Derechos reservados © Jaime Jaramillo Arias.</div>
    </div>
  </header>

  <div class="card menuBar" role="menubar" aria-label="Menú principal">
    <div class="menuGroup">
      <button class="menuBtn" type="button" data-menu-target="menuPlayback" aria-expanded="false" aria-haspopup="true">Reproducción</button>
      <div class="menuPopup" id="menuPlayback" role="menu">
        <div class="menuSection">
          <div class="menuSectionTitle">Reproducción y export</div>
          <div class="menuRow">
            <button class="btn primary" id="btnPlay" title="Reproducir la progresión usando tus referencias de audio">Reproducir</button>
            <button class="btn bad" id="btnStop" title="Detener reproducción">Stop</button>
            <button class="btn purple" id="btnExportAudio" title="Exportar el audio generado">Exportar audio</button>
          </div>
        </div>
      </div>
    </div>

    <div class="menuGroup">
      <button class="menuBtn" type="button" data-menu-target="menuProgressions" aria-expanded="false" aria-haspopup="true">Progresiones</button>
      <div class="menuPopup" id="menuProgressions" role="menu">
        <div class="menuSection">
          <div class="menuSectionTitle">Guardar progresiones</div>
          <div class="menuGrid">
            <div>
              <div class="label">Nombre de progresión</div>
              <input id="progName" type="text" placeholder="Ej: Blues en F, Turnaround" />
            </div>
            <div class="row" style="align-items:end;">
              <button class="btn primary" id="btnSaveProg" title="Guardar la progresión actual">Guardar</button>
            </div>
          </div>
        </div>
        <div class="menuSection">
          <div class="menuSectionTitle">Administrar</div>
          <div class="menuGrid">
            <div>
              <div class="label">Progresiones guardadas</div>
              <select id="savedProgSelect"></select>
            </div>
            <div class="menuRow">
              <button class="btn" id="btnLoadProg" title="Cargar la progresión seleccionada">Cargar</button>
              <button class="btn bad" id="btnDeleteProg" title="Eliminar la progresión seleccionada">Eliminar</button>
              <button class="btn ghost" id="btnExportProgs" title="Exportar todas las progresiones guardadas">Exportar</button>
              <button class="btn ghost" id="btnImportProgs" title="Cargar el archivo con progresiones exportadas">Cargar archivo</button>
            </div>
          </div>
          <div class="menuRow">
            <span class="badge" id="savedCount">0 guardadas</span>
            <input id="importProgFile" type="file" accept=".json,application/json" style="display:none" />
          </div>
        </div>
      </div>
    </div>

    <div class="menuGroup">
      <button class="menuBtn" type="button" data-menu-target="menuAudio" aria-expanded="false" aria-haspopup="true">Audio</button>
      <div class="menuPopup" id="menuAudio" role="menu">
        <div class="menuSection">
          <div class="menuSectionTitle">Carpetas de audio</div>
          <div class="menuRow">
            <button class="btn" id="btnPickAudioFolder" title="Cargar una o más carpetas con archivos WAV de referencia">Cargar carpeta</button>
            <button class="btn ghost" id="btnAddAudioFolder" title="Agregar otra carpeta de instrumentos">+</button>
            <input id="audioFolderFallback" type="file" webkitdirectory style="display:none" />
          </div>
          <div class="mini" id="audioFolderStatus">Sin instrumentos cargados.</div>
          <div class="chips" id="audioFolderList"></div>
        </div>
        <div class="menuSection">
          <div class="menuSectionTitle">Loop base</div>
          <div class="menuRow">
            <button class="btn ghost" id="btnLoopToggle" title="Activar o silenciar el loop base">Loop base: ON</button>
          </div>
          <div class="label">Volumen loop</div>
          <div class="row" style="gap:8px; align-items:center;">
            <input id="loopVolume" type="range" min="0" max="1" step="0.01" value="0.6" />
            <span class="mini" id="loopVolumeValue">60%</span>
          </div>
          <div class="mini" id="loopStatus">Sin loop cargado.</div>
        </div>
      </div>
    </div>

    <div class="menuGroup">
      <button class="menuBtn" type="button" data-menu-target="menuSettings" aria-expanded="false" aria-haspopup="true">Ajustes</button>
      <div class="menuPopup" id="menuSettings" role="menu">
        <div class="menuSection">
          <div class="menuSectionTitle">Parámetros globales</div>
          <div class="menuGrid">
            <div>
              <div class="label">Compases por archivo</div>
              <input id="barsPerFile" type="number" min="1" max="256" value="24" />
            </div>
            <div>
              <div class="label">Compases por acorde</div>
              <input id="barsPerChord" type="number" min="1" max="64" value="2" />
            </div>
            <div>
              <div class="label">Signatura de medida</div>
              <select id="timeSignature">
                <option value="2/4">2/4</option>
                <option value="3/4">3/4</option>
                <option value="4/4" selected>4/4</option>
                <option value="5/4">5/4</option>
                <option value="6/8">6/8</option>
                <option value="7/8">7/8</option>
              </select>
            </div>
            <div>
              <div class="label">BPM fijo referencias</div>
              <input id="refBpm" type="number" min="20" max="300" value="90" />
            </div>
            <div>
              <div class="label">Compases loop base</div>
              <input id="loopBars" type="number" min="1" max="256" value="8" />
            </div>
            <div>
              <div class="label">Fundamental inicial</div>
              <select id="startRoot">
                <option value="A">A</option>
                <option value="A#">A#</option>
                <option value="B">B</option>
                <option value="C">C</option>
                <option value="C#">C#</option>
                <option value="D">D</option>
                <option value="D#">D#</option>
                <option value="E">E</option>
                <option value="F">F</option>
                <option value="F#">F#</option>
                <option value="G" selected>G</option>
                <option value="G#">G#</option>
              </select>
            </div>
            <div>
              <div class="label">Repeticiones</div>
              <input id="repeatCount" type="number" min="1" max="64" value="1" class="inputNumber" title="Número de veces que se repetirá la progresión" />
            </div>
            <div>
              <div class="label">Transposición</div>
              <input id="globalTranspose" type="number" min="-24" max="24" value="0" class="inputNumber" title="Sube o baja las fundamentales del cifrado por semitonos" />
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="menuGroup">
      <button class="menuBtn" type="button" data-menu-target="menuStatus" aria-expanded="false" aria-haspopup="true">Estado</button>
      <div class="menuPopup" id="menuStatus" role="menu">
        <div class="menuSection">
          <div class="menuSectionTitle">Referencias</div>
          <div class="menuRow">
            <div class="pill status" title="Estado de carga de referencias de audio">
              <span class="dot bad" id="dotReady"></span>
              <span id="readyText">No listo</span>
            </div>
            <div class="pill status" id="qualityMismatch" title="Estado de coincidencia de calidades">
              <span class="dot bad" id="qualityMismatchDot"></span>
              <span id="qualityMismatchText">Carga referencias de audio para validar calidades.</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="menuGroup">
      <button class="menuBtn" type="button" data-menu-target="menuHelp" aria-expanded="false" aria-haspopup="true">Ayuda</button>
      <div class="menuPopup" id="menuHelp" role="menu">
        <div class="menuSection">
          <div class="menuSectionTitle">Soporte rápido</div>
          <div class="menuRow">
            <button class="btn ghost helpBtn" id="btnHelp" title="Abrir ayuda">
              <span class="q">?</span><span>Ayuda</span>
            </button>
          </div>
          <div class="menuFooter">Accede a la guía paso a paso y atajos.</div>
        </div>
      </div>
    </div>
  </div>

  <div class="card megaCard">
    <div class="hd megaHd">
      <div class="title">Panel principal</div>
    </div>
    <div class="megaBd">
      <div class="sectionGrid">
        <div class="sectionCard">
          <div class="sectionTitle">Progresión y calidades</div>
          <div class="label">Cifrados disponibles (calidades) <span class="mini">(clic para insertar)</span></div>
          <div class="chips" id="qualityChips"></div>
          <div class="label" style="margin-top:8px">Progresión</div>
          <textarea id="prog" spellcheck="false" title="Escribe la progresión usando barras: | Cmaj7 | o | Dm7 G7 |. Usa |/|, |-|, ||: y :||." placeholder="Escribe una progresión con barras. Ej: | Cmaj7 | o | Dm7 G7 |. Usa |/|, |-|, ||: y :|| para loops." ></textarea>
        </div>
      </div>

      <div class="card">
        <div class="hd">
          <div class="title">Mezclador</div>
          <div class="mini" id="mixerSummary">0 instrumentos</div>
        </div>
        <div class="bd">
          <div class="mixerEmpty" id="mixerEmpty">Carga una carpeta para ver instrumentos en el mezclador.</div>
          <div class="mixerGrid" id="mixerGrid"></div>
        </div>
      </div>
    </div>
  </div>
</div>


<div class="modal" id="helpModal" aria-hidden="true">
  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modalHd">
      <h2 id="helpTitle">Ayuda</h2>
      <div class="row">
        <button class="btn" id="btnHelpClose" title="Cerrar ayuda">Cerrar</button>
      </div>
    </div>
    <div class="modalBd">
      <p><b>Guía amigable paso a paso</b></p>
      <ul>
        <li><b>1) Prepara tus WAVs:</b> cada archivo debe nombrarse como <span class="kbd">calidad__instrumento.wav</span> o <span class="kbd">calidad_instrumento.wav</span>. Ejemplos: <span class="kbd">maj7__piano.wav</span>, <span class="kbd">m7_guitarra.wav</span>, <span class="kbd">7alt__rhodes.wav</span>. El texto antes del separador es la <i>calidad</i> (maj7, m7, 7b9, ø7, etc.).</li>
        <li><b>2) Carga tu carpeta:</b> pulsa <span class="kbd">Cargar carpeta</span>. Al cargar, revisa el indicador de <b>Calidades detectadas</b> para confirmar que el sistema reconoce todo lo que necesitas.</li>
        <li><b>3) Ajusta la base:</b> define <span class="kbd">Compases por archivo</span>, <span class="kbd">Compases por acorde</span>, el <span class="kbd">BPM fijo</span> de referencia y la <span class="kbd">Fundamental inicial</span>. Estos parámetros determinan cómo se alinean los audios con tu progresión.</li>
        <li><b>4) Escribe la progresión:</b> usa barras para separar compases. Ejemplo: <span class="kbd">| Dm7 G7 | Cmaj7 |</span>. Puedes usar:
          <ul>
            <li><span class="kbd">|/|</span> para mutear instrumentos dentro de un compás.</li>
            <li><span class="kbd">|-|</span> para mutear todo el compás.</li>
            <li><span class="kbd">||:</span> … <span class="kbd">:||</span> para repetir secciones.</li>
            <li><span class="kbd">2-3</span> o <span class="kbd">3-2</span> al inicio para aplicar clave.</li>
          </ul>
        </li>
        <li><b>5) Transposición:</b> el control <span class="kbd">Transposición</span> sube o baja las <b>fundamentales</b> de los acordes en semitonos <i>sin alterar sus calidades</i>. Ejemplo: si subes +2, <span class="kbd">Dm7</span> pasa a <span class="kbd">Em7</span> y <span class="kbd">G7</span> pasa a <span class="kbd">A7</span>.</li>
        <li><b>6) Mezclador:</b> ajusta volumen, mute y solo por instrumento para construir tu balance. El resumen del mezclador te indica cuántos instrumentos están activos.</li>
        <li><b>7) Guardar y recuperar:</b> usa <span class="kbd">Guardar</span> para registrar una progresión, <span class="kbd">Exportar</span> para descargar todas, y <span class="kbd">Cargar archivo</span> para reimportarlas más tarde.</li>
        <li><b>8) Escuchar y exportar:</b> pulsa <span class="kbd">Reproducir</span> para escuchar, <span class="kbd">Stop</span> para detener y <span class="kbd">Exportar audio</span> para generar un WAV final.</li>
      </ul>
      <p class="mini">Atajo: <span class="kbd">Espacio</span> alterna Reproducir / Stop (cuando no estás escribiendo en un campo de texto).</p>

    </div>
  </div>
</div>

<script type="module">

(() => {
  const el = (id) => document.getElementById(id);
  const logEl = el("log");
  const readyText = el("readyText");
  const dotReady = el("dotReady");
  const audioFolderStatus = el("audioFolderStatus");
  const audioFolderList = el("audioFolderList");
  const loopStatus = el("loopStatus");
  const qualityChips = el("qualityChips");
  const qualityMismatchText = el("qualityMismatchText");
  const qualityMismatchDot = el("qualityMismatchDot");
  const progPreview = el("progPreview");
  const mixerGrid = el("mixerGrid");
  const mixerEmpty = el("mixerEmpty");
  const mixerSummary = el("mixerSummary");

  const prog = el("prog");
  const progName = el("progName");
  const savedProgSelect = el("savedProgSelect");
  const btnSaveProg = el("btnSaveProg");
  const btnLoadProg = el("btnLoadProg");
  const btnDeleteProg = el("btnDeleteProg");
  const btnExportProgs = el("btnExportProgs");
  const btnImportProgs = el("btnImportProgs");
  const importProgFile = el("importProgFile");
  const savedCount = el("savedCount");
  const repeatCount = el("repeatCount");
  const globalTranspose = el("globalTranspose");
  const barsPerFileInput = el("barsPerFile");
  const barsPerChordInput = el("barsPerChord");
  const timeSignatureInput = el("timeSignature");
  const refBpmInput = el("refBpm");
  const loopBarsInput = el("loopBars");
  const startRootInput = el("startRoot");
  const loopVolumeInput = el("loopVolume");
  const loopVolumeValue = el("loopVolumeValue");
  const btnLoopToggle = el("btnLoopToggle");

  const NOTE_TO_SEMI = new Map([
    ["C",0], ["B#",0],
    ["C#",1], ["DB",1],
    ["D",2],
    ["D#",3], ["EB",3],
    ["E",4], ["FB",4],
    ["F",5], ["E#",5],
    ["F#",6], ["GB",6],
    ["G",7],
    ["G#",8], ["AB",8],
    ["A",9],
    ["A#",10], ["BB",10],
    ["B",11], ["CB",11]
  ]);
  const SEMI_TO_NOTE_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const SEMI_TO_NOTE_FLAT = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];

  let audioCtx = null;
  let audioTracks = [];
  let baseLoopBuffers = [];
  let altLoopBuffers = [];
  let audioQualities = [];
  let audioFolderLoaded = false;
  let isAudioPlaying = false;
  let audioNodes = [];
  let audioTimers = [];
  let currentGlobalTranspose = 0;
  let loopEnabled = true;
  let trackIdCounter = 0;
  let playbackLoopTimer = null;
  let referenceBpmFromFolder = null;
  const PLAYBACK_SCHEDULE_AHEAD_SEC = 0.08;
  const RELEASE_TAIL_SEC = 0.05;
  const MIN_FADE_SEC = 0.005;
  const LOOP_CROSSFADE_SEC = 0.02;
  const LOOP_FADE_NO_OVERLAP_SEC = 0.01;
  const FADE_CURVE_SAMPLES = 128;
  const STORAGE_KEY = "jcg_saved_progressions";

  const buildEqualPowerCurve = (samples, fadeIn = true) => {
    const curve = new Float32Array(samples);
    for (let i = 0; i < samples; i += 1) {
      const t = i / (samples - 1);
      curve[i] = fadeIn ? Math.sin(t * Math.PI * 0.5) : Math.cos(t * Math.PI * 0.5);
    }
    return curve;
  };
  const FADE_IN_CURVE = buildEqualPowerCurve(FADE_CURVE_SAMPLES, true);
  const FADE_OUT_CURVE = buildEqualPowerCurve(FADE_CURVE_SAMPLES, false);

  const log = (msg, level = "INFO") => {
    const prefix = level === "ERROR" ? "❌" : level === "WARN" ? "⚠️" : "✅";
    const stamp = new Date().toLocaleTimeString();
    if (!logEl) {
      const method = level === "ERROR" ? "error" : level === "WARN" ? "warn" : "log";
      console[method](`[${stamp}] ${prefix} ${msg}`);
      return;
    }
    logEl.textContent += `[${stamp}] ${prefix} ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  };

  const readSavedProgressions = () => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return [];
      return parsed.filter((item) => item && typeof item.name === "string" && typeof item.text === "string");
    } catch (_) {
      return [];
    }
  };

  const writeSavedProgressions = (list) => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(list));
    } catch (err) {
      log(`No pude guardar progresiones: ${String(err?.message || err)}`, "ERROR");
    }
  };

  const renderSavedProgressions = (list, selectedName = "") => {
    if (!savedProgSelect) return;
    savedProgSelect.innerHTML = "";
    if (!list.length) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "Sin progresiones guardadas";
      savedProgSelect.appendChild(opt);
      savedProgSelect.disabled = true;
      if (btnLoadProg) btnLoadProg.disabled = true;
      if (btnDeleteProg) btnDeleteProg.disabled = true;
      if (btnExportProgs) btnExportProgs.disabled = true;
    } else {
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "Selecciona una progresión";
      savedProgSelect.appendChild(placeholder);
      for (const item of list) {
        const opt = document.createElement("option");
        opt.value = item.name;
        opt.textContent = item.name;
        savedProgSelect.appendChild(opt);
      }
      savedProgSelect.disabled = false;
      if (btnLoadProg) btnLoadProg.disabled = false;
      if (btnExportProgs) btnExportProgs.disabled = false;
      if (selectedName) savedProgSelect.value = selectedName;
      if (btnDeleteProg) btnDeleteProg.disabled = !savedProgSelect.value;
    }
    if (savedCount) {
      savedCount.textContent = `${list.length} guardada${list.length === 1 ? "" : "s"}`;
    }
  };

  const getSavedProgressions = () => readSavedProgressions().sort((a, b) => a.name.localeCompare(b.name, "es"));

  const saveCurrentProgression = () => {
    const name = (progName?.value || "").trim();
    const text = (prog?.value || "").trim();
    if (!name) {
      log("Escribe un nombre para guardar la progresión.", "WARN");
      return;
    }
    if (!text) {
      log("Escribe una progresión antes de guardar.", "WARN");
      return;
    }
    const list = getSavedProgressions();
    const existingIndex = list.findIndex((item) => item.name.toLowerCase() === name.toLowerCase());
    const payload = { name, text, updatedAt: new Date().toISOString() };
    if (existingIndex >= 0) {
      list[existingIndex] = payload;
    } else {
      list.push(payload);
    }
    writeSavedProgressions(list);
    renderSavedProgressions(list, name);
    log(`Progresión "${name}" guardada.`, "OK");
  };

  const loadSelectedProgression = () => {
    const name = savedProgSelect?.value || "";
    if (!name) {
      log("Selecciona una progresión guardada.", "WARN");
      return;
    }
    const list = getSavedProgressions();
    const item = list.find((p) => p.name === name);
    if (!item) {
      log("No encontré esa progresión.", "WARN");
      return;
    }
    prog.value = item.text;
    if (progName) progName.value = item.name;
    updateQualityMismatch();
    log(`Progresión "${item.name}" cargada.`, "OK");
  };

  const deleteSelectedProgression = () => {
    const name = savedProgSelect?.value || "";
    if (!name) {
      log("Selecciona una progresión guardada para eliminar.", "WARN");
      return;
    }
    const confirmed = window.confirm(`¿Eliminar la progresión "${name}"? Esta acción no se puede deshacer.`);
    if (!confirmed) return;
    const list = getSavedProgressions().filter((item) => item.name !== name);
    writeSavedProgressions(list);
    renderSavedProgressions(list);
    log(`Progresión "${name}" eliminada.`, "OK");
  };

  const exportProgressions = () => {
    const list = getSavedProgressions();
    if (!list.length) {
      log("No hay progresiones guardadas para exportar.", "WARN");
      return;
    }
    const blob = new Blob([JSON.stringify(list, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement("a");
    anchor.href = url;
    anchor.download = "progresiones_guardadas.json";
    document.body.appendChild(anchor);
    anchor.click();
    anchor.remove();
    URL.revokeObjectURL(url);
    log("Exportadas progresiones guardadas.", "OK");
  };

  const importProgressions = async (file) => {
    if (!file) return;
    try {
      const text = await file.text();
      const incoming = JSON.parse(text);
      if (!Array.isArray(incoming)) throw new Error("El archivo no tiene formato válido.");
      const sanitized = incoming
        .filter((item) => item && typeof item.name === "string" && typeof item.text === "string")
        .map((item) => ({ name: item.name.trim(), text: item.text.trim() }))
        .filter((item) => item.name && item.text);
      if (!sanitized.length) {
        log("No encontré progresiones válidas en el archivo.", "WARN");
        return;
      }
      const list = getSavedProgressions();
      const map = new Map(list.map((item) => [item.name.toLowerCase(), item]));
      for (const item of sanitized) {
        map.set(item.name.toLowerCase(), { ...item, updatedAt: new Date().toISOString() });
      }
      const merged = [...map.values()].sort((a, b) => a.name.localeCompare(b.name, "es"));
      writeSavedProgressions(merged);
      renderSavedProgressions(merged);
      log(`Importadas ${sanitized.length} progresiones.`, "OK");
    } catch (err) {
      log(`No pude importar: ${String(err?.message || err)}`, "ERROR");
    }
  };

  const clearLog = () => {
    if (logEl) logEl.textContent = "";
  };

  const setReady = (ready, text) => {
    if (ready) {
      dotReady.classList.remove("bad");
      dotReady.classList.add("ok");
    } else {
      dotReady.classList.remove("ok");
      dotReady.classList.add("bad");
    }
    readyText.textContent = text;
  };

  const normalizeAccidentals = (s) => s.replaceAll("♭","b").replaceAll("♯","#");

  const normalizeQuality = (q) => {
    let s = (q || "").trim();
    s = normalizeAccidentals(s);
    return s || null;
  };

  const getLoopVariant = (fullName) => {
    if (!fullName) return null;
    const base = fullName.replace(/\.[^.]+$/, "");
    if (!/loop/i.test(base)) return null;
    if (/loop2/i.test(base)) return "alt";
    return "base";
  };

  const isLoopFileName = (fullName) => getLoopVariant(fullName) !== null;

  const parseLoopInstrumentName = (fullName) => {
    if (!fullName) return "";
    const base = fullName.replace(/\.[^.]+$/, "");
    const parts = base.split(/__|_|\s+|-/).map((part) => part.trim()).filter(Boolean);
    const filtered = parts.filter((part) => !/loop/i.test(part));
    return filtered.join(" ").trim();
  };

  const scaleCurve = (curve, scale) => {
    if (scale === 1) return curve;
    const out = new Float32Array(curve.length);
    for (let i = 0; i < curve.length; i += 1) {
      out[i] = curve[i] * scale;
    }
    return out;
  };

  const parseChordToken = (tokRaw) => {
    const tok = normalizeAccidentals(tokRaw.trim());
    const m = tok.match(/^([A-Ga-g])([#b]?)(.*)$/);
    if (!m) throw new Error(`No entiendo el acorde: "${tokRaw}"`);
    const root = (m[1].toUpperCase() + (m[2]||"")).toUpperCase();
    const qualRaw = (m[3]||"").trim();
    const qualKey = normalizeQuality(qualRaw);
    if (!qualKey) throw new Error(`Calidad faltante en "${tokRaw}". Ej: Dm7, G9, A7alt, Cmaj7.`);
    const rootSemi = NOTE_TO_SEMI.get(root.toUpperCase());
    if (rootSemi === undefined) throw new Error(`Fundamental inválida: "${root}"`);
    return { root, rootSemi, quality: qualKey, token: tokRaw };
  };

  const getTimeSignature = () => {
    const raw = timeSignatureInput.value || "4/4";
    const [numRaw, denRaw] = raw.split("/");
    const num = Math.max(1, parseInt(numRaw, 10) || 4);
    const den = Math.max(1, parseInt(denRaw, 10) || 4);
    return { num, den };
  };

  const getEighthsPerBar = () => {
    const { num, den } = getTimeSignature();
    const eighths = Math.round((num * 8) / den);
    return Math.max(1, eighths);
  };

  const durationsForBar = (chordCount, eighthsPerBar) => {
    if (eighthsPerBar === 8) {
      if (chordCount === 1) return [8];
      if (chordCount === 2) return [4, 4];
      if (chordCount === 3) return [4, 2, 2];
      return [2, 2, 2, 2];
    }
    const base = Math.floor(eighthsPerBar / chordCount);
    let remainder = eighthsPerBar % chordCount;
    return Array.from({ length: chordCount }, () => {
      const extra = remainder > 0 ? 1 : 0;
      remainder = Math.max(0, remainder - 1);
      return base + extra;
    });
  };

  const tokenizeBarsWithLoops = (raw) => {
    const bars = [];
    let current = "";
    let pendingLoopStart = false;
    let pendingLoopSwitch = false;
    const flush = ({ loopEnd = false } = {}) => {
      const trimmed = current.trim();
      if (!trimmed) {
        current = "";
        return;
      }
      bars.push({
        text: trimmed,
        loopStart: pendingLoopStart,
        loopEnd,
        loopSwitch: pendingLoopSwitch,
      });
      pendingLoopStart = false;
      pendingLoopSwitch = false;
      current = "";
    };

    const re = /(\|\|:|:\|\||\|\||\|)/g;
    let lastIndex = 0;
    let match;
    while ((match = re.exec(raw)) !== null) {
      current += raw.slice(lastIndex, match.index);
      const token = match[1];
      if (token === "||:") {
        flush();
        pendingLoopStart = true;
      } else if (token === ":||") {
        if (current.trim()) {
          flush({ loopEnd: true });
        } else if (bars.length) {
          bars[bars.length - 1].loopEnd = true;
          pendingLoopStart = false;
          current = "";
        } else {
          throw new Error("Marcador :|| sin barra previa.");
        }
      } else if (token === "||") {
        flush();
        pendingLoopSwitch = !pendingLoopSwitch;
      } else {
        flush();
      }
      lastIndex = re.lastIndex;
    }
    current += raw.slice(lastIndex);
    flush();

    if (pendingLoopStart) {
      throw new Error("Marcador ||: sin cierre :||.");
    }

    return bars;
  };

  const expandLoopBars = (bars) => {
    const out = [];
    let loopStartIndex = null;
    for (const bar of bars) {
      if (bar.loopStart) {
        if (loopStartIndex !== null) {
          throw new Error("No se permiten loops anidados.");
        }
        loopStartIndex = out.length;
      }
      out.push({ ...bar, loopStart: false, loopEnd: false });
      if (bar.loopEnd) {
        if (loopStartIndex === null) {
          throw new Error("Marcador :|| sin ||:.");
        }
        const repeat = out.slice(loopStartIndex).map((item) => ({
          ...item,
          loopStart: false,
          loopEnd: false,
        }));
        out.push(...repeat);
        loopStartIndex = null;
      }
    }
    if (loopStartIndex !== null) {
      throw new Error("Marcador ||: sin cierre :||.");
    }
    return out;
  };

  const extractClavePrefix = (text) => {
    const match = (text || "").match(/^\s*(2-3|3-2)\s*/);
    if (!match) return { claveMode: "none", strippedText: text || "" };
    return {
      claveMode: match[1],
      strippedText: (text || "").slice(match[0].length),
    };
  };

  const parseProgression = (text, opts = {}) => {
    const { maxChordsPerBar = 4, applyClaveAnticipations: applyClave = true } = opts;
    const { claveMode, strippedText } = extractClavePrefix(text.replace(/\r/g, ""));
    const raw = strippedText.trim();
    if (!raw) throw new Error("Escribe una progresión.");
    const parts = expandLoopBars(tokenizeBarsWithLoops(raw));
    if (!parts.length) throw new Error("Usa barras | |. Ej: | Bbmaj7 Gm9 | ...");

    const segments = [];
    const bars = [];
    let startEighth = 0;
    let lastBarDef = null;
    const eighthsPerBar = getEighthsPerBar();

    const addMuteBar = (muteType, source = "", barIndex = 0, loopSwitch = false) => {
      const token = muteType === "all" ? "-" : "/";
      segments.push({
        type: "mute",
        muteType,
        startEighth,
        durEighth: eighthsPerBar,
        barIndex,
        barChordCount: 0,
        barChordIndex: 0,
        token,
      });
      bars.push({
        barIndex,
        muteType,
        loopSwitch,
        tokens: [{ text: token, isMute: true }],
      });
      startEighth += eighthsPerBar;
      lastBarDef = { type: "mute", muteType };
    };

    const addBar = (barChords, source = "", barIndex = 0, loopSwitch = false) => {
      if (!barChords || !barChords.length) {
        throw new Error(`Barra inválida: "${source || ""}". Solo 1 a ${maxChordsPerBar} acordes por compás.`);
      }
      if (barChords.length < 1 || barChords.length > maxChordsPerBar) {
        throw new Error(`Barra inválida: "${source || barChords.join(" ")}". Solo 1 a ${maxChordsPerBar} acordes por compás.`);
      }

      const chordCount = barChords.length;
      const durations = durationsForBar(chordCount, eighthsPerBar);
      const tokens = [];

      let barEighthOffset = 0;
      for (const [idx, c] of barChords.entries()) {
        const parsed = parseChordToken(c);
        segments.push({
          type: "chord",
          ...parsed,
          startEighth,
          durEighth: durations[idx],
          barIndex,
          barChordCount: chordCount,
          barChordIndex: idx,
          barEighthOffset,
        });
        startEighth += durations[idx];
        barEighthOffset += durations[idx];
        tokens.push({ text: parsed.token || c, quality: parsed.quality, isMute: false });
      }

      bars.push({
        barIndex,
        muteType: null,
        loopSwitch,
        tokens,
      });
      lastBarDef = { type: "chord", chords: barChords };
    };

    for (const [barIndex, bar] of parts.entries()) {
      const rawBar = bar.text || "";
      const loopSwitch = !!bar.loopSwitch;
      if (rawBar === "%") {
        if (!lastBarDef) throw new Error("El signo % solo se puede usar después del primer compás.");
        if (lastBarDef.type === "mute") {
          addMuteBar(lastBarDef.muteType, rawBar, barIndex, loopSwitch);
        } else {
          addBar(lastBarDef.chords, rawBar, barIndex, loopSwitch);
        }
        continue;
      }
      if (rawBar === "/" || rawBar === "-") {
        addMuteBar(rawBar === "-" ? "all" : "instruments", rawBar, barIndex, loopSwitch);
        continue;
      }
      const chords = rawBar.split(/\s+/).map((s) => s.trim()).filter(Boolean);
      if (chords.length === 1 && (chords[0] === "/" || chords[0] === "-")) {
        addMuteBar(chords[0] === "-" ? "all" : "instruments", rawBar, barIndex, loopSwitch);
        continue;
      }
      addBar(chords, rawBar, barIndex, loopSwitch);
    }

    if (applyClave) {
      applyClaveAnticipations(segments, eighthsPerBar, claveMode);
    }

    const totalEighth = parts.length * eighthsPerBar;
    normalizeSegmentDurations(segments, totalEighth);

    return { segments, totalEighth, totalBars: parts.length, bars, claveMode };
  };

  const repeatProgressionText = (text, times) => {
    const t = Math.max(1, parseInt(times, 10) || 1);
    const base = (text || "").trim();
    if (t === 1 || !base) return text;
    const { claveMode, strippedText } = extractClavePrefix(base);
    const cleaned = strippedText.trim();
    const repeated = Array.from({ length: t }, () => cleaned).join(" ");
    if (claveMode === "none") return repeated;
    return `${claveMode} ${repeated}`.trim();
  };

  const getBarsPerFile = () => Math.max(1, parseInt(barsPerFileInput.value, 10) || 1);
  const getBarsPerChord = () => Math.max(1, parseInt(barsPerChordInput.value, 10) || 1);
  const getRefBpm = () => Math.max(20, parseInt(refBpmInput.value, 10) || 90);
  const getCrossfadeSeconds = () => LOOP_CROSSFADE_SEC;
  const getLoopBars = () => Math.max(1, parseInt(loopBarsInput?.value, 10) || 1);
  const buildLoopSetsForBars = (bars, baseSet, altSet) => {
    const baseAvailable = baseSet?.length > 0;
    const altAvailable = altSet?.length > 0;
    let useAlt = !baseAvailable && altAvailable;
    const resolved = [];
    for (const bar of bars || []) {
      if (bar?.loopSwitch) useAlt = !useAlt;
      let selected = useAlt ? altSet : baseSet;
      if (!selected?.length) {
        selected = useAlt ? baseSet : altSet;
      }
      resolved.push(selected || []);
    }
    return resolved;
  };

  const findBpmInFolderName = (name) => {
    if (!name) return null;
    const match = name.match(/(\d+(?:[.,]\d+)?)\s*bpm\b/i);
    if (!match) return null;
    const parsed = parseFloat(match[1].replace(",", "."));
    if (!Number.isFinite(parsed)) return null;
    return parsed;
  };

  const applyFolderBpm = (name) => {
    if (!refBpmInput) return;
    const parsed = findBpmInFolderName(name);
    if (!Number.isFinite(parsed)) return;
    const clamped = Math.min(300, Math.max(20, parsed));
    refBpmInput.value = String(clamped);
    log(`BPM fijo detectado en carpeta: ${clamped}.`, "OK");
  };

  const sameChord = (a, b) => a && b && a.rootSemi === b.rootSemi && a.quality === b.quality;

  const applyClaveAnticipations = (segments, eighthsPerBar, claveMode) => {
    if (!segments.length || eighthsPerBar !== 8) return segments;
    if (claveMode !== "2-3" && claveMode !== "3-2") return segments;

    const byBar = new Map();
    for (const seg of segments) {
      if (seg.type !== "chord") continue;
      if (!byBar.has(seg.barIndex)) byBar.set(seg.barIndex, []);
      byBar.get(seg.barIndex).push(seg);
    }

    const sortedBars = [...byBar.keys()].sort((a, b) => a - b);
    for (let i = 0; i < sortedBars.length - 1; i += 2) {
      if (sortedBars[i + 1] !== sortedBars[i] + 1) continue;
      const barA = byBar.get(sortedBars[i]) || [];
      const barB = byBar.get(sortedBars[i + 1]) || [];
      const barAClave = claveMode === "2-3" ? "2" : "3";
      const barBClave = barAClave === "2" ? "3" : "2";

      const applyShift = (segment, shift) => {
        segment.startEighth = Math.max(0, segment.startEighth - shift);
      };

      const applyTwoSideShifts = (bar) => {
        applyShift(bar[0], 2);
        applyShift(bar[1], 1);
      };

      const applyThreeSideShifts = (bar) => {
        applyShift(bar[1], 1);
      };
      if (barA.length === 1 && barB.length === 1) {
        if (!sameChord(barA[0], barB[0])) {
          if (barAClave === "2") {
            applyShift(barA[0], 2);
          } else {
            applyShift(barB[0], 2);
          }
        }
      } else if (barA.length === 2 && barB.length === 2) {
        if (barAClave === "2") {
          applyTwoSideShifts(barA);
        } else {
          applyThreeSideShifts(barA);
        }
        if (barBClave === "2") {
          applyTwoSideShifts(barB);
        } else {
          applyThreeSideShifts(barB);
        }
      }
    }

    return segments;
  };

  const normalizeSegmentDurations = (segments, totalEighth) => {
    if (segments.length >= 2) {
      for (let i = 0; i < segments.length - 1; i++) {
        segments[i].durEighth = segments[i + 1].startEighth - segments[i].startEighth;
      }
      segments[segments.length - 1].durEighth = totalEighth - segments[segments.length - 1].startEighth;
      for (const s of segments) {
        s.durEighth = Math.max(1, s.durEighth);
      }
    }
  };

  const applyBassClaveAnticipations = (segments, eighthsPerBar, claveMode) => {
    if (!segments.length || eighthsPerBar !== 8) return segments;
    if (claveMode !== "2-3" && claveMode !== "3-2") return segments;

    const byBar = new Map();
    for (const seg of segments) {
      if (seg.type !== "chord") continue;
      if (!byBar.has(seg.barIndex)) byBar.set(seg.barIndex, []);
      byBar.get(seg.barIndex).push(seg);
    }

    const sortedBars = [...byBar.keys()].sort((a, b) => a - b);
    const applyShift = (segment, shift) => {
      segment.startEighth = Math.max(0, segment.startEighth - shift);
    };

    for (const barIndex of sortedBars) {
      const bar = byBar.get(barIndex) || [];
      if (bar.length !== 2 || bar[0].barChordCount !== 2) continue;

      const secondChord = bar.find((seg) => seg.barChordIndex === 1) || bar[1];
      if (secondChord) {
        applyShift(secondChord, 1);
      }

      const nextBar = byBar.get(barIndex + 1);
      if (!nextBar || !nextBar.length) continue;
      const firstChord = nextBar.find((seg) => seg.barChordIndex === 0) || nextBar[0];
      if (firstChord) {
        applyShift(firstChord, 2);
      }
    }

    return segments;
  };

  const buildRootBarStartMap = () => {
    const map = new Map();
    const startRoot = (startRootInput.value || "G").toUpperCase();
    const startSemi = NOTE_TO_SEMI.get(startRoot);
    if (startSemi == null) return map;
    const barsPerChord = getBarsPerChord();
    for (let i = 0; i < 12; i++) {
      const rootSemi = (startSemi + i) % 12;
      map.set(rootSemi, i * barsPerChord);
    }
    return map;
  };

  const getRefBarSeconds = () => {
    const { num, den } = getTimeSignature();
    const bpm = getRefBpm();
    return (60 / bpm) * num * (4 / den);
  };

  const getRefSecondsPerEighth = () => {
    const bpm = getRefBpm();
    return (60 / bpm) / 2;
  };

  const getClaveReferenceOffsetSeconds = (claveMode, barSeconds, barsPerChord) => {
    if (claveMode !== "3-2") return 0;
    if (barsPerChord < 2) return 0;
    return barSeconds;
  };
  const transposeRootLabel = (root, delta, preferFlat = false) => {
    const baseSemi = NOTE_TO_SEMI.get(root.toUpperCase());
    if (baseSemi == null) return root;
    const target = ((baseSemi + delta) % 12 + 12) % 12;
    const dict = preferFlat ? SEMI_TO_NOTE_FLAT : SEMI_TO_NOTE_SHARP;
    return dict[target] ?? root;
  };

  const transposeChordTokenText = (tok, delta) => {
    if (!delta) return tok;
    const normalized = normalizeAccidentals(tok.trim());
    const slashIndex = normalized.indexOf("/");
    const mainToken = slashIndex === -1 ? normalized : normalized.slice(0, slashIndex);
    const bassToken = slashIndex === -1 ? null : normalized.slice(slashIndex + 1);
    const m = mainToken.match(/^([A-Ga-g])([#b]?)(.*)$/);
    if (!m) return tok;
    const rootKey = (m[1].toUpperCase() + (m[2] || "")).toUpperCase();
    const preferFlat = m[2] === "b" || m[2] === "♭";
    if (!NOTE_TO_SEMI.has(rootKey)) return tok;
    const rest = m[3] || "";
    const newRoot = transposeRootLabel(rootKey, delta, preferFlat);
    let output = newRoot + rest;
    if (bassToken != null) {
      const bassMatch = bassToken.match(/^([A-Ga-g])([#b]?)(.*)$/);
      if (bassMatch) {
        const bassKey = (bassMatch[1].toUpperCase() + (bassMatch[2] || "")).toUpperCase();
        const preferFlatBass = bassMatch[2] === "b" || bassMatch[2] === "♭";
        if (NOTE_TO_SEMI.has(bassKey)) {
          const bassRest = bassMatch[3] || "";
          const newBass = transposeRootLabel(bassKey, delta, preferFlatBass);
          output += `/${newBass}${bassRest}`;
          return output;
        }
      }
      output += `/${bassToken}`;
    }
    return output;
  };

  const transposeProgressionSegment = (segment, delta) => (
    segment.replace(/\S+/g, (tok) => (tok === "%" ? tok : transposeChordTokenText(tok, delta)))
  );

  const transposeProgressionText = (text, delta) => {
    if (!delta) return text;
    const raw = text.replace(/\r/g, "");
    const re = /(\|\|:|:\|\||\|)/g;
    let lastIndex = 0;
    let out = "";
    let match;
    while ((match = re.exec(raw)) !== null) {
      const segment = raw.slice(lastIndex, match.index);
      out += transposeProgressionSegment(segment, delta);
      out += match[1];
      lastIndex = re.lastIndex;
    }
    out += transposeProgressionSegment(raw.slice(lastIndex), delta);
    return out;
  };

  const clampGlobalTranspose = () => {
    let n = parseInt(globalTranspose.value, 10);
    if (!Number.isFinite(n)) n = 0;
    n = Math.max(-24, Math.min(24, n));
    globalTranspose.value = String(n);
    return n;
  };

  const applyGlobalTranspose = () => {
    const desired = clampGlobalTranspose();
    const delta = desired - currentGlobalTranspose;
    if (delta === 0) return;
    prog.value = transposeProgressionText(prog.value, delta);
    currentGlobalTranspose = desired;
    updateQualityMismatch();
  };

  const insertAtCursor = (input, text) => {
    const start = input.selectionStart || 0;
    const end = input.selectionEnd || 0;
    const value = input.value;
    input.value = value.slice(0, start) + text + value.slice(end);
    const pos = start + text.length;
    input.selectionStart = input.selectionEnd = pos;
    input.focus();
  };

  const renderQualityChips = () => {
    qualityChips.innerHTML = "";
    if (!audioQualities.length) {
      const s = document.createElement("span");
      s.className = "mini";
      s.textContent = "Carga una carpeta de audio para ver las calidades disponibles.";
      qualityChips.appendChild(s);
      return;
    }
    for (const q of audioQualities) {
      const chip = document.createElement("button");
      chip.type = "button";
      chip.className = "pill";
      chip.textContent = q;
      chip.title = "Insertar calidad";
      chip.addEventListener("click", () => insertAtCursor(prog, q));
      qualityChips.appendChild(chip);
    }
  };

  const renderProgressionPreview = (parsed, parseError, missingSet) => {
    if (!progPreview) return;
    progPreview.innerHTML = "";
    const raw = prog.value.trim();
    if (!raw) {
      const empty = document.createElement("span");
      empty.className = "previewEmpty";
      empty.textContent = "Escribe una progresión para verla aquí.";
      progPreview.appendChild(empty);
      return;
    }
    if (parseError) {
      const errText = document.createElement("span");
      errText.className = "previewError";
      errText.textContent = `Progresión inválida: ${String(parseError?.message || parseError)}`;
      progPreview.appendChild(errText);
      return;
    }
    if (!parsed) return;

    const bars = parsed.bars || [];
    const claveMode = parsed.claveMode;
    bars.forEach((barInfo) => {
      const barRow = document.createElement("div");
      barRow.className = "barRow";
      const barStart = document.createElement("span");
      barStart.className = "barSep";
      barStart.textContent = "|";
      barRow.appendChild(barStart);

      for (const tokenInfo of barInfo.tokens || []) {
        const token = document.createElement("span");
        token.className = "chordToken";
        token.textContent = tokenInfo.text;
        if (tokenInfo.isMute) {
          token.classList.add("mute");
        } else if (missingSet && missingSet.has(tokenInfo.quality)) {
          token.classList.add("bad");
        }
        barRow.appendChild(token);
      }

      const barEnd = document.createElement("span");
      barEnd.className = "barSep";
      barEnd.textContent = "|";
      barRow.appendChild(barEnd);
      progPreview.appendChild(barRow);
    });
  };

  const updateQualityMismatch = () => {
    let parsed = null;
    let parseError = null;
    try {
      const repeatedText = repeatProgressionText(prog.value, repeatCount.value);
      parsed = parseProgression(repeatedText, { maxChordsPerBar: 4 });
    } catch (err) {
      parseError = err;
    }
    if (!audioFolderLoaded || !audioQualities.length) {
      qualityMismatchText.textContent = "Carga referencias de audio para validar calidades.";
      qualityMismatchDot.classList.remove("ok");
      qualityMismatchDot.classList.add("bad");
      renderProgressionPreview(parsed, parseError, null);
      return;
    }

    if (parseError) {
      qualityMismatchText.textContent = `Progresión inválida: ${String(parseError?.message || parseError)}`;
      qualityMismatchDot.classList.remove("ok");
      qualityMismatchDot.classList.add("bad");
      renderProgressionPreview(parsed, parseError, null);
      return;
    }

    try {
      const qualities = new Set(parsed.segments.filter((s) => s.type === "chord").map((s) => s.quality));
      const missing = [...qualities].filter((q) => !audioQualities.includes(q));
      const missingSet = new Set(missing);
      if (missing.length) {
        qualityMismatchText.textContent = `Faltan referencias para: ${missing.join(", ")}`;
        qualityMismatchDot.classList.remove("ok");
        qualityMismatchDot.classList.add("bad");
      } else {
        qualityMismatchText.textContent = "Todas las calidades están cubiertas por las referencias.";
        qualityMismatchDot.classList.remove("bad");
        qualityMismatchDot.classList.add("ok");
      }
      renderProgressionPreview(parsed, null, missingSet);
    } catch (err) {
      qualityMismatchText.textContent = `Progresión inválida: ${String(err?.message || err)}`;
      qualityMismatchDot.classList.remove("ok");
      qualityMismatchDot.classList.add("bad");
      renderProgressionPreview(parsed, err, null);
    }
  };

  const ensureAudioContext = () => {
    if (!audioCtx) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) throw new Error("AudioContext no disponible en este navegador.");
      const options = { latencyHint: "playback" };
      try {
        audioCtx = new Ctx(options);
      } catch (_) {
        audioCtx = new Ctx();
      }
    }
    return audioCtx;
  };

  const parseAudioFileName = (fullName) => {
    if (!fullName) return null;
    if (!/\.wav$/i.test(fullName)) return null;
    if (isLoopFileName(fullName)) return null;
    const base = fullName.replace(/\.[^.]+$/, "");
    let separator = "__";
    let splitIndex = base.lastIndexOf(separator);
    if (splitIndex < 0) {
      separator = "_";
      splitIndex = base.lastIndexOf(separator);
    }
    if (splitIndex < 0) return null;
    const qualityRaw = base.slice(0, splitIndex);
    const instrument = base.slice(splitIndex + separator.length).trim();
    if (!instrument) return null;
    const qualityKey = normalizeQuality(qualityRaw.trim());
    if (!qualityKey) return null;
    return { qualityKey, instrument };
  };

  const getLoopVolume = () => {
    const value = parseFloat(loopVolumeInput?.value ?? "0");
    if (!Number.isFinite(value)) return 0;
    return Math.max(0, Math.min(1, value));
  };

  const updateLoopControls = () => {
    const baseCount = baseLoopBuffers.length;
    const altCount = altLoopBuffers.length;
    const totalLoops = baseCount + altCount;
    if (loopVolumeValue) {
      loopVolumeValue.textContent = `${Math.round(getLoopVolume() * 100)}%`;
    }
    if (btnLoopToggle) {
      btnLoopToggle.textContent = loopEnabled ? "Loop base: ON" : "Loop base: OFF";
      btnLoopToggle.classList.toggle("bad", !loopEnabled);
      btnLoopToggle.classList.toggle("ghost", loopEnabled);
      btnLoopToggle.disabled = totalLoops === 0;
    }
    if (loopStatus) {
      if (!totalLoops) {
        loopStatus.textContent = "Sin loop cargado.";
      } else {
        loopStatus.textContent = `Loop base: ${baseCount} · Loop2: ${altCount}.`;
      }
    }
  };

  const getAnySolo = () => audioTracks.some((track) => track.solo);

  const getTrackEffectiveVolume = (track) => {
    if (track.mute) return 0;
    if (getAnySolo() && !track.solo) return 0;
    return Math.max(0, Math.min(1, track.volume));
  };

  const isBassInstrumentName = (name) => /contrabajo|bajo|bass/i.test(name || "");

  const updateMixerSummary = () => {
    if (!mixerSummary) return;
    const count = audioTracks.length;
    const soloActive = getAnySolo();
    mixerSummary.textContent = `${count} instrumento${count === 1 ? "" : "s"}${soloActive ? " · Solo activo" : ""}`;
  };

  const renderMixer = () => {
    if (!mixerGrid || !mixerEmpty) return;
    mixerGrid.innerHTML = "";
    const hasTracks = audioTracks.length > 0;
    mixerEmpty.style.display = hasTracks ? "none" : "block";
    if (!hasTracks) {
      updateMixerSummary();
      return;
    }

    for (const track of audioTracks) {
      const card = document.createElement("div");
      card.className = "mixerTrack";

      const title = document.createElement("div");
      title.className = "trackName";
      title.textContent = track.name;

      const sliderRow = document.createElement("div");
      sliderRow.className = "row";
      sliderRow.style.gap = "8px";
      sliderRow.style.alignItems = "center";

      const slider = document.createElement("input");
      slider.type = "range";
      slider.min = "0";
      slider.max = "1";
      slider.step = "0.01";
      slider.value = String(track.volume);

      const value = document.createElement("span");
      value.className = "trackValue";
      value.textContent = `${Math.round(track.volume * 100)}%`;

      slider.addEventListener("input", () => {
        const next = parseFloat(slider.value);
        track.volume = Number.isFinite(next) ? next : 0;
        value.textContent = `${Math.round(track.volume * 100)}%`;
      });

      sliderRow.appendChild(slider);
      sliderRow.appendChild(value);

      const panRow = document.createElement("div");
      panRow.className = "row";
      panRow.style.gap = "8px";
      panRow.style.alignItems = "center";

      const panLabel = document.createElement("span");
      panLabel.className = "trackValue";
      panLabel.textContent = "Pan";

      const panSlider = document.createElement("input");
      panSlider.type = "range";
      panSlider.min = "-1";
      panSlider.max = "1";
      panSlider.step = "0.01";
      panSlider.value = String(track.pan ?? 0);

      const panValue = document.createElement("span");
      panValue.className = "trackValue";
      const formatPanValue = (val) => {
        if (Math.abs(val) < 0.01) return "C";
        return val < 0 ? `L${Math.round(Math.abs(val) * 100)}%` : `R${Math.round(val * 100)}%`;
      };
      panValue.textContent = formatPanValue(track.pan ?? 0);

      panSlider.addEventListener("input", () => {
        const next = parseFloat(panSlider.value);
        track.pan = Number.isFinite(next) ? Math.max(-1, Math.min(1, next)) : 0;
        panValue.textContent = formatPanValue(track.pan);
      });

      panRow.appendChild(panLabel);
      panRow.appendChild(panSlider);
      panRow.appendChild(panValue);

      const buttons = document.createElement("div");
      buttons.className = "trackButtons";

      const soloBtn = document.createElement("button");
      soloBtn.type = "button";
      soloBtn.className = "btn sm ghost";
      soloBtn.textContent = "Solo";

      const muteBtn = document.createElement("button");
      muteBtn.type = "button";
      muteBtn.className = "btn sm ghost";
      muteBtn.textContent = "Mute";

      const syncButtons = () => {
        soloBtn.classList.toggle("purple", track.solo);
        soloBtn.classList.toggle("ghost", !track.solo);
        soloBtn.textContent = track.solo ? "Solo: ON" : "Solo";
        muteBtn.classList.toggle("bad", track.mute);
        muteBtn.classList.toggle("ghost", !track.mute);
        muteBtn.textContent = track.mute ? "Mute: ON" : "Mute";
        updateMixerSummary();
      };

      soloBtn.addEventListener("click", () => {
        track.solo = !track.solo;
        syncButtons();
      });

      muteBtn.addEventListener("click", () => {
        track.mute = !track.mute;
        syncButtons();
      });

      syncButtons();

      buttons.appendChild(soloBtn);
      buttons.appendChild(muteBtn);

      card.appendChild(title);
      card.appendChild(sliderRow);
      card.appendChild(panRow);
      card.appendChild(buttons);

      mixerGrid.appendChild(card);
    }

    updateMixerSummary();
  };

  const collectFoldersFromFileList = (list) => {
    const entries = list.map((file) => {
      const rel = file.webkitRelativePath || file._relativePath || file.name || "";
      const parts = rel.split("/").filter(Boolean);
      return { file, parts };
    });
    const rootNames = new Set(entries.map((entry) => entry.parts[0]).filter(Boolean));
    let useSecondLevel = false;
    if (rootNames.size === 1) {
      const secondLevel = new Set(
        entries
          .filter((entry) => entry.parts.length > 2)
          .map((entry) => entry.parts[1])
          .filter(Boolean)
      );
      useSecondLevel = secondLevel.size > 1;
    }

    const byFolder = new Map();
    for (const entry of entries) {
      const parts = entry.parts;
      const folderName = (useSecondLevel && parts.length > 2 ? parts[1] : parts[0]) || "carpeta";
      if (!byFolder.has(folderName)) byFolder.set(folderName, []);
      byFolder.get(folderName).push(entry.file);
    }
    return [...byFolder.entries()].map(([name, files]) => ({ name, files }));
  };

  const loadFolderViaPicker = async ({ allowMultiple = false } = {}) => {
    const pickViaFileInput = () => (
      new Promise((resolve, reject) => {
        const input = el("audioFolderFallback");
        input.multiple = allowMultiple;
        input.onchange = () => {
          const list = [...input.files];
          input.value = "";
          if (!list.length) {
            reject(new Error("No se encontraron archivos en esa carpeta."));
            return;
          }
          const folders = collectFoldersFromFileList(list);
          if (!folders.length) {
            reject(new Error("No se encontraron archivos en esa carpeta."));
            return;
          }
          if (folders.length > 1) {
            resolve(folders);
            return;
          }
          resolve(folders[0]);
        };
        input.click();
      })
    );

    if (window.showDirectoryPicker) {
      let dir;
      try {
        dir = await window.showDirectoryPicker();
      } catch (err) {
        if (err?.name === "AbortError") return null;
        throw err;
      }
      const collect = async (handle, prefix, acc) => {
        for await (const [, child] of handle.entries()) {
          if (child.kind === "file") {
            const file = await child.getFile();
            file._relativePath = `${prefix}${child.name}`;
            acc.push(file);
          } else if (child.kind === "directory") {
            await collect(child, `${prefix}${child.name}/`, acc);
          }
        }
      };
      const files = [];
      await collect(dir, `${dir.name}/`, files);
      const folders = collectFoldersFromFileList(files);
      if (!folders.length) return null;
      if (allowMultiple || folders.length > 1) {
        return folders;
      }
      return folders[0];
    }

    return await pickViaFileInput();
  };

  const updateReadyState = () => {
    audioFolderLoaded = audioTracks.length > 0 || baseLoopBuffers.length > 0 || altLoopBuffers.length > 0;
    setReady(audioFolderLoaded, audioFolderLoaded ? "Listo" : "No listo");
  };

  const renderAudioFolderStatus = () => {
    if (!audioFolderStatus) return;
    if (!audioTracks.length) {
      if (baseLoopBuffers.length || altLoopBuffers.length) {
        audioFolderStatus.textContent = `Sin instrumentos cargados. Loop base: ${baseLoopBuffers.length} · Loop2: ${altLoopBuffers.length}.`;
      } else {
        audioFolderStatus.textContent = "Sin instrumentos cargados.";
      }
      if (audioFolderList) audioFolderList.innerHTML = "";
      return;
    }
    const instrumentNames = audioTracks.map((track) => track.name);
    const loopSuffix = (baseLoopBuffers.length || altLoopBuffers.length)
      ? ` · Loop base: ${baseLoopBuffers.length} · Loop2: ${altLoopBuffers.length}`
      : "";
    audioFolderStatus.textContent = `Instrumentos cargados: ${instrumentNames.length}.${loopSuffix}`;
    if (audioFolderList) {
      audioFolderList.innerHTML = "";
      for (const name of instrumentNames) {
        const chip = document.createElement("span");
        chip.className = "folderChip";
        chip.textContent = name;
        audioFolderList.appendChild(chip);
      }
    }
  };

  const cleanupTrackResources = (track) => {
    if (!track) return;
    for (const url of track.urlsByQuality?.values() ?? []) {
      URL.revokeObjectURL(url);
    }
  };

  const resetAudioTracks = () => {
    for (const track of audioTracks) {
      for (const url of track.urlsByQuality.values()) {
        URL.revokeObjectURL(url);
      }
    }
    audioTracks = [];
    baseLoopBuffers = [];
    altLoopBuffers = [];
    audioQualities = [];
    referenceBpmFromFolder = null;
    renderQualityChips();
    renderMixer();
  };

  const addTrackFromFolder = async ({ folder, ctx }) => {
    let createdTracks = [];
    let newTracks = [];
    try {
      if (!folder.files?.length) {
        throw new Error("No se encontraron archivos en esa carpeta.");
      }

      const folderBpm = findBpmInFolderName(folder.name);
      const hasExisting = audioTracks.length > 0;

      if (hasExisting) {
        if (referenceBpmFromFolder != null) {
          if (!Number.isFinite(folderBpm)) {
            throw new Error("Todas las carpetas deben incluir el BPM en el nombre.");
          }
          if (Math.abs(folderBpm - referenceBpmFromFolder) > 0.01) {
            throw new Error("Las carpetas tienen BPM distintos. Usa el mismo BPM en todas.");
          }
        } else if (Number.isFinite(folderBpm)) {
          throw new Error("Las carpetas cargadas no tenían BPM. Usa el mismo formato en todas.");
        }

      } else {
        if (Number.isFinite(folderBpm)) {
          referenceBpmFromFolder = folderBpm;
          applyFolderBpm(folder.name);
        }
      }

      const skipped = [];
      const dups = [];
      const loopSkipped = [];
      const pendingLoops = { base: [], alt: [] };
      const tracksByInstrument = new Map();

      for (const f of folder.files) {
        const fullName = (f.name || "").trim();
        if (!fullName) { skipped.push("(sin nombre)"); continue; }
        const loopVariant = getLoopVariant(fullName);
        if (loopVariant) {
          if (!/\.wav$/i.test(fullName)) { skipped.push(fullName); continue; }
          try {
            const buf = await f.arrayBuffer();
            const audioBuf = await ctx.decodeAudioData(buf.slice(0));
            pendingLoops[loopVariant].push({ name: fullName, buffer: audioBuf });
          } catch (err) {
            loopSkipped.push(fullName);
          }
          continue;
        }
        const parsed = parseAudioFileName(fullName);
        if (!parsed) { skipped.push(fullName); continue; }
        const { qualityKey, instrument } = parsed;
        if (!tracksByInstrument.has(instrument)) {
          const trackId = trackIdCounter += 1;
          tracksByInstrument.set(instrument, {
            id: trackId,
            name: instrument || `Instrumento ${trackId}`,
            buffersByQuality: new Map(),
            urlsByQuality: new Map(),
            loopBuffers: [],
            volume: 0.6,
            pan: 0,
            mute: false,
            solo: false,
            qualities: [],
          });
        }
        const track = tracksByInstrument.get(instrument);
        if (track.buffersByQuality.has(qualityKey)) {
          dups.push(`${instrument}:${qualityKey}`);
          const oldUrl = track.urlsByQuality.get(qualityKey);
          if (oldUrl) URL.revokeObjectURL(oldUrl);
        }

        try {
          const buf = await f.arrayBuffer();
          const audioBuf = await ctx.decodeAudioData(buf.slice(0));
          track.buffersByQuality.set(qualityKey, audioBuf);
          const objectUrl = URL.createObjectURL(f);
          track.urlsByQuality.set(qualityKey, objectUrl);
        } catch (err) {
          skipped.push(fullName);
        }
      }

      newTracks = [...tracksByInstrument.values()];
      const pendingLoopCount = pendingLoops.base.length + pendingLoops.alt.length;
      if (!newTracks.length && !pendingLoopCount) {
        throw new Error(`No encontré WAVs válidos en la carpeta "${folder.name}".`);
      }

      if (pendingLoops.base.length) {
        for (const loop of pendingLoops.base) {
          baseLoopBuffers.push({ name: loop.name, buffer: loop.buffer });
        }
      }
      if (pendingLoops.alt.length) {
        for (const loop of pendingLoops.alt) {
          altLoopBuffers.push({ name: loop.name, buffer: loop.buffer });
        }
      }

      const referenceQualities = audioQualities.length ? [...audioQualities] : null;
      let resolvedQualities = referenceQualities;

      for (const track of newTracks) {
        track.qualities = [...new Set(track.buffersByQuality.keys())].sort((a, b) => a.localeCompare(b, "en"));
        if (!track.qualities.length) {
          throw new Error(`No encontré WAVs válidos para el instrumento "${track.name}".`);
        }

        if (!resolvedQualities) {
          resolvedQualities = [...track.qualities];
        } else {
          const missing = resolvedQualities.filter((q) => !track.qualities.includes(q));
          const extra = track.qualities.filter((q) => !resolvedQualities.includes(q));
          if (missing.length || extra.length) {
            const details = [
              missing.length ? `Faltan: ${missing.join(", ")}` : "",
              extra.length ? `Sobran: ${extra.join(", ")}` : "",
            ].filter(Boolean).join(" — ");
            throw new Error(`Las calidades de "${track.name}" no coinciden con las demás. ${details}`);
          }
        }

        const expectedSeconds = getBarsPerFile() * getRefBarSeconds();
        for (const [quality, buffer] of track.buffersByQuality.entries()) {
          if (buffer.duration + 0.1 < expectedSeconds) {
            log(`(${track.name}) "${quality}": duración corta (${buffer.duration.toFixed(2)}s). Esperaba ~${expectedSeconds.toFixed(2)}s.`, "WARN");
          }
        }

        log(`(${track.name}) Cargados ${track.qualities.length} WAV(s) de referencia.`, "OK");
      }

      if (!audioQualities.length && resolvedQualities) {
        audioQualities = resolvedQualities;
      }

      for (const track of newTracks) {
        audioTracks.push(track);
        createdTracks.push(track);
      }

      if (pendingLoopCount) {
        log(`Loops base: ${pendingLoops.base.length} · Loop2: ${pendingLoops.alt.length}.`, "OK");
      }
      if (skipped.length) {
        log(`Archivos ignorados (no WAV / nombre inválido): ${skipped.join(", ")}`, "WARN");
      }
      if (dups.length) {
        log(`Duplicados: se usó el último WAV para: ${[...new Set(dups)].join(", ")}`, "WARN");
      }
      if (loopSkipped.length) {
        log(`Loops ignorados (error al leer): ${loopSkipped.join(", ")}`, "WARN");
      }

      return createdTracks[createdTracks.length - 1] || null;
    } catch (err) {
      for (const track of createdTracks) {
        cleanupTrackResources(track);
      }
      for (const track of newTracks) {
        cleanupTrackResources(track);
      }
      throw err;
    }
  };

  const loadAudioFolder = async ({ reset = false, allowMultiple = false } = {}) => {
    const previousStatus = audioFolderStatus?.textContent || "";
    if (reset) {
      clearLog();
      resetAudioTracks();
    }

    const hasExisting = audioTracks.length > 0;
    if (audioFolderStatus) {
      audioFolderStatus.textContent = hasExisting && !reset ? "Añadiendo instrumentos…" : "Cargando…";
    }
    if (loopStatus && reset) loopStatus.textContent = "Cargando…";
    updateReadyState();
    if (reset) updateQualityMismatch();

    let loadedAny = false;
    try {
      const ctx = ensureAudioContext();
      const folderResult = await loadFolderViaPicker({ allowMultiple });
      if (!folderResult) {
        renderAudioFolderStatus();
        updateLoopControls();
        updateReadyState();
        return;
      }

      const folders = Array.isArray(folderResult) ? folderResult : [folderResult];
      for (const folder of folders) {
        try {
          await addTrackFromFolder({ folder, ctx });
          loadedAny = true;
        } catch (err) {
          log(String(err?.message || err), "ERROR");
        }
      }

      if (!loadedAny) {
        throw new Error("No se pudo cargar ninguna carpeta.");
      }

      renderQualityChips();
      renderMixer();
      updateQualityMismatch();
      updateLoopControls();
      renderAudioFolderStatus();
      updateReadyState();
    } catch (err) {
      if (reset && !loadedAny) {
        resetAudioTracks();
        if (audioFolderStatus) audioFolderStatus.textContent = "Error al cargar carpeta.";
      } else if (audioFolderStatus) {
        audioFolderStatus.textContent = previousStatus || audioFolderStatus.textContent;
      }
      if (!loadedAny) {
        log(String(err?.message || err), "ERROR");
      }
      if (loadedAny) {
        renderQualityChips();
        renderMixer();
        updateQualityMismatch();
        renderAudioFolderStatus();
      }
      updateLoopControls();
      updateReadyState();
    }
  };

  const stopAudioPlayback = () => {
    isAudioPlaying = false;
    if (playbackLoopTimer) {
      clearTimeout(playbackLoopTimer);
      playbackLoopTimer = null;
    }
    for (const t of audioTimers) {
      clearTimeout(t);
    }
    audioTimers = [];
    for (const node of audioNodes) {
      try {
        node.source?.stop();
      } catch (_) {}
      try {
        node.source?.disconnect();
        node.gain?.disconnect();
        node.panner?.disconnect();
      } catch (_) {}
    }
    audioNodes = [];
  };

  const scheduleAudioChord = ({
    ctx,
    buffer,
    startTime,
    endTime,
    bufferOffset,
    trackNodes = true,
    gainValue = 1,
    panValue = 0,
    fadeInSec = null,
    fadeOutSec = null,
  }) => {
    if (!buffer) return;
    const source = ctx.createBufferSource();
    source.buffer = buffer;

    const gain = ctx.createGain();
    gain.gain.value = 0;
    let panner = null;
    if (typeof ctx.createStereoPanner === "function") {
      panner = ctx.createStereoPanner();
      panner.pan.value = Math.max(-1, Math.min(1, panValue));
      source.connect(gain).connect(panner).connect(ctx.destination);
    } else {
      source.connect(gain).connect(ctx.destination);
    }

    const duration = Math.max(0, endTime - startTime);
    const safeOffset = Math.max(0, Math.min(buffer.duration - 0.002, bufferOffset));
    const maxPlayable = Math.max(0, buffer.duration - safeOffset);
    const playDuration = Math.min(duration, maxPlayable);
    if (playDuration <= 0) return;

    const baseFade = Math.max(MIN_FADE_SEC, getCrossfadeSeconds());
    const attackRequest = fadeInSec == null ? baseFade : Math.max(0, fadeInSec);
    const releaseRequest = fadeOutSec == null ? baseFade : Math.max(0, fadeOutSec);
    const maxFade = Math.max(MIN_FADE_SEC, playDuration / 2);
    const attack = Math.min(attackRequest, maxFade);
    const release = Math.min(releaseRequest, maxFade);
    const effectiveEnd = startTime + playDuration;
    const sustainStart = startTime + attack;
    const releaseStart = Math.max(sustainStart, effectiveEnd - release);

    gain.gain.setValueAtTime(0, startTime);
    if (attack > 0) {
      gain.gain.setValueCurveAtTime(scaleCurve(FADE_IN_CURVE, gainValue), startTime, attack);
    } else {
      gain.gain.setValueAtTime(gainValue, startTime);
    }
    if (effectiveEnd > sustainStart) {
      gain.gain.setValueAtTime(gainValue, releaseStart);
    }
    if (release > 0) {
      gain.gain.setValueCurveAtTime(scaleCurve(FADE_OUT_CURVE, gainValue), releaseStart, release);
    } else {
      gain.gain.setValueAtTime(0, effectiveEnd);
    }

    source.start(startTime, safeOffset, playDuration);
    source.stop(effectiveEnd + release + RELEASE_TAIL_SEC);

    if (trackNodes) {
      audioNodes.push({ source, gain, panner });
    }
  };

  const buildAudioSegments = () => {
    const repeatedText = repeatProgressionText(prog.value, repeatCount.value);
    const parsed = parseProgression(repeatedText, { maxChordsPerBar: 4 });
    let bassSegments = parsed.segments;
    if (parsed.claveMode === "2-3" || parsed.claveMode === "3-2") {
      const baseParsed = parseProgression(repeatedText, {
        maxChordsPerBar: 4,
        applyClaveAnticipations: false,
      });
      bassSegments = applyBassClaveAnticipations(
        baseParsed.segments,
        getEighthsPerBar(),
        baseParsed.claveMode,
      );
      normalizeSegmentDurations(bassSegments, baseParsed.totalEighth);
    }
    return {
      segments: parsed.segments,
      bassSegments,
      bars: parsed.bars,
      totalEighth: parsed.totalEighth,
      claveMode: parsed.claveMode,
    };
  };

  const scheduleLoopLayer = ({
    ctx,
    baseTime,
    totalEighth,
    totalBars,
    secPerEighth,
    barSeconds,
    trackNodes,
    loopBuffersByBar,
    loopGain,
    panValue,
    mutedBars = new Set(),
    claveMode = "none",
  }) => {
    const hasAnyLoops = (loopBuffersByBar || []).some((set) => set && set.length);
    if (!loopEnabled || !hasAnyLoops) return;
    const loopVolume = getLoopVolume();
    if (loopVolume <= 0) return;
    const effectiveLoopGain = loopVolume * Math.max(0, Math.min(1, loopGain ?? 1));
    if (effectiveLoopGain <= 0) return;
    const barTotal = totalBars ?? Math.ceil(totalEighth / getEighthsPerBar());
    const loopBars = getLoopBars();
    const overlapSec = LOOP_CROSSFADE_SEC;
    for (let bar = 0; bar < barTotal; bar += 1) {
      if (mutedBars.has(bar)) continue;
      const loopSet = loopBuffersByBar?.[bar] || [];
      if (!loopSet.length) continue;
      const startTime = baseTime + bar * barSeconds;
      const loopBarIndex = loopBars > 0 ? bar % loopBars : bar;
      const claveOffsetSeconds = claveMode === "3-2" ? barSeconds : 0;
      for (const loop of loopSet) {
        const duration = Math.max(loop.buffer.duration, 0.001);
        const bufferOffset = (loopBarIndex * barSeconds + claveOffsetSeconds) % duration;
        const safeOffset = Math.max(0, Math.min(loop.buffer.duration - 0.002, bufferOffset));
        const maxPlayable = Math.max(0, loop.buffer.duration - safeOffset);
        const useOverlap = maxPlayable >= barSeconds + overlapSec;
        const endTime = startTime + (useOverlap ? barSeconds + overlapSec : barSeconds);
        const fadeInSec = useOverlap ? overlapSec : LOOP_FADE_NO_OVERLAP_SEC;
        const fadeOutSec = useOverlap ? overlapSec : LOOP_FADE_NO_OVERLAP_SEC;
        scheduleAudioChord({
          ctx,
          buffer: loop.buffer,
          startTime,
          endTime,
          bufferOffset,
          trackNodes,
          gainValue: effectiveLoopGain,
          panValue,
          fadeInSec,
          fadeOutSec,
        });
      }
    }
  };

  const playAudio = async () => {
    if (!audioTracks.length && !baseLoopBuffers.length && !altLoopBuffers.length) {
      log("Carga carpetas de WAVs para reproducir.", "ERROR");
      return;
    }
    let parsed;
    try {
      parsed = buildAudioSegments();
    } catch (err) {
      log(String(err?.message || err), "ERROR");
      updateQualityMismatch();
      return;
    }

    const segments = parsed.segments;
    const bassSegments = parsed.bassSegments || segments;
    const bars = parsed.bars || [];
    const claveMode = parsed.claveMode;
    if (!segments.length) {
      log("No hay acordes para reproducir.", "ERROR");
      return;
    }

    const rootBarMap = buildRootBarStartMap();
    const barsPerChord = getBarsPerChord();
    const eighthsPerBar = getEighthsPerBar();
    const segmentEighths = eighthsPerBar * barsPerChord;
    const tracks = audioTracks;

    for (const seg of segments) {
      if (seg.type !== "chord") continue;
      if (!rootBarMap.has(seg.rootSemi)) {
        log(`Fundamental inválida para audio: ${seg.root}.`, "ERROR");
        return;
      }
    }
    for (const track of tracks) {
      for (const seg of segments) {
        if (seg.type !== "chord") continue;
        if (!track.buffersByQuality.has(seg.quality)) {
          log(`(${track.name}) No tengo WAV para la calidad "${seg.quality}".`, "ERROR");
          return;
        }
      }
    }

    stopAudioPlayback();
    isAudioPlaying = true;

    const ctx = ensureAudioContext();
    const secPerEighth = getRefSecondsPerEighth();
    const barSeconds = getRefBarSeconds();
    const baseTime = ctx.currentTime + PLAYBACK_SCHEDULE_AHEAD_SEC;
    const loopAudible = loopEnabled && (baseLoopBuffers.length || altLoopBuffers.length) && getLoopVolume() > 0;
    const hasChordSegments = segments.some((seg) => seg.type === "chord");
    const anyTrackAudible = hasChordSegments && tracks.some((track) => getTrackEffectiveVolume(track) > 0);
    const anyAudible = anyTrackAudible || loopAudible;
    if (!anyAudible) {
      log("Todos los instrumentos están en mute/solo silencioso.", "WARN");
      isAudioPlaying = false;
      return;
    }

    const mutedBars = new Set(
      (bars || []).filter((bar) => bar.muteType === "all").map((bar) => bar.barIndex),
    );

    const loopBuffersByBar = buildLoopSetsForBars(bars, baseLoopBuffers, altLoopBuffers);
    scheduleLoopLayer({
      ctx,
      baseTime,
      totalEighth: parsed.totalEighth,
      totalBars: bars.length,
      secPerEighth,
      barSeconds,
      trackNodes: true,
      loopBuffersByBar,
      loopGain: 1,
      panValue: 0,
      mutedBars,
      claveMode,
    });

    for (const track of tracks) {
      const trackGain = getTrackEffectiveVolume(track);
      if (trackGain <= 0) continue;

      const trackSegments = isBassInstrumentName(track.name) ? bassSegments : segments;
      for (const seg of trackSegments) {
        if (seg.type !== "chord") continue;
        const buffer = track.buffersByQuality.get(seg.quality);
        const rootBarStart = rootBarMap.get(seg.rootSemi);
        const offsetEighthInSegment = ((seg.barIndex % barsPerChord) * eighthsPerBar) + (seg.barEighthOffset || 0);
        const offsetSeconds = offsetEighthInSegment * secPerEighth;
        const loopStart = rootBarStart * barSeconds;

        const startTime = baseTime + seg.startEighth * secPerEighth;
        const endTime = startTime + seg.durEighth * secPerEighth;
        const chordDurationSeconds = Math.max(barSeconds * barsPerChord, 0.001);
        const baseOffset = offsetSeconds;
        const claveOffsetSeconds = getClaveReferenceOffsetSeconds(claveMode, barSeconds, barsPerChord);
        const shiftedOffset = (baseOffset + claveOffsetSeconds) % chordDurationSeconds;
        const bufferOffset = loopStart + shiftedOffset;

        scheduleAudioChord({
          ctx,
          buffer,
          startTime,
          endTime,
          bufferOffset,
          trackNodes: true,
          gainValue: trackGain,
          panValue: track.pan ?? 0,
        });
      }
    }

    const playbackDurationSec = parsed.totalEighth * secPerEighth;
    const doneTimer = setTimeout(() => {
      isAudioPlaying = false;
    }, playbackDurationSec * 1000);
    audioTimers.push(doneTimer);
    playbackLoopTimer = null;
    log("Playback iniciado.", "OK");
  };

  const encodeWavFromBuffer = (buffer) => {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const length = buffer.length;
    const bytesPerSample = 4;
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = length * blockAlign;
    const bufferSize = 44 + dataSize;
    const wavBuffer = new ArrayBuffer(bufferSize);
    const view = new DataView(wavBuffer);

    const writeString = (offset, str) => {
      for (let i = 0; i < str.length; i += 1) {
        view.setUint8(offset + i, str.charCodeAt(i));
      }
    };

    writeString(0, "RIFF");
    view.setUint32(4, 36 + dataSize, true);
    writeString(8, "WAVE");
    writeString(12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 3, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bytesPerSample * 8, true);
    writeString(36, "data");
    view.setUint32(40, dataSize, true);

    const channelData = [];
    for (let ch = 0; ch < numChannels; ch += 1) {
      channelData.push(buffer.getChannelData(ch));
    }

    let offset = 44;
    for (let i = 0; i < length; i += 1) {
      for (let ch = 0; ch < numChannels; ch += 1) {
        const sample = Math.max(-1, Math.min(1, channelData[ch][i]));
        view.setFloat32(offset, sample, true);
        offset += bytesPerSample;
      }
    }

    return wavBuffer;
  };

  const exportAudio = async () => {
    if (!audioTracks.length && !baseLoopBuffers.length && !altLoopBuffers.length) {
      log("Carga carpetas de WAVs para exportar audio.", "ERROR");
      return;
    }
    let parsed;
    try {
      parsed = buildAudioSegments();
    } catch (err) {
      log(String(err?.message || err), "ERROR");
      updateQualityMismatch();
      return;
    }

    const segments = parsed.segments;
    const bassSegments = parsed.bassSegments || segments;
    const bars = parsed.bars || [];
    const claveMode = parsed.claveMode;
    if (!segments.length) {
      log("No hay acordes para exportar.", "ERROR");
      return;
    }

    const rootBarMap = buildRootBarStartMap();
    const barsPerChord = getBarsPerChord();
    const eighthsPerBar = getEighthsPerBar();
    const segmentEighths = eighthsPerBar * barsPerChord;
    const tracks = audioTracks;

    for (const seg of segments) {
      if (seg.type !== "chord") continue;
      if (!rootBarMap.has(seg.rootSemi)) {
        log(`Fundamental inválida para audio: ${seg.root}.`, "ERROR");
        return;
      }
    }

    for (const track of tracks) {
      for (const seg of segments) {
        if (seg.type !== "chord") continue;
        if (!track.buffersByQuality.has(seg.quality)) {
          log(`(${track.name}) No tengo WAV para la calidad "${seg.quality}".`, "ERROR");
          return;
        }
      }
    }

    const allBuffers = tracks.flatMap((track) => [...track.buffersByQuality.values()]);
    const sampleRate = allBuffers[0]?.sampleRate || 44100;
    const numChannels = Math.max(1, ...allBuffers.map((buf) => buf.numberOfChannels || 1));
    const secPerEighth = getRefSecondsPerEighth();
    const totalDuration = parsed.totalEighth * secPerEighth;
    const renderLength = Math.ceil((totalDuration + 0.4) * sampleRate);
    const offlineCtx = new OfflineAudioContext(numChannels, renderLength, sampleRate);

    log("Renderizando audio en segundo plano…", "OK");

    const barSeconds = getRefBarSeconds();

    const loopAudible = loopEnabled && (baseLoopBuffers.length || altLoopBuffers.length) && getLoopVolume() > 0;
    const hasChordSegments = segments.some((seg) => seg.type === "chord");
    const anyTrackAudible = hasChordSegments && tracks.some((track) => getTrackEffectiveVolume(track) > 0);
    const anyAudible = anyTrackAudible || loopAudible;
    if (!anyAudible) {
      log("Todos los instrumentos están en mute/solo silencioso.", "WARN");
      return;
    }

    const mutedBars = new Set(
      (bars || []).filter((bar) => bar.muteType === "all").map((bar) => bar.barIndex),
    );

    const loopBuffersByBar = buildLoopSetsForBars(bars, baseLoopBuffers, altLoopBuffers);
    scheduleLoopLayer({
      ctx: offlineCtx,
      baseTime: 0,
      totalEighth: parsed.totalEighth,
      totalBars: bars.length,
      secPerEighth,
      barSeconds,
      trackNodes: false,
      loopBuffersByBar,
      loopGain: 1,
      panValue: 0,
      mutedBars,
      claveMode,
    });

    for (const track of tracks) {
      const trackGain = getTrackEffectiveVolume(track);
      if (trackGain <= 0) continue;

      const trackSegments = isBassInstrumentName(track.name) ? bassSegments : segments;
      for (const seg of trackSegments) {
        if (seg.type !== "chord") continue;
        const buffer = track.buffersByQuality.get(seg.quality);
        const rootBarStart = rootBarMap.get(seg.rootSemi);
        const offsetEighthInSegment = ((seg.barIndex % barsPerChord) * eighthsPerBar) + (seg.barEighthOffset || 0);
        const offsetSeconds = offsetEighthInSegment * secPerEighth;
        const loopStart = rootBarStart * barSeconds;

        const startTime = seg.startEighth * secPerEighth;
        const endTime = startTime + seg.durEighth * secPerEighth;
        const chordDurationSeconds = Math.max(barSeconds * barsPerChord, 0.001);
        const baseOffset = offsetSeconds;
        const claveOffsetSeconds = getClaveReferenceOffsetSeconds(claveMode, barSeconds, barsPerChord);
        const shiftedOffset = (baseOffset + claveOffsetSeconds) % chordDurationSeconds;
        const bufferOffset = loopStart + shiftedOffset;

        scheduleAudioChord({
          ctx: offlineCtx,
          buffer,
          startTime,
          endTime,
          bufferOffset,
          trackNodes: false,
          gainValue: trackGain,
          panValue: track.pan ?? 0,
        });
      }
    }

    let rendered;
    try {
      rendered = await offlineCtx.startRendering();
    } catch (err) {
      log(`Error al renderizar WAV: ${String(err?.message || err)}`, "ERROR");
      return;
    }

    const wavBuffer = encodeWavFromBuffer(rendered);
    const blob = new Blob([wavBuffer], { type: "audio/wav" });
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement("a");
    anchor.href = url;
    anchor.download = `referencia_${getRefBpm()}bpm.wav`;
    document.body.appendChild(anchor);
    anchor.click();
    anchor.remove();
    URL.revokeObjectURL(url);
    log(`Exportado audio: ${anchor.download}`, "OK");
  };

  const btnHelp = el("btnHelp");
  const btnHelpClose = el("btnHelpClose");
  const helpModal = el("helpModal");
  const menuButtons = [...document.querySelectorAll("[data-menu-target]")];
  const menuGroups = [...document.querySelectorAll(".menuGroup")];

  const getDragInsertTarget = (container, x, y) => {
    const items = [...container.querySelectorAll(":scope > [data-draggable-item]:not(.dragging)")];
    if (!items.length) return null;
    let closest = null;
    let closestDistance = Number.POSITIVE_INFINITY;
    for (const item of items) {
      const rect = item.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const distance = Math.hypot(x - centerX, y - centerY);
      if (distance < closestDistance) {
        closestDistance = distance;
        closest = item;
      }
    }
    if (!closest) return null;
    const rect = closest.getBoundingClientRect();
    const midpointY = rect.top + rect.height / 2;
    const midpointX = rect.left + rect.width / 2;
    const before = y < midpointY || (Math.abs(y - midpointY) < rect.height / 5 && x < midpointX);
    return before ? closest : closest.nextElementSibling;
  };

  const initDraggableContainers = () => {
    document.querySelectorAll("[data-draggable-container]").forEach((container) => {
      const getItems = () => [...container.querySelectorAll(":scope > [data-draggable-item]")];
      getItems().forEach((item) => {
        item.setAttribute("draggable", "true");
        item.addEventListener("dragstart", (event) => {
          item.classList.add("dragging");
          event.dataTransfer.effectAllowed = "move";
          event.dataTransfer.setData("text/plain", "");
        });
        item.addEventListener("dragend", () => {
          item.classList.remove("dragging");
          getItems().forEach((panel) => panel.classList.remove("drag-target"));
        });
        item.addEventListener("dragenter", () => {
          if (!item.classList.contains("dragging")) {
            item.classList.add("drag-target");
          }
        });
        item.addEventListener("dragleave", () => {
          item.classList.remove("drag-target");
        });
      });
      container.addEventListener("dragover", (event) => {
        event.preventDefault();
        const dragging = container.querySelector(":scope > .dragging");
        if (!dragging) return;
        const insertBefore = getDragInsertTarget(container, event.clientX, event.clientY);
        if (!insertBefore) {
          container.appendChild(dragging);
        } else {
          container.insertBefore(dragging, insertBefore);
        }
      });
      container.addEventListener("drop", (event) => {
        event.preventDefault();
        getItems().forEach((panel) => panel.classList.remove("drag-target"));
      });
    });
  };

  const openHelp = () => {
    helpModal.classList.add("open");
    helpModal.setAttribute("aria-hidden", "false");
  };
  const closeHelp = () => {
    helpModal.classList.remove("open");
    helpModal.setAttribute("aria-hidden", "true");
  };
  btnHelp.addEventListener("click", openHelp);
  btnHelpClose.addEventListener("click", closeHelp);
  helpModal.addEventListener("click", (e) => { if (e.target === helpModal) closeHelp(); });
  window.addEventListener("keydown", (e) => { if (e.key === "Escape") closeHelp(); });

  const closeMenus = (exceptId = "") => {
    menuGroups.forEach((group) => {
      const button = group.querySelector("[data-menu-target]");
      const popupId = button?.getAttribute("data-menu-target") || "";
      const popup = popupId ? document.getElementById(popupId) : null;
      if (!popup || popupId === exceptId) return;
      popup.classList.remove("open");
      if (button) button.setAttribute("aria-expanded", "false");
    });
  };

  menuButtons.forEach((button) => {
    const popupId = button.getAttribute("data-menu-target");
    const popup = popupId ? document.getElementById(popupId) : null;
    if (!popup) return;
    button.addEventListener("click", (event) => {
      event.stopPropagation();
      const isOpen = popup.classList.contains("open");
      closeMenus();
      if (!isOpen) {
        popup.classList.add("open");
        button.setAttribute("aria-expanded", "true");
      } else {
        popup.classList.remove("open");
        button.setAttribute("aria-expanded", "false");
      }
    });
  });

  document.addEventListener("click", (event) => {
    if (event.target.closest(".menuGroup")) return;
    closeMenus();
  });

  window.addEventListener("keydown", (event) => {
    if (event.key === "Escape") closeMenus();
  });

  el("btnPickAudioFolder").addEventListener("click", () => loadAudioFolder({ reset: true, allowMultiple: true }));
  el("btnAddAudioFolder").addEventListener("click", () => loadAudioFolder({ reset: false, allowMultiple: true }));
  el("btnPlay").addEventListener("click", playAudio);
  el("btnStop").addEventListener("click", stopAudioPlayback);
  el("btnExportAudio").addEventListener("click", exportAudio);
  loopVolumeInput.addEventListener("input", updateLoopControls);
  btnLoopToggle.addEventListener("click", () => {
    loopEnabled = !loopEnabled;
    updateLoopControls();
  });
  btnSaveProg.addEventListener("click", saveCurrentProgression);
  btnLoadProg.addEventListener("click", loadSelectedProgression);
  btnDeleteProg.addEventListener("click", deleteSelectedProgression);
  btnExportProgs.addEventListener("click", exportProgressions);
  btnImportProgs.addEventListener("click", () => importProgFile.click());
  importProgFile.addEventListener("change", (e) => {
    const file = e.target.files?.[0];
    if (file) {
      importProgressions(file);
    }
    e.target.value = "";
  });
  savedProgSelect.addEventListener("change", () => {
    if (btnDeleteProg) btnDeleteProg.disabled = !savedProgSelect.value;
  });

  prog.addEventListener("input", updateQualityMismatch);
  repeatCount.addEventListener("input", updateQualityMismatch);
  barsPerFileInput.addEventListener("input", updateQualityMismatch);
  barsPerChordInput.addEventListener("input", updateQualityMismatch);
  timeSignatureInput.addEventListener("change", updateQualityMismatch);
  refBpmInput.addEventListener("input", () => {
    updateQualityMismatch();
  });
  loopBarsInput.addEventListener("input", updateQualityMismatch);
  startRootInput.addEventListener("change", updateQualityMismatch);
  globalTranspose.addEventListener("input", applyGlobalTranspose);
  window.addEventListener("keydown", (e) => {
    if (e.code !== "Space" && e.key !== " ") return;
    const ae = document.activeElement;
    const tag = ae && ae.tagName ? ae.tagName.toLowerCase() : "";
    const typing = tag === "textarea" || tag === "input" || tag === "select" || (ae && ae.isContentEditable);
    if (typing) return;
    e.preventDefault();
    if (isAudioPlaying) stopAudioPlayback();
    else playAudio();
  });

  prog.value = "";
  initDraggableContainers();
  renderQualityChips();
  renderMixer();
  renderSavedProgressions(getSavedProgressions());
  updateQualityMismatch();
  updateReadyState();
  updateLoopControls();
})();
</script>
</body>
</html>
